* --------------------------------------------------------------------------
* This is the standard INCLUDE file of equates for ODBC defined variables.
* It is located in the demo directory.
* ==========================================================================
*
$INCLUDE INCLUDE ODBC.H
*
* --------------------------------------------------------------------------
* This program will connect to a SQL datasource, create test data in a local
*   UniData file, then update that data to the datasource via BCI.
* ==========================================================================
*
GOSUB SET.CONNECT.INFO
GOSUB ESTABLISH.BCI 
GOSUB CREATE.LOCAL.FILE
GOSUB LOAD.LOCAL.FILE
GOSUB ALLOC.STATEMENT.ENV
GOSUB CREATE.TABLE
GOSUB LOAD.TABLE
GOSUB CONFIRM.TABLE
GOSUB FREE.ENV
*
END.OF.PROGRAM:
STOP "Exiting bcidemo"
*
SET.CONNECT.INFO:
*
* --------------------------------------------------------------------------
* datasource == Name of the established ODBC datasource  
* username   == Name of user as defined on the SQL Database Engine 
* passwd     == Password of user 
* ==========================================================================
*
datasource = "qadb" 
username = "unidata"  
passwd = "qadb" 
RETURN
*
ESTABLISH.BCI:
*
* --------------------------------------------------------------------------
* These are the following steps necessary in any BCI application to 
*   connect to the SQL database.  These connection steps fall into four major
*   parts.  
* --------------------------------------------------------------------------
* Step 1 - Allocate Database Environment
* ==========================================================================
*
STATUS = SQLAllocEnv(database.env)
*
MODULE = "ESTABLISH.BCI"
ENVTYPE = "Database"
Fn = "SQLAllocEnv"
GOSUB CHECK.STATUS
*
* --------------------------------------------------------------------------
* Step 2 - Allocate Connection Environment
* ==========================================================================
*
STATUS = SQLAllocConnect(database.env,connection.env)
*
ENVTYPE = "Connection"
fn = "SQLAllocConnect"
GOSUB CHECK.STATUS
*
CRT "Attempting connect to ":datasource:" with user id ":username
*
* --------------------------------------------------------------------------
* Step 3 - Connecting to Database 
* ==========================================================================
*
STATUS = SQLConnect(connection.env, datasource, username, passwd)
*
ENVTYPE = "Connection"
GOSUB CHECK.STATUS
RETURN
*
ALLOC.STATEMENT.ENV:
*
* --------------------------------------------------------------------------
* Step 4 - Allocate Statement Environment
*          The Statement Environment is used when executing SQL
*          statement functions
* ==========================================================================
*
STATUS = SQLAllocStmt(connection.env,statement.env)
*
MODULE = "ALLOC.statement.env"
Fn = "SQLAllocStmt"
ENVTYPE = "Connection"
GOSUB CHECK.STATUS
RETURN
*
CREATE.LOCAL.FILE:
*
* --------------------------------------------------------------------------
* This subroutine creates a local UniData file, creates dicts, and populates
* it with data.
* ==========================================================================
*
DIM DICT(8)
f = @FM
DICT(2) =  "ID":  f:"D":f:0:f:f:f:"10L":f:"S":f:f:"CHARACTER,10":f
DICT(3) =  "NAME": f:"D":f:1:f:f:f:"10L":f:"S":f:f:"CHARACTER,10":f
DICT(4) =  "GRADE":f:"D":f:2:f:"MD0":f:f:"10R":f:"S":f:f:"INTEGER":f
DICT(5) =  "CITY": f:"D":f:3:f:f:f:"15L":f:"S":f:f:"CHARACTER,15":f
DICT(6) =  "@REVISE": f: "PH":f:f:f:f:f:f:f:f
DICT(7) =  "@":f:"PH":f:"ID.SUP ID NAME GRADE CITY":f:f:f:f:f:f:f
DICT(8) =  "@KEY":f:"PH":f:"ID":f:f:f:f:f:f:f
*
CRT "Deleting local EMPFILE file"
EXECUTE "DELETE.FILE EMPFILE FORCE"
EXECUTE "CREATE.FILE EMPFILE 3"
*
OPEN "DICT","EMPFILE" TO D.EMPFILE ELSE STOP "Failed to open DICT EMPFILE"
REC = ""
FOR INDEX = 2 TO 8
    ID = DICT(INDEX)<1>
    FOR I = 2 TO 9
        REC<I-1> = DICT(INDEX)<I>
    NEXT I
    WRITE REC TO D.EMPFILE, ID
NEXT INDEX
RETURN
*
LOAD.LOCAL.FILE:
*
* --------------------------------------------------------------------------
* This subroutine loads data into the local UniData file
* ==========================================================================
*
DIM EMPDATA(5)
EMPDATA(1) = "E1":@FM:"Alice":@FM: 12:@FM:"Deale"
EMPDATA(2) = "E2":@FM:"Betty":@FM: 10:@FM:"Vienna"
EMPDATA(3) = "E3":@FM:"Carmen":@FM: 13:@FM:"Vienna"
EMPDATA(4) = "E4":@FM:"Don":@FM: 12:@FM:"Deale"
EMPDATA(5) = "E5":@FM:"Ed":@FM: 13:@FM:"Akron"
*
* --------------------------------------------------------------------------
* CLear the files and then load them up 
* ==========================================================================
*
EXECUTE "CLEAR.FILE EMPFILE"
OPEN "EMPFILE" TO EMPFILE ELSE STOP "Failed to open EMPFILE File"
FOR INDEX = 1 TO 5
    REC = EMPDATA(INDEX)
    ID = REC<1>
    DREC = REC<2>:@FM:REC<3>:@FM:REC<4>
    WRITE DREC TO EMPFILE, ID
NEXT INDEX
RETURN
*
CREATE.TABLE:
*
* --------------------------------------------------------------------------
* CreateStmt is a UniBasic variable that will be used to create the 
* SQL table.  The data types are dependent on what kind of data will be used
* and per the ODBC 2.0 spec, what datatypes are available on the SQL DB.
*  
* It is also possible to use the SQLGetTypeInfo function to retrieve supported 
* data types.
* CHAR is the SQL data type used in this example
* ==========================================================================
CreateStmt = "CREATE TABLE EMPTABLE( ID CHAR(10), NAME CHAR(10), GRADE CHAR(10), CITY CHAR(15))"
* --------------------------------------------------------------------------
* DropStmt is a UniBasic variable used to drop or remove EMPTABLE
* ==========================================================================
DropStmt = "DROP TABLE EMPTABLE"
*
CRT "Dropping EMPTABLE table in ":datasource
*
* --------------------------------------------------------------------------
* The drop statement is executed through the Statement Environment
* ==========================================================================
*
STATUS = SQLExecDirect(statement.env, DropStmt)
*
CRT "Creating EMPTABLE table in ":datasource
*
* --------------------------------------------------------------------------
* The create statement executed via the Statement Environment
* ==========================================================================
*
STATUS = SQLExecDirect(statement.env, CreateStmt)
*
MODULE = "CREATE.TABLE"
Expect = ""
ENVTYPE = "Statement"
GOSUB CHECK.STATUS
RETURN
*
LOAD.TABLE: 
*
* --------------------------------------------------------------------------
* This UniBasic variable is using place holders or parameter markers to mark 
* where the data will be loaded.
* ==========================================================================
*
InsertStmt = "INSERT INTO EMPTABLE VALUES (?, ?, ?, ?)"
*
* --------------------------------------------------------------------------
* SQLPrepare will now pass the Insert Statement to the datasource.
*   The Database usually parses the statement in preparation for the
*   execute statement.
* ==========================================================================
*
STATUS = SQLPrepare(statement.env, InsertStmt)
*
MODULE = "LOAD.TABLE"
Fn = "SQLPrepare"
ENVTYPE = "Statement"
GOSUB CHECK.STATUS
*
* --------------------------------------------------------------------------
* The following SQLBindParameter's bind the previous SQLPrepare statement
* It is necessary to bind all parameters before they are executed.  This type
*   of binding is typically done when data will be fetched several times. 
*
* Using the Statement Environment, UniBasic variables will be 
* translated and placed into a field element.
* 
* Param 1 - Name of the Statement Environment
* Param 2 - Number of the table element we're referencing
* Param 3 - The type of conversion to be done to variable
*           SQL.B.BASIC translation allows translation to be determined by the
*             data type on the SQL database.  Can be used with any SQL data
*             type.
* Param 4 - SQL data type
* Param 5 - Scale or size of the field (when applicable with data type)
* Param 6 - Precision (when applicable with data type) 
* Param 7 - UniBasic variable to load.
* ==========================================================================
*
STATUS = SQLBindParameter(statement.env, 1, SQL.B.BASIC, SQL.CHAR, 10, 0, ID)
*
Fn = "SQLBindParameter"
ENVTYPE = "Statement"
GOSUB CHECK.STATUS
*
STATUS = SQLBindParameter(statement.env, 2, SQL.B.BASIC, SQL.CHAR, 10, 0, NAME)
*
GOSUB CHECK.STATUS
*
STATUS = SQLBindParameter(statement.env, 3, SQL.B.BASIC, SQL.CHAR, 10, 0, GRADE)
*
GOSUB CHECK.STATUS
*
STATUS = SQLBindParameter(statement.env, 4, SQL.B.BASIC, SQL.CHAR, 15, 0, CITY)
*
GOSUB CHECK.STATUS
*
ROWNUM = 0
*
* --------------------------------------------------------------------------
* Start loop to retrieve data for SQL Database
* ==========================================================================
*
SELECT EMPFILE
LOOP
    READNEXT ID ELSE ID = "" 
WHILE ID NE "" DO
    ROWNUM += 1
    READ REC FROM EMPFILE, ID ELSE STOP "Error reading local EMPFILE file"
*
* --------------------------------------------------------------------------
* Assigning variables for the needed fields
* ==========================================================================
*
    NAME = REC<1>
    GRADE = REC<2>
    CITY = REC<3>
    CRT "Loading row ":ROWNUM:" from EMPFILE"
*
* --------------------------------------------------------------------------
* SQLExecute knows what to execute from how the Statement Environment was
*   prepared and binded.
* ==========================================================================
*
    STATUS = SQLExecute(statement.env)
*
    Fn = "SQLExecute"
    ENVTYPE = "Statement"
    GOSUB CHECK.STATUS
REPEAT
RETURN
*
CONFIRM.TABLE:
*
MODULE = "CONFIRM.TABLE"
form = "T##########"
dash =  "----------"
* --------------------------------------------------------------------------
* UniBasic variable for executing SQL select on new table
* ==========================================================================
*
SelectStmt = "SELECT ID, NAME, GRADE, CITY FROM EMPTABLE"
*
* --------------------------------------------------------------------------
* Execute select statement via Statement Environment
* ==========================================================================
*
STATUS = SQLExecDirect(statement.env,SelectStmt)
*
Fn = "SQLExecDirect"
ENVTYPE = "Statement"
GOSUB CHECK.STATUS
*
* --------------------------------------------------------------------------
* The following SQLBindCol statements bind the Statement Environment to
*   return values from elements 1 through 4. (Parameter 1 and 2)
*
*   SQL.B.CHAR is used with SQL.CHAR data types for translation
*   SQL.B.NUMBER is used with SQL.NUMERIC data types (Parameter 3)
*
*   Value returned is parameter 4
* ==========================================================================
*
STATUS = SQLBindCol(statement.env, 1, SQL.B.CHAR, ID.RET)
*
Fn = "SQLBindCol"
GOSUB CHECK.STATUS
*
STATUS = SQLBindCol(statement.env, 2, SQL.B.CHAR, NAME.RET)
GOSUB CHECK.STATUS
*
STATUS = SQLBindCol(statement.env, 3, SQL.B.NUMBER, GRADE.RET)
GOSUB CHECK.STATUS

STATUS = SQLBindCol(statement.env, 4, SQL.B.CHAR, CITY.RET)
GOSUB CHECK.STATUS
*
PRINT "ID" form:"NAME" form:"GRADE" form :"CITY" form
PRINT dash form:dash form:dash form :dash form
STATUS = 0
Fn = "SQLFetch"
ENVTYPE = "Statement"
LOOP 
WHILE STATUS <> SQL.NO.DATA.FOUND DO
*
* --------------------------------------------------------------------------
* As we loop through, we'll get the next row of data from columns 1 - 4,
*   populating our new variables
* ==========================================================================
*
    STATUS = SQLFetch(statement.env)
*
    GOSUB CHECK.STATUS
    IF STATUS <> SQL.NO.DATA.FOUND
    THEN 
        CRT ID.RET form:NAME.RET form:GRADE.RET form:CITY.RET
    END
REPEAT
*
ENVTYPE = "Statement"
GOSUB CHECK.STATUS
RETURN
*
FREE.ENV:
*
* --------------------------------------------------------------------------
* The SQLFreeStmt using the SQL.UNBIND will release all bound statements for
*   this Statement Environment.
* ==========================================================================
*
STATUS = SQLFreeStmt(statement.env, SQL.UNBIND)
*
* --------------------------------------------------------------------------
* The SQLFreeStmt with the SQL.DROP option will release or un-allocate the
*   current Statement Environment.
* ==========================================================================
*
STATUS = SQLFreeStmt(statement.env, SQL.DROP)
*
* --------------------------------------------------------------------------
* SQLDisconnect disconnects Connection Environment from the database
* ==========================================================================
*
STATUS = SQLDisconnect(connection.env)
*
* --------------------------------------------------------------------------
* SQLFreeConnect releases the Connection Environment and its resources
* ==========================================================================
*
STATUS = SQLFreeConnect(connection.env)
*
* --------------------------------------------------------------------------
* SQLFreeEnv is the last step in releasing the BCI environment and its 
*   resources
* ==========================================================================
*
STATUS = SQLFreeEnv(database.env)
*
RETURN
*
CHECK.STATUS:
*
* --------------------------------------------------------------------------
* It is a good idea to have some kind of error handling routine.  Depending
*   on the focus of the application it may be necessary to stop processing or
*   it may be ok to continue.
* ==========================================================================
*
EXIT.PROGRAM = 0
BEGIN CASE
    CASE STATUS = SQL.ERROR
        RETMSG = "STATUS is  ":STATUS:" -> Error Occurred."
        EXIT.PROGRAM = 1
    CASE STATUS = SQL.INVALID.HANDLE
        RETMSG = "STATUS is  ":STATUS:" -> Invalid Connection Handle."
        EXIT.PROGRAM = 1
    CASE STATUS = SQL.NEED.DATA
        RETMSG = "STATUS is  ":STATUS:" -> Data Required."
    CASE STATUS = SQL.NO.DATA.FOUND
        RETMSG = "STATUS is ":STATUS:" -> No Data Found." 
    CASE STATUS = SQL.SUCCESS
        RETMSG = "STATUS is ":STATUS:" -> Successful." 
    CASE STATUS = SQL.SUCCESS.WITH.INFO
        RETMSG = "STATUS is ":STATUS:" -> Successful With Info." 
    CASE 1
        RETMSG = "STATUS is ":STATUS:" -> Unknown Status." 
        EXIT.PROGRAM = 1
END CASE
*
BEGIN CASE
    CASE ENVTYPE = "Connection"
        CONNECT.VAR = connection.env
    CASE ENVTYPE = "Statement" 
        CONNECT.VAR = statement.env 
    CASE ENVTYPE = "Database"
        CONNECT.VAR = database.env
END CASE
 *       
IF EXIT.PROGRAM THEN
*
* --------------------------------------------------------------------------
* SQLError returns more information about errors.
* ==========================================================================
*
    ERROR.STATUS = SQLERROR(-1,CONNECT.VAR,-1,STATE,NATCODE,ERRTXT)
    CRT "In Module: ":MODULE
    CRT "Called ":Fn:" function in ":ENVTYPE:" environment."
    CRT RETMSG
    CRT "SQLSTATE , NATCOD are:" : STATE:" , ":NATCODE
    CRT "Error text is ":ERRTXT
    RETURN TO END.OF.PROGRAM
END
RETURN
