1000 * Send Packet ZPKT.TYPE ZLEN ZTXBUF
BEGIN CASE
CASE ZPKT.TYPE = ZPKT.START OR ZPKT.TYPE = ZPKT.INITACK OR ZPKT.TYPE = ZPKT.END OR ZPKT.TYPE = ZPKT.IDLE
FORMAT = ZFMT.HEXPKT
CASE 1
IF TX.HIGHBIT THEN
IF TX.CANKER THEN
FORMAT = ZFMT.KERMIT; KO = 1; KOC = 0
END ELSE
IF TX.CANASC THEN
FORMAT = ZFMT.ASCPKT
END ELSE
FORMAT = ZFMT.HEXPKT
END
END
END ELSE
FORMAT = ZFMT.BINPKT
END
END CASE
TXCANRLE = (TX.CANRLE AND ZPKT.TYPE = ZPKT.DATA)
HEXOUTPUT = (HEX.OUTPUT AND ZPKT.TYPE = ZPKT.DATA)
OUTP = ZDLE:FORMAT:ZPKT.TYPE
CRCRESULT = SEQ(ZPKT.TYPE)
IF ZLEN THEN
BEGIN CASE
CASE FORMAT = ZFMT.BINPKT
FOR L = 1 TO 8
GOSUB 1010
GOSUB 1110
NEXT L
BEGIN CASE
CASE HEXOUTPUT AND TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1040
GOSUB 1110
NEXT L
CASE HEXOUTPUT
FOR L = 9 TO ZLEN
GOSUB 1030
GOSUB 1110
NEXT L
CASE TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1020
GOSUB 1110
NEXT L
CASE 1
FOR L = 9 TO ZLEN
GOSUB 1010
GOSUB 1110
NEXT L
END CASE
CASE FORMAT = ZFMT.HEXPKT
FOR L = 1 TO 8
GOSUB 1010
GOSUB 1120
NEXT L
BEGIN CASE
CASE HEXOUTPUT AND TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1040
GOSUB 1120
NEXT L
CASE HEXOUTPUT
FOR L = 9 TO ZLEN
GOSUB 1030
GOSUB 1120
NEXT L
CASE TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1020
GOSUB 1120
NEXT L
CASE 1
FOR L = 9 TO ZLEN
GOSUB 1010
GOSUB 1120
NEXT L
END CASE
CASE FORMAT = ZFMT.ASCPKT
FOR L = 1 TO 8
GOSUB 1010
GOSUB 1100
NEXT L
BEGIN CASE
CASE HEXOUTPUT AND TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1040
GOSUB 1100
NEXT L
CASE HEXOUTPUT
FOR L = 9 TO ZLEN
GOSUB 1030
GOSUB 1100
NEXT L
CASE TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1020
GOSUB 1100
NEXT L
CASE 1
FOR L = 9 TO ZLEN
GOSUB 1010
GOSUB 1100
NEXT L
END CASE
CASE FORMAT = ZFMT.KERMIT
FOR L = 1 TO 8
GOSUB 1010
GOSUB 1100
NEXT L
BEGIN CASE
CASE HEXOUTPUT AND TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1040
GOSUB 1130
NEXT L
CASE HEXOUTPUT
FOR L = 9 TO ZLEN
GOSUB 1030
GOSUB 1130
NEXT L
CASE TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1020
GOSUB 1130
NEXT L
CASE 1
FOR L = 9 TO ZLEN
GOSUB 1010
GOSUB 1130
NEXT L
END CASE
END CASE
END
IF NOT(NON.RESILIENT) THEN CRCRESULT = ZLEN + 1
GOSUB 2100
OUTP = OUTP:ZDLE:ZFMT.PKTEND:HEXCRC
CRT OUTP:CHAR(13):
IF TU.TRACE THEN TRACE = 'O->':OCONV(OUTP, 'MCP'); GOSUB 6000
RETURN
1010 * get next char C & S with NO RLE encoding
C = ZTXBUF[L, 1]; S = SEQ(C)
CRCRESULT = CRCRESULT + S
RETURN
1020 * get next char C & S and test RLE encoding
C = ZTXBUF[L, 1]; S = SEQ(C)
CRCRESULT = CRCRESULT + S
IF ZTXBUF[L, 3] # C:C:C THEN
IF C = ZRLE.CHAR THEN OUTP = OUTP:ZRLE.CHAR
RETURN
END
RLE = 1
LOOP
C2 = ZTXBUF[L+RLE, 1]
WHILE C2 = C AND C2 # '' DO
RLE = RLE + 1
REPEAT
IF RLE > 2 THEN
IF RLE > 93 THEN RLE = 93
CRCRESULT = CRCRESULT + (S * (RLE - 1))
L = L + RLE - 1
OUTP = OUTP:ZRLE.CHAR:CHAR(RLE + 30)
END
IF C = ZRLE.CHAR THEN OUTP = OUTP:ZRLE.CHAR
RETURN
1030 * get next HEX char C & S with NO RLE encoding
C = ZTXBUF[L, 1]; S = SEQ(C)
L = L + 1; C = OCONV(C:ZTXBUF[L, 1], 'MCU')
S = ICONV(C, MX.CONV)
IF S # 255 THEN
C = CHAR(S)
END ELSE
IF FF.ALLOW THEN C = CHAR(S)
END
CRCRESULT = CRCRESULT + S
RETURN
1040 * get next HEX char C & S and test RLE encoding
C = ZTXBUF[L, 1]; S = SEQ(C)
L = L + 1; C = OCONV(C:ZTXBUF[L, 1], 'MCU')
S = ICONV(C, MX.CONV)
IF S # 255 THEN
C = CHAR(S)
END ELSE
IF FF.ALLOW THEN C = CHAR(S)
END
CRCRESULT = CRCRESULT + S
S2 = ZTXBUF[L-1, 2]
IF ZTXBUF[L+1, 2] # S2 THEN
IF C = ZRLE.CHAR THEN OUTP = OUTP:ZRLE.CHAR
RETURN
END
RLE = 1
LOOP
C2 = ZTXBUF[L+RLE, 1]
RLE = RLE + 1; C2 = OCONV(C2:ZTXBUF[L+RLE, 1], 'MCU')
S2 = ICONV(C2, MX.CONV)
WHILE S2 = S AND C2 # '' DO
RLE = RLE + 1
REPEAT
IF RLE > 4 THEN
RLE = INT(RLE / 2)
IF RLE > 93 THEN RLE = 93
CRCRESULT = CRCRESULT + (S * (RLE - 1))
L = L + (RLE * 2) - 2
OUTP = OUTP:ZRLE.CHAR:CHAR(RLE + 30)
END
IF C = ZRLE.CHAR THEN OUTP = OUTP:ZRLE.CHAR
RETURN
1100 * encode ASCII data
BEGIN CASE
CASE C = "/" OR C = "\"; OUTP = OUTP:C
CASE S > 127; S = S - 128; C = CHAR(S)
IF C = "/" THEN OUTP = OUTP:"\" ELSE OUTP = OUTP:"/"
END CASE
1110 * put Binary BYTE C into OUTP
IF S < 32 OR S = 127 OR S > 251 THEN
OUTP = OUTP:ZDLE
IF S >= 127 THEN
C = CHAR(S - 64)
END ELSE
C = CHAR(S + 64)
END
END
OUTP = OUTP:C
RETURN
1120 * encode HEX data
BEGIN CASE
CASE S > 127; C = OCONV(S, MX.CONV)
OUTP = OUTP:"\":OCONV(C, 'MCL')
CASE S = 127; OUTP = OUTP:ZDLE:CHAR(S - 64)
CASE S < 32; OUTP = OUTP:ZDLE:CHAR(S + 64)
CASE C = '\'; OUTP = OUTP:'\\'
CASE 1; OUTP = OUTP:C
END CASE
RETURN
1130 * encode KERMIT data
IF S < KS(KO, 2) OR S > KS(KO, 3) THEN
BEGIN CASE
CASE S >= KS(1,2) AND S <= KS(1,3); KO = 1
CASE S >= KS(2,2) AND S <= KS(2,3); KO = 2
CASE S >= KS(3,2) AND S <= KS(3,3); KO = 3
CASE S >= KS(4,2) AND S <= KS(4,3); KO = 4
END CASE
OUTP = OUTP:CHAR(126 - KO); KOC = KS(KO, 1)
END
OUTP = OUTP:CHAR(S - KOC)
RETURN
1200 * SEND TX Start packet
OUTP = "_f":SUPPRESS.STATUS:ASCII.MODE:SEMI:APPEND.MODE:CLOSEBRACE
OUTP = OUTP:DOS.FILE.NAME:SEMI:DESCRIPTION
CRT CHAR(27):OUTP:CHAR(27):'\':
IF TU.TRACE THEN TRACE = 'O->':OCONV(OUTP, 'MCP'); GOSUB 6000
RETURN
1210 * SEND RX Start packet
OUTP = "_f":SUPPRESS.STATUS:ASCII.MODE:OPENBRACE
OUTP = OUTP:DOS.FILE.NAME:SEMI:DESCRIPTION
CRT CHAR(27):OUTP:CHAR(27):'\':
IF TU.TRACE THEN TRACE = 'O->':OCONV(OUTP, 'MCP'); GOSUB 6000
RETURN
1230 * SEND RX Data Acknowledgement
POS = RXPOS; GOSUB 3000; ZTXBUF = HEXPOS
ZPKT.TYPE = ZPKT.DATAACK; ZLEN = 8
GOSUB 1000
RETURN
1250 * SEND Abort sequence
CRT STR(ZDLE, 8):STR(CHAR(8), 8):
IF TU.TRACE THEN TRACE = 'O->Abort Sequence'; GOSUB 6000
RETURN
1300 * Recieve Packet
RXBUF = ""; PKT.TYPE = ZNOPKT; RXRLE = 0; RXPKTFORMAT = 0
IF RX.STREAM OR TX.STREAM THEN
INKEY.FLAG = 1
END ELSE
 INCLUDE TUBP INKEY.MORE
END
IF INKEY.FLAG THEN
P = 0; RXDLE = 0
ECHO OFF; !PI/O,PR1ME*!
INPUT RXINBUFF:
ECHO ON; !PI/O,PR1ME*!
IF TU.TRACE THEN TRACE = 'I<-':OCONV(RXINBUFF, 'MCP'); GOSUB 6000
LOOP
RXLEN = LEN(RXINBUFF); IF RXLEN THEN PKT.TYPE = ZPKT.RXBAD
SUBP = 0
LOOP
SUBP = SUBP + 1
CH = RXINBUFF[SUBP, 1]; BYTE = SEQ(CH)
WHILE SUBP <= RXLEN AND P <= ZMAXPKTLEN DO
IF RXDLE OR CH = ZDLE THEN
BEGIN CASE
CASE CH = ZDLE; RXDLE = RXDLE + 1
IF RXDLE > 5 THEN PKT.TYPE = ZCANCEL; RETURN
CASE BYTE = ZBYTE.PKTEND
CRCRESULT = 0; HEXOUT = 0
IF HEX.OUTPUT AND (RXBUF[1, 1] = ZPKT.DATA OR RXBUF[1, 1] = ZPKT.LASTDATA) THEN HEXOUT = 1
BEGIN CASE
CASE RXPKTFORMAT = ZFMT.BINPKT OR RXPKTFORMAT = ZFMT.BIN255
RXPKTLEN = LEN(RXBUF); NEWINP = ''; RXRLE = 0
FOR P = 1 TO RXPKTLEN
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
IF RXPKTFORMAT = ZFMT.BIN255 THEN
IF CH = "\" THEN
IF RXBUF[P, 3] = BYTE255 THEN
P = P + 3; BYTE = 255
END
END
END
BEGIN CASE
CASE CH = ZRLE.CHAR AND RX.CANRLE AND RXRLE < 2
IF RXRLE THEN
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; RXRLE = 0
CRCRESULT = CRCRESULT + BYTE
END ELSE RXRLE = 1
CASE RXRLE
IF RXRLE = 1 THEN
RXRLE = SEQ(CH) - 30
IF RXRLE < 3 THEN RXRLE = 0
END ELSE
IF CH = ZRLE.CHAR THEN P = P + 1
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:STR(CH, RXRLE)
CRCRESULT = CRCRESULT + (BYTE * RXRLE)
RXRLE = 0
END
CASE HEXOUT AND P > 9
CRCRESULT = CRCRESULT + BYTE
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
NEWINP = NEWINP:CH
CASE 1; NEWINP = NEWINP:CH
CRCRESULT = CRCRESULT + BYTE
END CASE
NEXT P
RXBUF = NEWINP; NEWINP = ''; RXRLE = 0
RXPKTLEN = LEN(RXBUF); CH = RXBUF[1, 1]
CASE RXPKTFORMAT = ZFMT.HEXPKT
RXPKTLEN = LEN(RXBUF); NEWINP = ''; RXRLE = 0
FOR P = 1 TO RXPKTLEN
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
BEGIN CASE
CASE CH = ZRLE.CHAR AND RX.CANRLE AND RXRLE < 2
IF RXRLE THEN
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; RXRLE = 0
CRCRESULT = CRCRESULT + BYTE
END ELSE RXRLE = 1
CASE RXRLE
IF RXRLE = 1 THEN
RXRLE = SEQ(CH) - 30
IF RXRLE < 3 THEN RXRLE = 0
END ELSE
IF CH = ZRLE.CHAR THEN P = P + 1
IF CH = '\' THEN
P = P + 1; CH = RXBUF[P, 1]
IF CH # '\' THEN
P = P + 1; CH = OCONV(CH:RXBUF[P, 1], 'MCU')
BYTE = ICONV(CH, MX.CONV)
IF BYTE # 255 THEN
CH = CHAR(BYTE)
END ELSE
IF FF.ALLOW THEN CH = CHAR(BYTE) ELSE CH = "~"
END
END
END
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:STR(CH, RXRLE)
CRCRESULT = CRCRESULT + (BYTE * RXRLE)
RXRLE = 0
END
CASE 1
IF CH = '\' THEN
P = P + 1; CH = RXBUF[P, 1]
IF CH # '\' THEN
P = P + 1; CH = OCONV(CH:RXBUF[P, 1], 'MCU')
BYTE = ICONV(CH, MX.CONV)
IF BYTE # 255 THEN
CH = CHAR(BYTE)
END ELSE
IF FF.ALLOW THEN CH = CHAR(BYTE) ELSE CH = "~"
END
END
END
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; CRCRESULT = MOD(CRCRESULT + BYTE, 256)
END CASE
NEXT P
RXBUF = NEWINP; NEWINP = ''; RXRLE = 0
RXPKTLEN = LEN(RXBUF); CH = RXBUF[1, 1]
CASE RXPKTFORMAT = ZFMT.ASCPKT
RXPKTLEN = LEN(RXBUF); NEWINP = ''; RXRLE = 0
FOR P = 1 TO RXPKTLEN
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
BEGIN CASE
CASE CH = ZRLE.CHAR AND RX.CANRLE AND RXRLE < 2
IF RXRLE THEN
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; RXRLE = 0
CRCRESULT = CRCRESULT + BYTE
END ELSE RXRLE = 1
CASE RXRLE
IF RXRLE = 1 THEN
RXRLE = SEQ(CH) - 30
IF RXRLE < 3 THEN RXRLE = 0
END ELSE
IF CH = ZRLE.CHAR THEN P = P + 1
BEGIN CASE
CASE CH = '\'; P = P + 1; CH = RXBUF[P, 1]
IF CH # '\' THEN BYTE = SEQ(CH) + 128; CH = CHAR(BYTE)
CASE CH = '/'; P = P + 1; CH = RXBUF[P, 1]
IF CH # '/' THEN BYTE = SEQ(CH) + 128; CH = CHAR(BYTE)
END CASE
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:STR(CH, RXRLE)
CRCRESULT = CRCRESULT + (BYTE * RXRLE)
RXRLE = 0
END
CASE 1
BEGIN CASE
CASE CH = '\'; P = P + 1; CH = RXBUF[P, 1]
IF CH # '\' THEN BYTE = SEQ(CH) + 128; CH = CHAR(BYTE)
CASE CH = '/'; P = P + 1; C = RXBUF[P, 1]
IF CH # '/' THEN BYTE = SEQ(CH) + 128; CH = CHAR(BYTE)
END CASE
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; CRCRESULT = CRCRESULT + BYTE
END CASE
NEXT P
RXBUF = NEWINP; NEWINP = ''; RXRLE = 0
RXPKTLEN = LEN(RXBUF); CH = RXBUF[1, 1]
CASE RXPKTFORMAT = ZFMT.KERMIT
RXPKTLEN = LEN(RXBUF); NEWINP = ''; RXRLE = 0
FOR P = 1 TO RXPKTLEN
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
BEGIN CASE
CASE CH = ZRLE.CHAR AND RX.CANRLE AND RXRLE < 2
IF RXRLE THEN
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; RXRLE = 0
CRCRESULT = CRCRESULT + BYTE
END ELSE RXRLE = 1
CASE RXRLE
IF RXRLE = 1 THEN
RXRLE = SEQ(CH) - 30
IF RXRLE < 3 THEN RXRLE = 0
END ELSE
IF CH = ZRLE.CHAR THEN P = P + 1
IF BYTE > 121 AND BYTE < 126 THEN
KOC = KS(126 - BYTE, 1); P = P + 1
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
END
BYTE = BYTE + KOC
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END ELSE CH = CHAR(BYTE)
NEWINP = NEWINP:STR(CH, RXRLE)
CRCRESULT = CRCRESULT + (BYTE * RXRLE)
RXRLE = 0
END
CASE BYTE > 121; KOC = KS(126 - BYTE, 1)
CASE 1
BYTE = BYTE + KOC
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END ELSE CH = CHAR(BYTE)
NEWINP = NEWINP:CH; CRCRESULT = CRCRESULT + BYTE
END CASE
NEXT P
RXBUF = NEWINP; NEWINP = ''; RXRLE = 0
RXPKTLEN = LEN(RXBUF); CH = RXBUF[1, 1]
CASE 1; CH = ZNOPKT; RXPKTLEN = 0
END CASE
IF CH # ZNOPKT THEN
IF RXPKTLEN < 1 THEN CH = ZNOPKT; GOTO 1390
CRC = RXINBUFF[SUBP+1, 2]; CRC = OCONV(CRC, 'MCU')
CRC = ICONV(CRC, MX.CONV) + 0
GOSUB 2000
N = CRCRESULT + 0
RXPKTLEN = RXPKTLEN - 1
IF N = CRC THEN
PKT.TYPE = RXBUF[1, 1]; RETURN
END ELSE
IF TU.TRACE THEN
TRACE = 'Bad CRC: ':N:' # ':CRC:' ZLEN=':ZLEN
GOSUB 6000
END
END
END
PKT.TYPE = ZPKT.RXBAD; RETURN
CASE BYTE >= ZBYTE.BINPKT AND BYTE <= ZBYTE.KERMIT
RXPKTFORMAT = CH; RXDLE = 0; P = 1; RXBUF = ""; KO = 1; KOC = 0
IF TEST.BAD THEN
IF RXINBUFF[SUBP+1, 1] = ZPKT.DATA THEN
HEXPOS = RXINBUFF[SUBP+2, 8]; GOSUB 3100
IF POS # RXPOS THEN
RXBUF = RXINBUFF[SUBP+1, 9]
IF TU.TRACE THEN TRACE = 'I<-ZPKT.BAD'; GOSUB 6000
PKT.TYPE = ZPKT.RXBAD; RETURN
END
END
END
CASE BYTE < 32 OR BYTE = 127; GOTO 1390
CASE BYTE = 191
IF HEX.OUTPUT OR NOT(FF.ALLOW) THEN
RXPKTFORMAT = ZFMT.BIN255
RXBUF = RXBUF:BYTE255
END ELSE
RXBUF = RXBUF:CHAR(255)
END
P = P + 1; RXDLE = 0
CASE 1
IF BYTE > 63 AND BYTE < 188 THEN
RXBUF = RXBUF:CHAR(BYTE - 64)
END ELSE
RXBUF = RXBUF:CHAR(BYTE + 64)
END
P = P + 1; RXDLE = 0
END CASE
END ELSE
IF BYTE < 32 OR BYTE = 127 THEN GOTO 1390
RXBUF = RXBUF:CH; P = P + 1
END
1390 *
REPEAT
IF P <= ZMAXPKTLEN THEN
IF TX.STREAM OR RX.STREAM THEN
INKEY.FLAG = 1
END ELSE
 INCLUDE TUBP INKEY.MORE
END
IF INKEY.FLAG THEN
ECHO OFF; !PI/O,PR1ME*!
INPUT RXINBUFF:
ECHO ON; !PI/O,PR1ME*!
IF TU.TRACE THEN TRACE = 'i<-':OCONV(RXINBUFF, 'MCP'); GOSUB 6000
END ELSE P = 0; RXINBUFF = ''
END ELSE P = 0; RXINBUFF = ''
WHILE P OR RXINBUFF # '' DO
REPEAT
END
T = TIME()
IF BRAINDEAD AND T > BRAINDEAD THEN
PKT.TYPE = ZBRAINTIME
END
IF TXTIMER AND T > TXTIMER THEN
PKT.TYPE = ZTXTIME
END
RETURN
2000 * Test CRC wrt ZLEN
IF NOT(NON.RESILIENT) THEN CRCRESULT = ZLEN
2100 * build HEX CRC bytes
CRCRESULT = MOD(CRCRESULT, 256)
HEXCRC = OCONV(CRCRESULT, MX.CONV); HEXCRC = OCONV(HEXCRC, 'MCL')
IF LEN(HEXCRC) < 2 THEN HEXCRC = STR('0', 2-LEN(HEXCRC)):HEXCRC
RETURN
3000 * Convert decimal signed POS into Hex HEXPOS
IF POS >= 0 THEN
HEXPOS = OCONV(POS, MX.CONV); HEXPOS = OCONV(HEXPOS, 'MCL')
IF LEN(HEXPOS) < 8 THEN HEXPOS = STR('0', 8-LEN(HEXPOS)):HEXPOS
END ELSE
HEXPOS = "FFFFFFF"; APOS = 16 + POS; XPOS = OCONV(APOS, MX.CONV)
IF LEN(XPOS) > 1 THEN XPOS = XPOS[LEN(XPOS), 1]
HEXPOS = HEXPOS:XPOS; HEXPOS = OCONV(HEXPOS, 'MCL')
END
RETURN
3100 * Convert HEXPOS into decimal signed POS
IF HEXPOS = "" THEN POS = 0; RETURN
HEXPOS = OCONV(HEXPOS, 'MCU')
POS = ICONV(HEXPOS, MX.CONV)
IF POS > 4294967279 THEN POS = POS - 4294967296
RETURN
5000 * Update output
IF FTP.MODE THEN
RXBUFFER = ''
OK = 1 ; BYTE.PTR = 0; NOCONVERT ON ;!*UDT*!
OSOPEN PFNAME TO F.TMP ELSE STATUS = FTE.HOSTFILE.OPEN.ERROR ; RETURN ;!*UDT*!
LOOP WHILE OK DO ;!*UDT*!
OSBREAD DATA.IN FROM F.TMP AT BYTE.PTR LENGTH BLK.SIZE ON ERROR DATA.IN = "" ;!*UDT*!
BYTE.PTR = BYTE.PTR + BLK.SIZE ;!*UDT*!
IF DATA.IN = "" THEN OK = 0 ;!*UDT*!
RXBUFFER = RXBUFFER:DATA.IN ;!*UDT*!
REPEAT ;!*UDT*!
NOCONVERT OFF ; !*UDT*!
!@!OK = 1 ; !*UV,UP*!
!@!OPENSEQ PFNAME TO F.TMP THEN ; !*UV,UP*!
!@!LOOP WHILE OK DO ; !*UV,UP*!
!@!READBLK DATA.IN FROM F.TMP,BLK.SIZE ELSE DATA.IN = '' ; !*UV,UP*!
!@!IF DATA.IN = "" THEN OK = 0 ; !*UV,UP*!
!@!RXBUFFER = RXBUFFER:DATA.IN ; !*UV,UP*!
!@!REPEAT ; !*UV,UP*!
!@!CLOSESEQ F.TMP ; !*UV,UP*!
!@!END ; !*UV,UP*!
!@!L = 10000; POINTER = 1; !*AP*!
!@!DIM MATRIX(100); MAT MATRIX = ''; !*AP*!
!@!F.TMP = %OPEN(PFNAME, 2); !*AP*!
!@!IF F.TMP < 0 THEN RETURN; !*AP*!
!@!CHAR BUFFER[L]; !*AP*!
!@!LOOP; !*AP*!
!@!N = %READ(F.TMP, BUFFER, L); !*AP*!
!@!IF N THEN; !*AP*!
!@!IF N = L THEN; !*AP*!
!@!MATRIX(POINTER) = BUFFER; !*AP*!
!@!END ELSE; !*AP*!
!@!MATRIX(POINTER) = BUFFER[1, N]; !*AP*!
!@!END; !*AP*!
!@!POINTER = POINTER + 1; !*AP*!
!@!IF POINTER > 100 THEN; !*AP*!
!@!MATBUILD RXBUFFER FROM MATRIX USING ""; !*AP*!
!@!MAT MATRIX = ""; !*AP*!
!@!MATRIX(1) = RXBUFFER; POINTER = 2; RXBUFFER = ''; !*AP*!
!@!END; !*AP*!
!@!END; !*AP*!
!@!WHILE N = L DO; !*AP*!
!@!REPEAT; !*AP*!
!@!MATBUILD RXBUFFER FROM MATRIX USING ""; !*AP*!
!@!MAT MATRIX = ""; !*AP*!
!@!%CLOSE(F.TMP); !*AP*!
IF HEX.OUTPUT THEN; !*UDT,UP,UV*!
RXBUFF.LEN = LEN(RXBUFFER); NEW.RXBUFFER = ""; !*UDT,UP,UV*!
FOR I = 1 TO RXBUFF.LEN; !*UDT,UP,UV*!
S = SEQ(RXBUFFER[I,1]); !*UDT,UP,UV*!
CH = OCONV(S, MX.CONV); !*UDT,UP,UV*!
IF LEN(CH) = 1 THEN CH = "0":OCONV(CH, "MCU"); !*UDT,UP,UV*!
NEW.RXBUFFER = NEW.RXBUFFER:CH; !*UDT,UP,UV*!
NEXT I; !*UDT,UP,UV*!
RXBUFFER = NEW.RXBUFFER ; NEW.RXBUFFER = ""; !*UDT,UP,UV*!
END; !*UDT,UP,UV*!
END
IF CACHE.PTR THEN
IF RXBUFFER > "" THEN
CACHE.PTR = CACHE.PTR + 1
CACHE(CACHE.PTR) = RXBUFFER; RXBUFFER = ""
END
FOR I = 1 TO CACHE.PTR
RXBUFFER = RXBUFFER:CACHE(I); CACHE(I) = ''
IF SPLIT.SIZE THEN
IF LEN(RXBUFFER) > SPLIT.SIZE THEN
SPLIT.CNT = SPLIT.CNT + 1
CACHE.ID = RXITEM:DOT:SPLIT.CNT
WRITE RXBUFFER ON F.RXFILE, CACHE.ID
RXBUFFER = ''
STATUS = FTE.USING.CACHE
RTN.STR<1,-1> = CACHE.ID
END
END
NEXT I
END
IF SPOOLER.OUTPUT THEN
BUFLEN = LEN(RXBUFFER); L = 80
IF BUFLEN THEN
PRINTER ON
FOR I = 1 TO BUFLEN STEP L
PRINT RXBUFFER[I, L]:
NEXT I
PRINTER OFF; RXBUFFER = ""
END
RETURN
END
IF RXITEM = "" THEN
IF TU.TRACE THEN TRACE = "In memory transfer." ; GOSUB 6000
RXITEM = RXBUFFER; RXBUFFER = ""
END ELSE
IF BINARY AND OS.FILE THEN
IF TU.TRACE THEN TRACE = "Binary transfer, writting OS file." ; GOSUB 6000
!@!WRITEBLK RXBUFFER ON F.RXFILE ELSE STATUS = FTE.WRITE.ERROR; !*UP,UV*!
!@!!!!FLUSH F.RXFILE ELSE NULL ; !*UV,UP*!
!@!CLOSESEQ F.RXFILE ; !*UV,UP*!
NOCONVERT ON; !*UDT,UDTVMS*!
OSBWRITE RXBUFFER ON F.RXFILE AT 0 ON ERROR STATUS = FTE.WRITE.ERROR; !*UDT,UDTVMS*!
NOCONVERT OFF; !*UDT,UDTVMS*!
OSCLOSE F.RXFILE ON ERROR NULL ;!*UDT,UDTVMS*!
END ELSE
IF TU.TRACE THEN TRACE = "Non binary transfer, writting to DB file." ; GOSUB 6000
WRITE RXBUFFER ON F.RXFILE, RXITEM
END
RTN.STR<1,-1> = RXITEM
END
RETURN
6000 * Output TRACE data
TU.TRACE = TU.TRACE + 1; SBMMV = MOD(TU.TRACE,DBGMOD)
SBMMID = 'SBZ.':PORTNO:'.':INT(TU.TRACE / DBGMOD)
TRACE = OCONV(TIME(), 'MTS'):SPCE:TRACE
WRITEV TRACE ON TUSTATE,SBMMID,SBMMV
RETURN
