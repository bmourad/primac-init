SUBROUTINE TU.SBZ_2428(TXDATA, DOS.FILE.NAME, F.RXFILE, MAX.ITEM.SIZE, RXITEM, OPTIONS, RTN.STR, DESCRIPTION, STATUS)
 INCLUDE TU2428BP USER.INCLUDE.H
 INCLUDE TU2428BP TU.SBZ.H
!@! INCLUDE UNIVERSE.INCLUDE MACHINE.NAME ; !*UV,UP*!
!@! INCLUDE UNIVERSE.INCLUDE FILENAMES.H ; !*UV,UP*!
!@!EQU AM TO CHAR(254), VM TO CHAR(253), SVM TO CHAR(252); !*-UV,-UP,-UDT*!
EQU AM TO @AM, VM TO @VM, SVM TO @SVM ; !*UV,UP,UDT*!
EQU SEMI TO ';', CLOSEBRACE TO '}', OPENBRACE TO '{', SPCE TO ' ', DOT TO '.'
EQU DBGMOD TO 10000, ZTIME.OUT TO 60
DIM CACHE(30)
DIM KS(4, 3)
IF TXDATA # "" THEN TXFD = 1 ELSE TXFD = -1
GOSUB 9900
 INCLUDE TU2428BP ECHO.OFF.H
!@!ECHO ON ;!*PI/O,PR1ME*!
LOOP
BEGIN CASE
CASE TXSTATE = ZTX.START
IF TXRETRIES = 10 THEN STATUS = XFER.RETRY; GOTO 900
ZPKT.TYPE = ZPKT.START
IF TXFD = 1 THEN
RXSTATE = ZRX.WAIT; GOSUB 1200
END ELSE
GOSUB 1210
END
TXTIMER = TIME() + ZSTART; TXSTATE = ZTX.SWAIT
CASE TXSTATE = ZTX.INIT
ZPKT.TYPE = ZPKT.INIT
ZTXBUF = XFEROPTS
POS = TXBLKLEN; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
POS = RXBLKLEN; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
IF TXFD = 1 THEN
IF FTP.MODE THEN
PFNAME = FTPDIR:"SBZ.DL.":PORTNO
IF RUNNING.NT THEN
!@!EXECUTE OS.EXEC:' ':RM.CMD:' ':PFNAME ; !*UV,UP*!
!@!EXECUTE OS.EXEC:' ':TOUCH.CMD:' ':PFNAME ; !*UV,UP*!
END ELSE
!@!EXECUTE "sh -c 'rm ":PFNAME:"'" ;!*UV,UP*!
!@!EXECUTE "sh -c 'touch ":PFNAME:"'" ;!*UV,UP*!
END
!@!OPENSEQ PFNAME TO F.TMP ELSE STATUS = FTE.HOSTFILE.OPEN.ERROR; RETURN; !*UV,UP*!
OSDELETE PFNAME ON ERROR NULL ; !*UDT*!
OSWRITE "" ON PFNAME ON ERROR NULL ; !*UDT*!
OSOPEN PFNAME TO F.TMP ELSE STATUS = FTE.HOSTFILE.OPEN.ERROR; RETURN; !*UDT*!
!@!F.TMP = %OPEN(PFNAME, 770, 511); !*AP*!
IF TU.TRACE THEN TRACE = "Opened OS file ":PFNAME ; GOSUB 6000
NOCONVERT ON ; BYTE.PTR = 0 ; !*UDT*!
IF NO.BLK.DOWN THEN
FOR BLK.CNT = 1 TO NO.BLK.DOWN
READ TXDATA FROM F.SOURCE, 'XFER.DATA.':BLK.CNT ELSE NULL
IF BLK.CNT > 1 THEN TXDATA = AM:TXDATA ELSE
IF TXHEADER # "" THEN TXDATA = TXHEADER:AM:TXDATA
END
OSBWRITE TXDATA ON F.TMP AT BYTE.PTR ON ERROR STATUS = FTE.FILE.WRITE.ERROR; !*UDT*!
BYTE.PTR = BYTE.PTR + LEN(TXDATA);!*UDT*!
!@!WRITEBLK TXDATA ON F.TMP THEN NULL ;!*UV,UP*!
!@!%WRITE(F.TMP, TXDATA, LEN(TXDATA)); !*AP*!
IF TU.TRACE THEN TRACE = "Writing blocked data to OS file."; GOSUB 6000
NEXT BLK.CNT
END ELSE
IF HEX.OUTPUT THEN; !*UDT,UP,UV*!
TXBUFF.LEN = LEN(TXDATA) ; NEW.TXBUFF = ''; !*UDT,UP,UV*!
FOR I = 1 TO TXBUFF.LEN STEP 2; !*UDT,UP,UV*!
CH = TXDATA[I,2]; !*UDT,UP,UV*!
S = ICONV(CH, MX.CONV); !*UDT,UP,UV*!
NEW.TXBUFF = NEW.TXBUFF:CHAR(S); !*UDT,UP,UV*!
NEXT I; !*UDT,UP,UV*!
TXDATA = NEW.TXBUFF; !*UDT,UP,UV*!
TXDATA.LEN = TXBUFF.LEN / 2; !*UDT,UP,UV*!
END; !*UDT,UP,UV*!
OSBWRITE TXDATA ON F.TMP AT 0 ON ERROR STATUS = FTE.FILE.WRITE.ERROR; !*UDT*!
!@!WRITEBLK TXDATA ON F.TMP THEN NULL ;!*UV,UP*!
!@!L = LEN(TXDATA); WLEN = 10000; !*AP*!
!@!IF L > WLEN THEN; !*AP*!
!@!LIM = INT(L / WLEN) + 1; !*AP*!
!@!FOR I = 1 TO LIM; !*AP*!
!@!O = 1 + ((I-1) * WLEN); S = WLEN; !*AP*!
!@!IF (I * WLEN) > L THEN S = L - ((I-1) * WLEN); !*AP*!
!@!BUFFER = TXDATA[O, S]; !*AP*!
!@!%WRITE(F.TMP, BUFFER, S); !*AP*!
!@!NEXT I; !*AP*!
!@!END ELSE %WRITE(F.TMP, TXDATA, L); !*AP*!
IF TU.TRACE THEN TRACE = "Writing data to OS file."; GOSUB 6000
END
OSCLOSE F.TMP; !*UDT*!
NOCONVERT OFF; !*UDT*!
EXECUTE '!chmod 777 ':PFNAME CAPTURING CAPT ;!*UDT*!
!@!CLOSESEQ F.TMP ;!*UV,UP*!
!@!IF NOT(RUNNING.NT) THEN EXECUTE "sh -c 'chmod 777 ":PFNAME:"'" ;!*UV,UP*!
!@!%CLOSE(F.TMP); !*AP*!
!@!%CHMOD(PFNAME, 511); !*AP*!
IF TU.TRACE THEN TRACE = "Closing OS file and cleaning up."; GOSUB 6000
ZTXBUF = ZTXBUF:SEMI:PFNAME:SEMI:TXDATA.LEN; !*AP,UDT,UP,UV*!
END ELSE
POS = TXDATA.LEN; IF HEX.OUTPUT THEN POS = INT(POS / 2)
IF NOT(BINARY) THEN POS = POS + COUNT(TXDATA, AM)
ZTXBUF = ZTXBUF:SEMI:POS
END
END ELSE
IF FTP.MODE THEN
PFNAME = FTPDIR:"SBZ.UL.":PORTNO
NOCONVERT ON; OSWRITE 'dummy' ON PFNAME; NOCONVERT OFF ;!*UDT*!
EXECUTE '!chmod 777 ':PFNAME CAPTURING CAPT ;!*UDT*!
IF RUNNING.NT THEN
!@!EXECUTE OS.EXEC:' ':RM.CMD:' ':PFNAME ; !*UV,UP*!
!@!EXECUTE OS.EXEC:' ':TOUCH.CMD:' ':PFNAME ; !*UV,UP*!
END ELSE
!@!EXECUTE "sh -c 'rm ":PFNAME:"'" ;!*UV,UP*!
!@!EXECUTE "sh -c 'touch ":PFNAME:"'" ;!*UV,UP*!
END
!@!OPENSEQ PFNAME TO F.TMP ELSE STATUS = FTE.HOSTFILE.OPEN.ERROR; RETURN;!*UV,UP*!
!@!WRITEBLK TXDATA ON F.TMP THEN NULL ;!*UV,UP*!
!@!CLOSESEQ F.TMP ;!*UV,UP*!
!@!IF NOT(RUNNING.NT) THEN EXECUTE "sh -c 'chmod 777 ":PFNAME:"'" ;!*UV,UP*!
!@!F.TMP = %OPEN(PFNAME, 770, 511); !*AP*!
!@!IF F.TMP THEN; !*AP*!
!@!%CLOSE(F.TMP); !*AP*!
!@!%CHMOD(PFNAME, 511); !*AP*!
!@!END; !*AP*!
ZTXBUF = ZTXBUF:SEMI:PFNAME
END ELSE
ZTXBUF = ZTXBUF:SEMI:ACKAFTER + 1
END
END
ZLEN = LEN(ZTXBUF); GOSUB 1000
TXTIMER = TIME() + INT(TIME.OUT / 2); TXSTATE = ZTX.INITACK
IF FTP.MODE THEN TXTIMER = 0; TXSTATE = ZTX.EOFACK
CASE TXSTATE = ZTX.XDATA
ZPKT.TYPE = ZPKT.DATA; ZLEN = 0
POS = TXPOS; IF HEX.OUTPUT THEN POS = INT(POS / 2)
GOSUB 3000; ZTXBUF = HEXPOS
IF TXPOS < 0 THEN
I = -1
END ELSE
IF NO.BLK.DOWN THEN
BLK.POS = TXPOS - OLD.POS
NEWTXBUF = TXDATA[BLK.POS + 1, TXBLKLEN]
IF TU.TRACE THEN TRACE = "Processing Data Block: ":BLK.CNT:" of ":NO.BLK.DOWN; GOSUB 6000
IF LEN(NEWTXBUF) < TXBLKLEN THEN
IF TU.TRACE THEN TRACE = "Reading new Data Block..."; GOSUB 6000
BLK.CNT = BLK.CNT + 1
IF BLK.CNT <= NO.BLK.DOWN THEN
OLD.POS = TXPOS; BLK.POS = 0
READ TXDATA FROM F.SOURCE, 'XFER.DATA.':BLK.CNT THEN
IF BLK.CNT < 2 THEN
IF TXHEADER # "" THEN TXDATA = TXHEADER:AM:TXDATA
END ELSE
TXDATA = NEWTXBUF:AM:TXDATA
END
ZTXBUF = ZTXBUF:TXDATA[BLK.POS+1, TXBLKLEN]
I = LEN(ZTXBUF) - 8
END ELSE
ZTXBUF = ZTXBUF:NEWTXBUF
I = LEN(ZTXBUF) - 8
END
END ELSE
ZTXBUF = ZTXBUF:NEWTXBUF
I = LEN(ZTXBUF) - 8
END
END ELSE
ZTXBUF = ZTXBUF:NEWTXBUF
I = LEN(ZTXBUF) - 8
END
END ELSE
ZTXBUF = ZTXBUF:TXDATA[TXPOS + 1, TXBLKLEN]
I = LEN(ZTXBUF) - 8
END
END
IF I > 0 THEN
TXPOS = TXPOS + I; ZLEN = I + 8
GOSUB 1000
TXGOODBYTES = TXGOODBYTES + I
IF TXBLKLEN < TXMAXBLKLEN AND TXGOODBYTES >= TXGOODNEEDED THEN
TXBLKLEN = TXBLKLEN * 2
IF TXBLKLEN >= TXMAXBLKLEN THEN
TXBLKLEN = TXMAXBLKLEN; TXGOODNEEDED = 0
END
END
IF TXWINDOW AND (TXPOS >= TXLASTACK + TXWINDOW) THEN
TXTIMER = TIME() + INT(TIME.OUT / 2)
TXSTATE = ZTX.DATAACK
END
IF NOT(TXSTART) THEN TXSTART = TIME()
END ELSE
ZPKT.TYPE = ZPKT.EOF; ZLEN = 8
GOSUB 1000
TXTIMER = TIME() + TIME.OUT; TXSTATE = ZTX.EOFACK
END
CASE TXSTATE = ZTX.EOF
ZPKT.TYPE = ZPKT.EOF; ZLEN = 8
POS = TXPOS; IF HEX.OUTPUT THEN POS = INT(POS / 2)
GOSUB 3000; ZTXBUF = HEXPOS
GOSUB 1000
TXTIMER = TIME() + INT(TIME.OUT / 2); TXSTATE = ZTX.EOFACK
CASE TXSTATE = ZTX.END
ZPKT.TYPE = ZPKT.END; ZLEN = 0; ZTXBUF = ""
GOSUB 1000
ZPKT.TYPE = ZPKT.END; ZLEN = 0; ZTXBUF = ""
GOSUB 1000
TXTIMER = TIME() + INT(TIME.OUT / 2); TXSTATE = ZTX.ENDACK
END CASE
LOOP
GOSUB 1300
IF TXSTATE AND PKT.TYPE # ZNOPKT THEN
BEGIN CASE
CASE PKT.TYPE = ZCANCEL OR PKT.TYPE = ZBRAINTIME
TXSTATE = ZTX.DONE; SBZ.ERR = SEQ(RXINBUFF[7,1])
BEGIN CASE
CASE SBZ.ERR = 1
STATUS = FTE.EOF
CASE SBZ.ERR = 2
STATUS = FTE.ABORT
CASE SBZ.ERR = 3
STATUS = FTE.READ.ERROR
CASE SBZ.ERR = 4
STATUS = FTE.WRITE.ERROR
CASE SBZ.ERR = 5
STATUS = FTE.PROTOCOL.ERROR
CASE SBZ.ERR = 6
STATUS = FTE.CONFIG.ERROR
CASE SBZ.ERR = 7
STATUS = FTE.START.ERROR
CASE SBZ.ERR = 8
STATUS = FTE.INTERNAL.ERROR
CASE SBZ.ERR = 9
STATUS = FTE.OPEN.ERROR
CASE SBZ.ERR = 10
STATUS = FTE.POSITION.ERROR
CASE 1
STATUS = FTE.UNKNOWN.ERROR
END CASE
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' ->Abort'; GOSUB 6000
TRACE = 'RXINBUFF=':RXINBUFF; GOSUB 6000
TRACE = 'RXBUFF=':RXBUFFER; GOSUB 6000
END
IF PKT.TYPE = ZCANCEL THEN
ZPKT.TYPE = ZPKT.EOF; ZLEN = 8; TXPOS = 0; TXFD = 1
POS = TXPOS; IF HEX.OUTPUT THEN HEX.OUTPUT = 0
GOSUB 3000; ZTXBUF = HEXPOS; RXPOS = 0
GOSUB 1000
TXTIMER = TIME() + ZSTART; TXSTATE = ZTX.EOFACK
END ELSE GOTO 900
CASE PKT.TYPE = ZTXTIME OR PKT.TYPE = ZPKT.NACK
IF TXSTATE = ZTX.XWAIT OR TXSTATE = ZTX.REND THEN
ZPKT.TYPE = ZPKT.IDLE; ZLEN = 0; ZTXBUF = ""
GOSUB 1000
TXTIMER = TIME() + ZIDLE
END ELSE
TXRETRIES = TXRETRIES + 1
IF TXRETRIES > ZRETRIES THEN
TXSTATE = ZTX.DONE; STATUS = XFER.RETRY
GOSUB 1250
END ELSE
TXTIMER = 0
IF RXSTATE = ZRX.INIT THEN
BEGIN CASE
CASE TXSTATE = ZTX.SWAIT; TXSTATE = ZTX.START
CASE TXSTATE = ZTX.INITACK; TXSTATE = ZTX.INIT
CASE TXSTATE = ZTX.DATAACK; TXSTATE = ZTX.XDATA
CASE TXSTATE = ZTX.EOFACK; TXSTATE = ZTX.EOF
CASE TXSTATE = ZTX.ENDACK; TXSTATE = ZTX.END
CASE TXSTATE = ZTX.XDATA
IF TXRETRIES > INT(ZRETRIES/2) THEN
GOSUB 1000; TXTIME = TIME() + INT(TIME.OUT / 2)
END
END CASE
END ELSE
IF ZPKT.TYPE # ZPKT.START THEN
GOSUB 1000; TXTIME = TIME() + INT(TIME.OUT / 2)
END
END
END
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' retry - TXSTATE=':TXSTATE
TRACE = TRACE:' & RXSTATE=':RXSTATE; GOSUB 6000
END
END
CASE PKT.TYPE = ZPKT.START OR PKT.TYPE = ZPKT.FTP
IF PKT.TYPE = ZPKT.FTP THEN FTP.MODE = 1
IF TXSTATE = ZTX.START OR TXSTATE = ZTX.SWAIT THEN
TXTIMER = 0; TXRETRIES = 0; TXSTATE = ZTX.INIT
BRAINDEAD = TIME() + ZBRAINDEAD
END
CASE PKT.TYPE = ZPKT.INIT
IF LEN(RXBUF) > 32 THEN
XFEROPTS = RXBUF[2, 16]
TX.XONXOFF = XFEROPTS[ZOPT.TX.XONXOFF, 1]
TX.CTLCHRS = XFEROPTS[ZOPT.TX.CTLCHRS, 1]
TX.HIGHCTL = XFEROPTS[ZOPT.TX.HIGHCTL, 1]
Z = XFEROPTS[ZOPT.TX.HIGHBIT, 1]
IF Z THEN TX.HIGHBIT = Z
TX.CANASC = XFEROPTS[ZOPT.TX.CANASC, 1]
TX.CANRLE = XFEROPTS[ZOPT.TX.CANRLE, 1]
TX.CANKER = XFEROPTS[ZOPT.TX.CANKER, 1]
TX.STREAM = XFEROPTS[ZOPT.TX.STREAM, 1]
RX.XONXOFF = XFEROPTS[ZOPT.RX.XONXOFF, 1]
RX.CTLCHRS = XFEROPTS[ZOPT.RX.CTLCHRS, 1]
RX.HIGHCTL = XFEROPTS[ZOPT.RX.HIGHCTL, 1]
Z = XFEROPTS[ZOPT.RX.HIGHBIT, 1]
IF Z THEN RX.HIGHBIT = Z
RX.CANASC = XFEROPTS[ZOPT.RX.CANASC, 1]
RX.CANRLE = XFEROPTS[ZOPT.RX.CANRLE, 1]
RX.CANKER = XFEROPTS[ZOPT.RX.CANKER, 1]
RX.STREAM = XFEROPTS[ZOPT.RX.STREAM, 1]
HEXPOS = RXBUF[18, 8]; GOSUB 3100; TXBLKLEN = POS
HEXPOS = RXBUF[26, 8]; GOSUB 3100; RXBLKLEN = POS
IF RXSTATE = ZRX.INIT THEN
RXSTATE = ZRX.DATA; TXTIMER = 0
ZPKT.TYPE = ZPKT.INITACK; RXPOS = 0
POS = RXPOS; GOSUB 3000; ZTXBUF = HEXPOS
END
END ELSE
ZPKT.TYPE = ZPKT.NACK; ZTXBUF = ""
TXTIMER = TIME() + TIME.OUT
END
IF RXSTATE = ZRX.INIT OR RXSTATE = ZRX.DATA THEN
ZLEN = LEN(ZTXBUF)
GOSUB 1000
END ELSE
BRAINDEAD = 0; TXTIMER = 0; TXRETRIES = 0
IF TXFD # 1 THEN
RXSTATE = ZRX.DATA; TXSTATE = ZTX.XWAIT
END ELSE
TXLASTACK = TXPOS; TXSTATE = ZTX.XDATA
END
END
CASE PKT.TYPE = ZPKT.INITACK
IF TXSTATE = ZTX.INIT OR TXSTATE = ZTX.INITACK THEN
BRAINDEAD = 0; TXTIMER = 0; TXRETRIES = 0
IF TXFD # 1 THEN
RXSTATE = ZRX.DATA; TXSTATE = ZTX.XWAIT
END ELSE
HEXPOS = RXBUF[2, 8]; GOSUB 3100; TXPOS = POS
IF HEX.OUTPUT THEN TXPOS = TXPOS * 2
IF TXPOS >= 0 THEN
TXLASTACK = TXPOS; TXSTATE = ZTX.XDATA
END ELSE
STATUS = XFER.OK; GOTO 900
END
END
END
CASE PKT.TYPE = ZPKT.DATA OR PKT.TYPE = ZPKT.RXBAD OR PKT.TYPE = ZPKT.LASTDATA
IF RXSTATE = ZRX.DATA THEN
HEXPOS = RXBUF[2, 8]; GOSUB 3100
IF POS # RXPOS OR POS < 0 OR PKT.TYPE = ZPKT.RXBAD THEN
TEST.BAD = 1
IF TU.TRACE THEN
TRACE = 'bad PKT.TYPE=':PKT.TYPE:' POS=':POS:' RXPOS=':RXPOS
GOSUB 6000
END
IF POS <= RXLASTSYNC THEN
RXRETRIES = 0; RXTIMER = 0
END
RXLASTSYNC = RXPOS
IF NOT(RXTIMER) OR TIME() > RXTIMER THEN
IF RXRETRIES > 4 THEN
IF TXSTATE < ZTX.REND AND NOT(HDXLINK) THEN
HDXLINK = 1; RXRETRIES = 0
END
END
RXRETRIES = RXRETRIES + 1
IF RXRETRIES > ZRETRIES THEN
TXSTATE = ZTX.DONE; STATUS = XFER.RETRY
GOSUB 1250
GOTO 900
END
IF RXRETRIES = 1 THEN RXSYNCID = RXSYNCID + 1
RXBLKLEN = INT(RXBLKLEN / 2); I = RXBLKLEN
BEGIN CASE
CASE I <= 64; I = 64
CASE I <= 128; I = 128
CASE I <= 256; I = 256
CASE 1; I = 512
END CASE
POS = RXPOS; GOSUB 3000; ZTXBUF = HEXPOS
POS = I; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
POS = RXSYNCID; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
ZPKT.TYPE = ZPKT.RPOS; ZLEN = 24
GOSUB 1000
RXTIMER = TIME() + TIME.OUT
END
END ELSE
BRAINDEAD = TIME() + ZBRAINDEAD; TEST.BAD = 0
RXPKTLEN = RXPKTLEN - 8
RXBLKLEN = RXPKTLEN
RXBUFFER = RXBUFFER:RXBUF[10, RXPKTLEN]
RXTIMER = 0; RXRETRIES = 0; RXLASTSYNC = RXPOS
IF HEX.OUTPUT THEN RXPKTLEN = INT(RXPKTLEN / 2)
RXPOS = RXPOS + RXPKTLEN
IF NOT(BINARY) THEN
AMS = COUNT(RXBUF, AM)
RXPOS = RXPOS + AMS
TOT.AM.COUNT = TOT.AM.COUNT + AMS
END
IF RXWINDOW AND PKT.TYPE # ZPKT.LASTDATA THEN
RXLASTACK = RXPOS
GOSUB 1230
CACHE.PTR = CACHE.PTR + 1
CACHE(CACHE.PTR) = RXBUFFER; RXBUFFER = ""
IF CACHE.PTR > 29 THEN
FOR I = 1 TO 30
RXBUFFER = RXBUFFER:CACHE(I); CACHE(I) = ''
IF SPLIT.SIZE THEN
IF LEN(RXBUFFER) > SPLIT.SIZE THEN
SPLIT.CNT = SPLIT.CNT + 1
CACHE.ID = RXITEM:DOT:SPLIT.CNT
WRITE RXBUFFER ON F.RXFILE, CACHE.ID
RXBUFFER = ''
STATUS = FTE.USING.CACHE
RTN.STR<1,-1> = CACHE.ID
END
END
NEXT I
CACHE.PTR = 1
CACHE(CACHE.PTR) = RXBUFFER; RXBUFFER = ""
END
END
IF NOT(RXSTART) THEN RXSTART = TIME()
IF PKT.TYPE = ZPKT.LASTDATA THEN
ZPKT.TYPE = ZPKT.EOF; ZLEN = 8; TXPOS = RXPOS
POS = TXPOS; IF HEX.OUTPUT THEN HEX.OUTPUT = 0
GOSUB 3000; ZTXBUF = HEXPOS
GOSUB 1000
TXTIMER = TIME() + ZSTART; TXSTATE = ZTX.EOFACK
END
END
END
CASE PKT.TYPE = ZPKT.DATAACK
IF TXSTATE = ZTX.XDATA OR TXSTATE = ZTX.DATAACK OR TXSTATE = ZTX.XWAIT OR TXSTATE = ZTX.EOF OR TXSTATE = ZTX.EOFACK THEN
HEXPOS = RXBUF[2, 8]; GOSUB 3100
IF TXWINDOW AND POS > TXLASTACK THEN
TXLASTACK = POS
IF TXSTATE = ZTX.DATAACK AND TXPOS < (TXLASTACK + TXWINDOW) THEN
TXSTATE = ZTX.XDATA; TXRETRIES = 0; TXTIMER = 0
END
END
END
CASE PKT.TYPE = ZPKT.RPOS
IF TXSTATE = ZTX.XDATA OR TXSTATE = ZTX.DATAACK OR TXSTATE = ZTX.XWAIT OR TXSTATE = ZTX.EOF OR TXSTATE = ZTX.EOFACK THEN
HEXPOS = RXBUF[2, 8]; GOSUB 3100; REQPOS = POS
RTXPOS = REQPOS; IF HEX.OUTPUT THEN RTXPOS = RTXPOS * 2
HEXPOS = RXBUF[18, 8]; GOSUB 3100; SYNCID = POS
IF SYNCID # TXSYNCID AND TXPOS # RTXPOS THEN
IF SYNCID # TXSYNCID THEN
TXSYNCID = SYNCID; TXRETRIES = 1
END ELSE TXRETRIES = TXRETRIES + 1
TXTIMER = 0
IF TXPOS < 0 THEN
TXSTATE = ZTX.EOF; TXPOS = -2
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' TXPOS=':TXPOS:' REQPOS=':REQPOS
TRACE = TRACE:' TXSYNCID=':TXSYNCID:' SYNCID=':SYNCID
GOSUB 6000
END
END ELSE
HEXPOS = RXBUF[10, 8]; GOSUB 3100; BLKLEN = POS
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' TXPOS=':TXPOS:' REQPOS=':REQPOS
TRACE = TRACE:' TXSYNCID=':TXSYNCID:' SYNCID=':SYNCID
TRACE = TRACE:' TXBLKLEN=':TXBLKLEN:' BLKLEN=':BLKLEN
GOSUB 6000
END
IF TXBLKLEN > BLKLEN THEN
TXBLKLEN = BLKLEN
END ELSE
TXBLKLEN = INT(TXBLKLEN / 2)
END
BEGIN CASE
CASE TXBLKLEN <= 32; TXBLKLEN = 64
IF NOT(TX.HIGHBIT) THEN TX.HIGHBIT = 1
CASE TXBLKLEN <= 64; TXBLKLEN = 64
CASE TXBLKLEN <= 128; TXBLKLEN = 128
CASE TXBLKLEN <= 256; TXBLKLEN = 256
CASE 1; TXBLKLEN = 512
END CASE
TXGOODBYTES = 0
TXGOODNEEDED = TXGOODNEEDED + 512
IF TXGOODNEEDED > 8192 THEN TXGOODNEEDED = 8192
IF TXSTATE # ZTX.XWAIT THEN TXSTATE = ZTX.XDATA
TXPOS = RTXPOS
END
END ELSE
IF SYNCID # TXSYNCID THEN
TXRETRIES = 1
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' TXPOS=':TXPOS:' SYNCID=':SYNCID
TRACE = TRACE:' TXSYNCID=':TXSYNCID:' TXRETRIES=':TXRETRIES
TRACE = TRACE:' SYNC=':SYNCID:' RPOS=':REQPOS
HEXPOS = RXBUF[10, 8]; GOSUB 3100
TRACE = TRACE:' BLKL=':POS; GOSUB 6000
END
END ELSE
TXPOS = RTXPOS; TXRETRIES = TXRETRIES + 1
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' TXPOS=':TXPOS:' SYNCID=':SYNCID
TRACE = TRACE:' TXSYNCID=':TXSYNCID:' TXRETRIES=':TXRETRIES
TRACE = TRACE:' SYNC=':SYNCID:' RPOS=':REQPOS
HEXPOS = RXBUF[10, 8]; GOSUB 3100
TRACE = TRACE:' BLKL=':POS; GOSUB 6000
END
END
END
IF TXRETRIES > ZRETRIES THEN
TXSTATE = ZTX.DONE; STATE = XFER.ABORT
GOSUB 1250
END
END
CASE PKT.TYPE = ZPKT.EOF
IF RXSTATE = ZRX.DATA THEN
HEXPOS = RXBUF[2, 8]; GOSUB 3100
IF POS < 0 THEN
RXSTATE = ZRX.INIT; BRAINDEAD = TIME() + ZBRAINDEAD
END ELSE
IF POS < RXPOS THEN
IF POS + TOT.AM.COUNT = RXPOS THEN POS = RXPOS
END
IF POS # RXPOS THEN
IF POS <= RXLASTSYNC THEN
RXRETRIES = 0; RXTIMER = 0
END
RXLASTSYNC = RXPOS
IF NOT(RXTIMER) OR TIME() > RXTIMER THEN
RXRETRIES = RXRETRIES + 1
IF RXRETRIES > ZRETRIES THEN
TXSTATE = ZTX.DONE; STATUS = XFER.ABORT
GOSUB 1250
END ELSE
IF RXRETRIES = 1 THEN RXSYNCID = RXSYNCID + 1
RXBLKLEN = INT(RXBLKLEN / 2); I = RXBLKLEN
BEGIN CASE
CASE I <= 64; I = 64
CASE I <= 128; I = 128
CASE I <= 256; I = 256
CASE 1; I = 512
END CASE
POS = RXPOS; GOSUB 3000; ZTXBUF = HEXPOS
POS = I; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
POS = RXSYNCID; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
ZPKT.TYPE = ZPKT.RPOS; ZLEN = 24
GOSUB 1000
RXTIMER = TIME() + TIME.OUT
END
END
END ELSE
RXSTATE = ZRX.INIT; BRAINDEAD = TIME() + ZBRAINDEAD
END
END
END
IF RXSTATE = ZRX.INIT THEN
IF TXSTATE = ZTX.SWAIT THEN TXSTATE = ZTX.REND
ZPKT.TYPE = ZPKT.EOFACK; ZLEN = 0; ZTXBUF = ""
GOSUB 1000
IF TXFD # 1 THEN
GOSUB 5000
TXSTATE = ZTX.DONE; STATUS = XFER.OK
END
END
CASE PKT.TYPE = ZPKT.EOFACK
IF TXSTATE = ZTX.EOF OR TXSTATE = ZTX.EOFACK THEN
IF TXFD # 1 THEN GOSUB 5000
BRAINDEAD = TIME() + ZBRAINDEAD
TXSTATE = ZTX.DONE
END
CASE PKT.TYPE = ZPKT.EOFTP
FTP.ERR = RXBUF[2,1]
IF SPLIT.SIZE THEN NULL ELSE
IF TXFD # 1 THEN
IF RXBUF[2, 1] = '0' THEN GOSUB 5000
END
IF RUNNING.NT THEN
EXECUTE "!DEL ":PFNAME CAPTURING CAPT; !*UDT*!
!@!EXECUTE OS.EXEC:' ':RM.CMD:' ':PFNAME CAPTURING CAPT ; !*UV,UP*!
END ELSE
EXECUTE '!rm ':PFNAME CAPTURING CAPT ;!*UDT*!
!@!EXECUTE "sh -c 'rm ":PFNAME:"'" CAPTURING CAPT ; !*UV,UP*!
END
!@!%UNLINK(PFNAME); !*AP*!
IF TU.TRACE THEN TRACE = "Removing ":PFNAME; GOSUB 6000
END
BRAINDEAD = TIME() + ZBRAINDEAD; TXSTATE = ZTX.DONE
BEGIN CASE
CASE FTP.ERR = 0 AND SPLIT.SIZE
STATUS = FTE.USING.FTP
RTN.STR = PFNAME
CASE FTP.ERR = 0
STATUS = XFER.OK
CASE FTP.ERR = 1
STATUS = FTE.FTP.LOADWINSOCK
CASE FTP.ERR = 2
STATUS = FTE.FTP.LOGINFAILED
CASE FTP.ERR = 3
STATUS = FTE.FTP.CONNECTFAILED
CASE FTP.ERR = 4
STATUS = FTE.FTP.OPFAILED
CASE FTP.ERR = 5
STATUS = FTE.FTP.ABORT
CASE FTP.ERR = 6
STATUS = FTE.FTP.WINSOCK
CASE FTP.ERR = 7
STATUS = FTE.FTP.FILEACCESS
CASE 1
STATUS = FTE.UNKNOWN.ERROR
END CASE
CASE PKT.TYPE = ZPKT.IDLE
IF TXSTATE = ZTX.XWAIT THEN
HDXLINK = 0; TXTIMER = 0
TXRETRIES = 0; TXSTATE = ZTX.XDATA
END ELSE
IF TXSTATE > ZTX.INITACK AND TXSTATE < ZTX.REND THEN
BRAINDEAD = TIME() + ZBRAINDEAD
END
END
CASE PKT.TYPE = ZPKT.END
IF TXSTATE = ZTX.END OR TXSTATE = ZTX.ENDACK THEN
ZPKT.TYPE = ZPKT.END; ZLEN = 0; ZTXBUF = ""
GOSUB 1000
END
IF TXFD # 1 THEN GOSUB 5000
TXSTATE = ZTX.DONE; STATUS = XFER.OK
END CASE
BEGIN CASE
CASE TXSTATE = ZTX.START OR TXSTATE = ZTX.SWAIT
IF RXSTATE = ZRX.WAIT THEN TXTIMER = 0; TXSTATE = ZTX.INIT
CASE TXSTATE = ZTX.XDATA
IF RXSTATE AND HDXLINK THEN
TXTIMER = TIME() + ZIDLE; TXSTATE = ZTX.XWAIT
END
CASE TXSTATE = ZTX.XWAIT
IF NOT(RXSTATE) THEN
TXTIMER = 0; TXRETRIES = 0; TXSTATE = ZTX.XDATA
END
CASE TXSTATE = ZTX.REND
IF NOT(RXSTATE) THEN
TXTIMER = 0; TXRETRIES = 0; TXSTATE = ZTX.END
END
END CASE
IF RX.STREAM OR TX.STREAM THEN PKT.TYPE = ZNOPKT
END
WHILE TXSTATE AND PKT.TYPE # ZNOPKT DO
REPEAT
WHILE TXSTATE DO
REPEAT
900 * ABORT or normal END
IF SPOOLER.OUTPUT THEN PRINTER CLOSE
 INCLUDE TU2428BP ECHO.ON.H
!@!IF PTERM THEN EXECUTE "PTERM CASE INVERT" CAPTURING RUBBISH ; !*UV,UP*!
!@!IF TXFD = -1 THEN F.RXFILE = OLD.F.RXFILE ; !*UV,UP*!
RETURN
 INCLUDE TU2428BP TU.SBZ.INC
9900 * Initialisation
PROMPT ''
 INCLUDE TU2428BP CASE.INVERT.OFF.H
!@!EXECUTE "XCS-ON" CAPTURING CAPT; !*PICK,AP*!
FF.ALLOW = 0; FTP.MODE = 0
FF.ALLOW = 1 ;!*UV,UVP,UP,UDT*!
FTPDIR = '/tmp/'; RUNNING.NT = 0
RUNNING.NT = OCONV(SYSTEM(33), 'MCU') ; !*UDT*!
!@!RUNNING.NT = SYSTEM(91) ; !*UV,UP*!
IF INDEX(RUNNING.NT, "NT", 1) THEN RUNNING.NT = 1 ELSE RUNNING.NT = 0; !*UDT*!
IF RUNNING.NT THEN
FTPDIR = GETENV("TEMP") ; !*UDT*!
IF FTPDIR = '' THEN FTPDIR = GETENV("TMP") ; !*UDT*!
!@!CALL UV.GETENV("TEMP", FTPDIR) ; !*UV,UP*!
!@!IF FTPDIR = '' THEN CALL UV.GETENV("TMP", FTPDIR) ; !*UV,UP*!
IF FTPDIR[LEN(FTPDIR), 1] # "\" THEN FTPDIR = FTPDIR:"\"
END
MX.CONV = 'MCDX'
CH = OCONV(127, MX.CONV); CH = OCONV(CH, 'MCU')
IF CH # '7F' THEN MX.CONV = 'MX'
BYTE255 = "\F":"f"
SPLIT.SIZE = 0; SPLIT.CNT = 0
IF MAX.ITEM.SIZE > '0' THEN SPLIT.SIZE = MAX.ITEM.SIZE
TX.XONXOFF = 1
TX.CTLCHRS = 1
TX.HIGHCTL = 0
TX.HIGHBIT = 0
TX.CANASC = 0
TX.CANRLE = 1
TX.CANKER = 0
TX.STREAM = 0
RX.XONXOFF = 1
RX.CTLCHRS = 1
RX.HIGHCTL = 0
RX.HIGHBIT = 1
RX.CANASC = 0
RX.CANRLE = 1
RX.CANKER = 1
RX.STREAM = 0
STATUS = 0 ; BLK.SIZE = 2048
NON.RESILIENT = 1
HEX.OUTPUT = INDEX(OPTIONS,'X',1)
IF INDEX(OPTIONS, 'C', 1) THEN TX.CANRLE = 0; RX.CANRLE = 0
LOCAL.CONNECT = INDEX(OPTIONS,'L',1)
!! IF LOCAL.CONNECT THEN NON.RESILIENT = 0
NON.RESILIENT.FLAG = INDEX(OPTIONS,'R',1)
IF NON.RESILIENT.FLAG OR TXDATA = "" THEN
NON.RESILIENT = 2; TX.STREAM = 1; RX.STREAM = 1
END
IF TXFD = 1 AND INDEX(RTN.STR, "TUXFER.DATA", 1) THEN
OPEN '',RTN.STR TO F.SOURCE ELSE
STATUS = FTE.HOSTFILE.OPEN.ERROR
RETURN
END
READ HEADER FROM F.SOURCE,'XFER.HEADER' ELSE
STATUS = FTE.READ.ERROR
RETURN
END
NO.BLK.DOWN = HEADER<14>
TXDATA.LEN = HEADER<16>
BLK.CNT = 0; BLK.POS = 0; OLD.POS = 0
IF TXDATA # "MIKE IS SILLY" THEN
TXHEADER = TXDATA
TXDATA = ""
END ELSE TXHEADER = "" ; TXDATA = ""
END ELSE
NO.BLK.DOWN = 0
TXDATA.LEN = LEN(TXDATA)
END
RTN.STR = ""
BINARY = INDEX(OPTIONS,'B',1) + HEX.OUTPUT
HOST.INITIATED = INDEX(OPTIONS,'H',1)
MINIMAL.STATUS = INDEX(OPTIONS,'M',1)
APPEND.FLAG = INDEX(OPTIONS,'A',1)
NO.STATUS.WINDOW = INDEX(OPTIONS,'Z',1)
SPOOLER.OUTPUT = INDEX(OPTIONS,'S',1) + INDEX(OPTIONS,'P',1)
TX.HIGHBIT = INDEX(OPTIONS,'7',1)
IF TX.HIGHBIT THEN RX.HIGHBIT = 1
TU.TRACE = INDEX(OPTIONS,'D',1)
IF INDEX(OPTIONS,'V',1) THEN SVM.TOKN = SPCE; VM.TOKN = SPCE
IF APPEND.FLAG THEN APPEND.MODE = 1 ELSE APPEND.MODE = 0
!@!TU.WHO = OCONV(0,'U50BB'); !*PICK,AP,ADDS,ULT,GA,ALTOS,MRX*!
!@!TU.WHO = OCONV("",'U50BB'); !*SEQ*!
!@!PORTNO = FIELD(TU.WHO,' ',1); !*PICK,AP,ADDS,ULT,GA,ALTOS,MRX*!
!@!PORTNO = @USERNO ; !*PI/O,PR1ME,UV,UP*!
PORTNO = @UDTNO ; !*UDT,UDTVMS*!
IF TU.TRACE THEN
MD.FILE = 'VOC'; !*PI/O,PR1ME,UDT,UDTVMS,UP,UV*!
!@!MD.FILE = 'MD'; !*ADDS,ALTOS,AP,GA,MRX,PICK,SEQ,ULT*!
TU.TRACE = 1
OPEN '', MD.FILE TO F.MD ELSE
MD.FILE = 'MD'
OPEN '',MD.FILE TO F.MD ELSE TU.TRACE = 0
END
OPEN '','TUSTATE' TO TUSTATE ELSE TU.TRACE = 0
IF TU.TRACE THEN
IF TXDATA > "" THEN OUTP = 'DOWNLOAD' ELSE OUTP = 'UPLOAD'
OUTP = OUTP:VM:DOS.FILE.NAME:VM:OPTIONS:VM:DESCRIPTION
WRITE OUTP ON TUSTATE,'SBZ.':PORTNO:'.0'
END
END
IF TXFD = -1 THEN
!@!STATUS FILEINFO FROM F.RXFILE ELSE FILEINFO = "" ; !*UP,UV*!
!@!OLD.F.RXFILE = F.RXFILE ; !*UV,UP*!
!@!BEGIN CASE ; !*UV,UP*!
!@!CASE FILEINFO<21> = "" ; !*UV,UP*!
!@!OS.FILE = 1 ; !*UV,UP*!
!@!CASE (FILEINFO<21> = 1 OR FILEINFO<21> = 19) AND RXITEM # "" AND BINARY; !*UV,UP*!
!@!OS.FILE = 1 ; RXITEM.ID = RXITEM; !*UV,UP*!
!@!IF FILEINFO<21> = 1 THEN ; !*UV,UP*!
!@!LEN.RXITEM = LEN(RXITEM); !*UV,UP*!
!@!X = ABS(LEN.RXITEM/14) ; TRUNCATE = 0; !*UV,UP*!
!@!BPOS = 1 ; TMP.ITEM = ""; POS = 14; !*UV,UP*!
!@!FOR I = 1 TO X UNTIL TRUNCATE; !*UV,UP*!
!@!IF TMP.ITEM # "" THEN; !*UV,UP*!
!@!IF I > 2 THEN POS = 13 ; TRUNCATE = 1; !*UV,UP*!
!@!TMP.ITEM = TMP.ITEM:"/":RXITEM[BPOS, POS]; !*UV,UP*!
!@!END ELSE; !*UV,UP*!
!@!TMP.ITEM = RXITEM[BPOS, POS]; !*UV,UP*!
!@!END; !*UV,UP*!
!@!BPOS = BPOS + POS; !*UV,UP*!
!@!NEXT I; !*UV,UP*!
!@!IF NOT(TRUNCATE) THEN; !*UV,UP*!
!@!TMP.ITEM = TRIM(TMP.ITEM:"/":RXITEM[BPOS, LEN.RXITEM]); !*UV,UP*!
!@!END; !*UV,UP*!
!@!IF TMP.ITEM[LEN(TMP.ITEM), 1] = "/" THEN TMP.ITEM = TMP.ITEM:"?"; !*UV,UP*!
!@!RXITEM.ID = TMP.ITEM; !*UV,UP*!
!@!END ELSE RXITEM.ID = "/":RXITEM.ID; !*UV,UP*!
!@!OS.FILE.PATH = FILEINFO<20>:RXITEM.ID ; !*UV,UP*!
!@!WRITE "" ON F.RXFILE, RXITEM ; !*UV,UP*!
!@!EXECUTE 'sh -c "rm ':OS.FILE.PATH:'"' CAPTURING RUBBISH ; !*UV,UP*!
!@!EXECUTE 'sh -c "touch ':OS.FILE.PATH:'"' CAPTURING RUBBISH ; !*UV,UP*!
!@!OPENSEQ OS.FILE.PATH TO F.RXFILE ELSE STATUS = FTE.HOSTFILE.OPEN.ERROR ; !*UV,UP*!
!@!CASE 1 ; !*UV,UP*!
!@!OS.FILE = 0 ; !*UV,UP*!
!@!END CASE ; !*UV,UP*1
FILE.TYPE = FILEINFO(F.RXFILE, 3) ;!*UDT,UDTVMS*!
OS.FILE.PATH = FILEINFO(F.RXFILE, 2) ;!*UDT,UDTVMS*!
BEGIN CASE ;!*UDT,UDTVMS*!
CASE FILE.TYPE = 8 OR FILE.TYPE = 5 ;!*UDT,UDTVMS*!
OS.FILE = 1 ;!*UDT,UDTVMS*!
CASE FILE.TYPE = 4 AND RXITEM # "" AND BINARY;!*UDT,UDTVMS*!
OS.FILE = 1 ;!*UDT,UDTVMS*!
OS.FILE.PATH = OS.FILE.PATH:"/":RXITEM ;!*UDT,UDTVMS*!
OSDELETE OS.FILE.PATH ON ERROR NULL ;!*UDT,UDTVMS*!
OSWRITE "" ON OS.FILE.PATH ON ERROR NULL ;!*UDT,UDTVMS*!
OSOPEN OS.FILE.PATH TO F.RXFILE ELSE STATUS = FTE.HOSTFILE.OPEN.ERROR; RETURN; !*UDT,UDTVMS*!
CASE 1 ; !*UDT,UDTVMS*1
OS.FILE = 0 ;!*UDT,UDTVMS*!
END CASE ;!*UDT,UDTVMS*!
!@!OS.FILE = 0 ; !*-UDT,-UDTVMS,-UP,-UV*!
END ELSE OS.FILE = 0
IF BINARY THEN ASCII.MODE = 0 ELSE ASCII.MODE = 2
IF TX.HIGHBIT THEN ASCII.MODE = ASCII.MODE + 1
SUPPRESS.STATUS = 0
IF HOST.INITIATED THEN SUPPRESS.STATUS = 1
IF NO.STATUS.WINDOW THEN SUPPRESS.STATUS = 2
IF MINIMAL.STATUS THEN SUPPRESS.STATUS = 3
XFEROPTS = TX.XONXOFF:TX.CTLCHRS:TX.HIGHCTL:TX.HIGHBIT
XFEROPTS = XFEROPTS:TX.CANASC:TX.CANRLE:TX.CANKER:TX.STREAM
XFEROPTS = XFEROPTS:RX.XONXOFF:RX.CTLCHRS:RX.HIGHCTL:RX.HIGHBIT
XFEROPTS = XFEROPTS:RX.CANASC:RX.CANRLE:RX.CANKER:RX.STREAM
KS(1,1) = 0; KS(1,2) = 32; KS(1,3) = KS(1,2) + 89
KS(2,1) = -32; KS(2,2) = KS(1,2) + KS(2,1); KS(2,3) = KS(1,3) + KS(2,1)
KS(3,1) = 44; KS(3,2) = KS(1,2) + KS(3,1); KS(3,3) = KS(1,3) + KS(3,1)
KS(4,1) = 255 - KS(1,3); KS(4,2) = KS(1,2) + KS(4,1); KS(4,3) = KS(1,3) + KS(4,1)
TXMAXBLKLEN = ZMAXBLKLEN; RXMAXBLKLEN = 64; CACHE.PTR = 0
TXGOODBYTES = 0; TXGOODNEEDED = 512; RXLASTACK = 1
TXWINDOW = 0; RXWINDOW = 1; TIME.OUT = ZTIME.OUT
TXSTATE = ZTX.START; RXSTATE = ZRX.INIT; RXBUFFER = ""
RXPOS = 0; TXPOS = 0; TXBLKLEN = 2048; RXBLKLEN = 2048
RXTIMER = 0; BRAINDEAD = TIME() + ZBRAINDEAD
TXTIMER = 0; TXRETRIES = 0; TXSTART = 0; RXSTART = 0
TXSYNCID = 0; RXSYNCID = 0; TEST.BAD = 0; HDXLINK = 0
ZPKT.TYPE = ZPKT.START; ZLEN = 0; RXLASTSYNC = 0
TOT.AM.COUNT = 0
ACKAFTER = 511; IF BINARY THEN ACKAFTER = 511
RETURN
END
