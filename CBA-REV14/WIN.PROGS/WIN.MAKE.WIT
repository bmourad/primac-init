* WIN.MAKE.WIT
* wIntegrate V2.0 Terminal Generation Program
* Compile for: GENERIC AP MD ME PI PR SQ UD UL UP UV UC IN GA
* (C) Copyright IBM Corporation 2003. All rights reserved
* Copyright (c) 1991-93. Impact Business Systems
*
* This version written under R83 pick
* Version 2.0 15/07/93
*
* Constants
      EQUATE TRUE TO 1, FALSE TO 0
      AM = CHAR(254)
      VM = CHAR(253)
      CR = CHAR(13)
      LF = CHAR(10)
      FF = CHAR(12)
      ESC = CHAR(27)
      ARG = CHAR(0)
*
      PRINT
      PRINT
      PRINT "This program will create a wIntegrate Terminal file based on the @(-n)"
      PRINT "codes used by your host computer."
      PRINT "Due to the limited information available from this source the Terminal"
      PRINT "generated will require further editing to define Edit/Function keys and"
      PRINT "any additional control sequences used by your system."
      PRINT
      PRINT
*
      GOSUB 100; * Initialise
      GOSUB 200; * Enter data
      IF WORKING THEN
         GOSUB 400; * Header
         GOSUB 500; * Calculate Cursor Code and Move Instructions
         GOSUB 800; * Add ordinary control sequences
         GOSUB 900; * Add attribute changing codes
         GOSUB 1000; * Output Definition
         GOSUB 1100; * Turn off record
      END
*
      STOP
*
*-------------------- Internal Function --------------------------
*
* Initialise Variables
100   WORKING = TRUE
      R.TERM = ''
      MOVECODES = ''
      FIXEDCODES = ''
      VALS = ""
      USED.CODES = ''
      ATTRCODES =''
      SICODES = ''
      ATTRVALS = ''
      MOVECODES<-1> = "CursorCode"
      MOVECODES<-1> = "MoveX"
      MOVECODES<-1> = "MoveXY"
      FIXEDCODES<-1> = "CR";           VALS<-1> = "13"
      FIXEDCODES<-1> = "LF";           VALS<-1> = "10"
      FIXEDCODES<-1> = "FF";           VALS<-1> = "-1"
      FIXEDCODES<-1> = "BS";           VALS<-1> = "8"
      FIXEDCODES<-1> = "Bell";         VALS<-1> = "7"
      FIXEDCODES<-1> = "CursorHome";   VALS<-1> = "-2"
      FIXEDCODES<-1> = "ClearEOL";     VALS<-1> = "-4"
      FIXEDCODES<-1> = "ClearEOP";     VALS<-1> = "-3"
      FIXEDCODES<-1> = "CursorLeft";   VALS<-1> = "-9"
      FIXEDCODES<-1> = "CursorUp";     VALS<-1> = "-10"
      FIXEDCODES<-1> = "CursorRight";  VALS<-1> = "-19"
      FIXEDCODES<-1> = "CursorDown";   VALS<-1> = "-20"
      FIXEDCODES<-1> = "EnableProtect";  VALS<-1> = "-11"
      FIXEDCODES<-1> = "DisableProtect"; VALS<-1> = "-12"
      FIXEDCODES<-1> = "ProtectOn";      VALS<-1> = "-7"
      FIXEDCODES<-1> = "ProtectOff";     VALS<-1> = "-8"
*
      ATTRCODES<-1> = "Effect Dim";        ATTRVALS<-1> = "-100"
      ATTRCODES<-1> = "Effect Normal";     ATTRVALS<-1> = "-101"
      ATTRCODES<-1> = "Effect Flash";      ATTRVALS<-1> = "-5"
      ATTRCODES<-1> = "Effect Normal";     ATTRVALS<-1> = "-6"
      ATTRCODES<-1> = "Effect Reverse";    ATTRVALS<-1> = "-13"
      ATTRCODES<-1> = "Effect Normal";     ATTRVALS<-1> = "-14"
      ATTRCODES<-1> = "Effect Underline";  ATTRVALS<-1> = "-15"
      ATTRCODES<-1> = "Effect Normal";     ATTRVALS<-1> = "-16"
*
      SICODES<-1> = "AttributeOn"
      SICODES<-1> = "AttributeOff"
      SICODES<-1> = "AttributeEffect Dim"
      SICODES<-1> = "AttributeEffect Flash"
      SICODES<-1> = "AttributeEffect Reverse"
      SICODES<-1> = "AttributeEffect Underline"
*
      RETURN
*
* User Input required
200   GOSUB 210; * Terminal Type
      IF WORKING THEN GOSUB 220; * Attribute type
*
      IF WORKING THEN
         IF TYPE # "" THEN EXECUTE "TERM ":TYPE
*
         PRINT
         PRINT
         PRINT "A skeleton WIT file Terminal definition will now be created and displayed"
         PRINT "on the screen. You should turn on Edit Record (Raw Data) to save output to a"
         PRINT "file in the WIT directory with an extension of WIT. Then press <CR>."
         PRINT
         PRINT "Press <CR> to continue or '*' to Exit ":
         INPUT DUM:
         IF DUM = '*' THEN WORKING = FALSE
      END
      RETURN
*
210   PRINT "Enter Terminal Type (or <CR> current, * Exit) ":
      INPUT TYPE
      IF TYPE = '*' THEN WORKING = FALSE
      RETURN
*
* Enter Attributes type
220   PRINT
      PRINT
      PRINT "The Terminal attributes are generated for a terminal in one of the three"
      PRINT "following ways. See wIntegrate Help Emulation for background information."
      PRINT
      PRINT "1. Only one attribute is allowed on the screen at a time"
      PRINT "2. A code is embedded into the screen for each type of attribute. This takes"
      PRINT "   up one character cell, and affects all characters up to the next attribute."
      PRINT "3. Every character can have a different attribute"
      PRINT
      MYGUESS = 1 + (@(-99) # "")
      LOOP
         PRINT "Enter Attribute type, <CR> for ":MYGUESS:" or * to exit ":
         INPUT ATTR
         IF ATTR = '' THEN ATTR = MYGUESS
         IF ATTR = '*' THEN WORKING = FALSE
      UNTIL ATTR = '*' OR ATTR = '1' OR ATTR = '2' OR ATTR = '3' DO
      REPEAT
      RETURN
*
* Create Header
400   R.TERM = ''
      R.TERM = '[wIntegrateTerminal]'
      R.TERM<-1> = '* Terminal generated by WIN.MAKE.WIT'
      R.TERM<-1> = '* ':TIMEDATE()
      RETURN
*
* Calculate cursor control code and Move XY and MoveX if possible
* Note Calculate by elimination so it will give an incorrect type and
* Move sequence if it can't figure it out.
*
500   CURSORCODE = ''
      LINEXY = ''
      LINEX = ''
      TEST1 = @(1,3)
      TEST2 = @(38,12)
      GOSUB 520; * Check diffences
      TYPE = 1
*
      BEGIN CASE
         CASE DIFF[2,1] = 'X'; CURSORCODE = 'A'
         CASE DIFF MATCH "'00XX'0N" OR DIFF = "00XX"
            IF TEST1[3,1] = CHAR(1) THEN CURSORCODE = 'H' ELSE CURSORCODE = 'L'
         CASE 1
            CURSORCODE = 'V'
            TYPE = 2
      END CASE
*
      R.TERM<-1> = MOVECODES<1>:" = '":CURSORCODE:"'"
      IF CURSORCODE = 'V' THEN
         GOSUB 530; * Create Variable length move definition
         LINEXY = LINE
         TEST1 = @(60)
         L1 = LEN(TEST1)
         IF L1 < 20 THEN
            TEST2 = @(3)
            L2 = LEN(TEST2)
            GOSUB 530; * Create Variable length move definition
            LINEX = LINE
         END
      END ELSE
         LINEXY = ''
         FOR J = 1 TO L
            IF DIFF[J,1] = 'X' THEN VAL = ARG ELSE VAL = TEST1[J,1]
            LINEXY = LINEXY : VAL
         NEXT J
         TEST1 = @(40)
         TEST2 = @(3)
         GOSUB 520; * Compare diffences
         IF L1 < 20 THEN
            LINEX = ''
            FOR J = 1 TO L
               IF DIFF[J,1] = 'X' THEN VAL = ARG ELSE VAL = TEST1[J,1]
               LINEX = LINEX :VAL
            NEXT J
         END
      END
*
      IF LINEX[1,1] = CHAR(13) THEN LINEX = LINEX[2,999]
      IF LINEX # "" THEN CODE = MOVECODES<2>; VAL = LINEX; GOSUB 5000
      IF LINEXY # '' THEN CODE = MOVECODES<3>; VAL = LINEXY; GOSUB 5000
      RETURN
*
* Compare TEST1 with TEST2 and create DIFF which has an X for characters
* different and 0 for characters the same
520   DIFF = ''
      L1 = LEN(TEST1)
      L2 = LEN(TEST2)
      IF L1 > L2 THEN L = L1 ELSE L = L2
      FOR J = 1 TO L
         IF TEST1[J,1] # TEST2[J,1] THEN D = 'X' ELSE D = '0'
         DIFF = DIFF : D
      NEXT J
*
      RETURN
*
* Compare TEST1 & TEST2 and give a control string
530   LINE = ''
      LL = 0
      K = 1
      J = 1
      LOOP
      WHILE J <= L1 AND K <= L2 DO
         IF TEST1[J,1] = TEST2[K,1] THEN
            VAL = TEST1[J,1]
            J = J + 1
            K = K + 1
         END ELSE
            VAL = ARG
            LOOP
            WHILE TEST1[J,1] MATCH "1N" DO
               J = J + 1
            REPEAT
            LOOP
            WHILE TEST2[K,1] MATCH "1N" DO
               K = K + 1
            REPEAT
         END
         LINE = LINE : VAL
         LL = LL + 1
      REPEAT
      RETURN
*
* Fixed control code sequences
800   N = DCOUNT(FIXEDCODES, AM)
      TYPE = 0
      FOR J = 1 TO N
         DUM = VALS<J>
         IF DUM # " " THEN
            IF DUM[1,1] = '-' THEN DUM = @(DUM) ELSE DUM = CHAR(DUM)
            IF DUM # "" THEN
               CODE = FIXEDCODES<J>
               VAL = DUM
               GOSUB 5000
            END
         END
      NEXT J
      RETURN
*
*  Terminal Attribute changing Codes
900   NOATTRS = DCOUNT(ATTRVALS,AM)
      TYPE = 0
*
      LINE = "EmbeddedAttributes = "
      IF ATTR = 2 THEN LINE = LINE : "Yes" ELSE LINE = LINE : "No"
      R.TERM<-1> = LINE
*
      IF ATTR = 1 THEN
         ATTRON = ''
         ATTROFF = ''
         FOR J = 1 TO NOATTRS STEP 2
            DUM = @(ATTRVALS<J>)
            IF DUM # '' THEN
               IF ATTRON = '' THEN ATTRON = DUM ELSE
                  K = 1
                  LOOP WHILE ATTRON[K,1] = DUM[K,1] DO
                     K = K + 1
                  REPEAT
                  IF ATTRON[K,1] # '' THEN ATTRON = ATTRON[1,K-1]
               END
            END
            IF ATTROFF = '' THEN ATTROFF = @(ATTRVALS<J+1>)
         NEXT J
         LON = LEN(ATTRON)
         IF LON THEN
            IF LON > 1 THEN
               J = 2
               LOOP
               WHILE SEQ(ATTRON[J,1]) >= 32 DO
                  J = J + 1
               REPEAT
               LON = J - 1
               ATTRON = ATTRON[1, LON]
            END
            CODE = SICODES<1>
            VAL = ATTRON
            GOSUB 5000
         END
         L = LEN(ATTROFF)
         IF L THEN
            CODE = SICODES<2>
            VAL = ATTROFF
            GOSUB 5000
         END
         FOR J = 1 TO NOATTRS STEP 2
            DUM = @(ATTRVALS<J>)
            DUM = DUM[LON+1, 999]
            IF DUM # "" THEN
               CODE = SICODES<3 + INT(J/2)>
               VAL = DUM
               GOSUB 5000
            END
         NEXT J
      END ELSE
         FOR J = 1 TO NOATTRS
            DUM = @(ATTRVALS<J>)
            IF DUM # "" THEN
               CODE = ATTRCODES<J>
               VAL = DUM
               GOSUB 5000
            END
         NEXT J
      END
*
      RETURN
*
*
* Print final result
1000  N = DCOUNT(R.TERM, AM)
      FOR J = 1 TO N
         PRINT R.TERM<J>
      NEXT J
*
      RETURN
*
*
* Turn off record
1100  PRINT
      PRINT "* Turn off Record, then hit <CR>. (Delete this line from the recorded file.)":
      INPUT DUM
*
      RETURN
*
*
* Add "control" sequence to definition
* CODE contains sequence name and VAL contains sequence characters
* TYPE 0 - Constant, 1 - fixed length arguments
*      2 - variable length arguments
*
5000  NO.CHARS = LEN(VAL)
*      QT = ''
*      IF INDEX(VAL, " ", 1) OR INDEX(VAL, ",", 1) THEN QT = '"'
      QT = '"'
      LOCATE(VAL,USED.CODES;VR) THEN
         NO.CHARS = 0
      END ELSE USED.CODES<-1> = VAL
*
      LINE = CODE:" = ":QT
      FOR POS = 1 TO NO.CHARS
         C = VAL[POS,1]
         S = SEQ(C)
         BEGIN CASE
            CASE C = ARG
               BEGIN CASE
                  CASE TYPE = 0; C = '\000'
                  CASE TYPE = 1; C = '%f'
                  CASE TYPE = 2; C = '%v'
               END CASE
            CASE C = ESC; C = '\e'
            CASE C = CR; C = '\r'
            CASE C = LF; C = '\n'
            CASE C = FF; C = '\f'
            CASE C = '"'; C = '\"'
            CASE C = "'"; C = "\'"
            CASE S < 32 OR S > 126
               C = '000':S
               C = C[LEN(C)-2,3]
               C = "\":C
         END CASE
*
         LINE = LINE : C
      NEXT POS
      LINE = LINE : QT
      IF NO.CHARS THEN R.TERM<-1> = LINE
      RETURN
*
   END
