SUBROUTINE WIN.TRANHDR(MAT R.HDR, MAT SS.ARGS, HDR.ERR)
* Get header for wIntegrate window Program file tranfer routines.
* Compile for: GENERIC AP MD ME PI.SUB PR.SUB SQ UD UL UP UV UC IN GA
* Copyright (c) 1991-2000 Impact Business Systems
* Copyright (c) 2000 Informix Corporation
*
* Errors (HDR.ERR)
*   1 - Cant open parameter file
*   2 - Header transfer failed 
* 
EQU TRUE TO 1, FALSE TO 0
*
AMVM=1; AMVM<1,2>=2; AMVM<2>=3
AM=AMVM[4,1]
VM=AMVM[2,1]
SELSEP = "/;|"
*
EQU STARTUP TO 0, IMPORT TO 1, EXPORT TO 2
*
HDR.ERR = 0
*
DIM R.HDR(30)
EQU F.BP         TO R.HDR(1)
EQU F.WORK       TO R.HDR(2)
EQU F.DATA       TO R.HDR(3)
EQU F.MD         TO R.HDR(4)
EQU VERSION      TO R.HDR(5)
EQU MACHINE.TYPE TO R.HDR(6)
EQU SERVNAME     TO R.HDR(7)
EQU DEBUG.ON     TO R.HDR(9)
EQU HOOKS        TO R.HDR(10)
EQU BLOCKSIZE    TO R.HDR(11)
EQU OPTIONS      TO R.HDR(12)
EQU FILE.INFO    TO R.HDR(13)
EQU ITEM.INFO    TO R.HDR(14)
EQU ITEM.LIST    TO R.HDR(15)
EQU FIELD.INFO   TO R.HDR(17)
EQU DICT.INFO    TO R.HDR(18)
EQU QFILE.INFO   TO R.HDR(19)
EQU CASE.INFO    TO R.HDR(20)
EQU MODE.INFO    TO R.HDR(21)
EQU SERV.INFO    TO R.HDR(22)
EQU WORK.INFO    TO R.HDR(23)
EQU SUBMODES     TO R.HDR(24)
EQU NSEQ         TO R.HDR(25)
EQU KEYGEN       TO R.HDR(26)
*
EQU HDRPAD TO 10
BLOCKSIZE = 240
* 
* Service sub parameters
DIM SS.ARGS(30)
EQU SS.PROGS  TO SS.ARGS(1)
EQU SS.PARAM  TO SS.ARGS(2)
EQU SS.RESULT TO SS.ARGS(3)
EQU SS.EXTRA1 TO SS.ARGS(4)
EQU SS.EXTRA2 TO SS.ARGS(5)
*
EQU SSA.INIT     TO 1
EQU SSA.FILESEL  TO 2
EQU SSA.FILECHK  TO 3
EQU SSA.FIELDSEL TO 4
EQU SSA.FIELDCHK TO 5
EQU SSA.EXECCHK  TO 6
EQU SSA.TRANCHK  TO 7
EQU SSA.PREFILE  TO 15
EQU SSA.PREITEM  TO 16
EQU SSA.PREFIELD TO 17
*
* Set up machine specific subroutines
WRKFILE = "WIN.PARAMS"
OPEN '','WIN.PARAMS' TO F.BP ELSE
   WRKFILE = "WIN.PROGS"
   OPEN '','WIN.PROGS' TO F.BP ELSE
      HDR.ERR = 1
      RETURN
   END
END
*
READ MACHINE.TYPE FROM F.BP, "MACHINE.TYPE" ELSE MACHINE.TYPE = "GENERIC"
MACHINE.TYPE = MACHINE.TYPE<1>
*
SUB.SUFFIX = ''
IF MACHINE.TYPE # 'GENERIC' THEN SUB.SUFFIX = '.' : MACHINE.TYPE
PARAMSUB = "WIN.PARAM" : SUB.SUFFIX
MAKEQ    = "WIN.MAKEQ" : SUB.SUFFIX
CRDICT   = "WIN.DICT" : SUB.SUFFIX
ITEMSUB  = "WIN.ITEM" : SUB.SUFFIX
EXECSUB  = "WIN.EXEC" : SUB.SUFFIX
TERMWSUB = "WIN.TERMW" : SUB.SUFFIX
REFSUB   = "WIN.RFMT" : SUB.SUFFIX
*
READV SERVNAME FROM F.BP,"SERVICESUB",1 ELSE SERVNAME = ""
SERVSUB = SERVNAME
*
GOSUB 5000; * Initialise
*
MODE = STARTUP
IF PRE.EXEC # "" THEN CALL @EXECSUB(PRE.EXEC,'',0)
* 
CMND = "ConnectOK"
*
LOOP 
 GOSUB 40; * Generate Checksum
 PRINT CHKSUM:CMND:CR:
 INPUT DUM:
*
 LOOP
 WHILE SEQ(DUM[1,1]) < 31 AND DUM[1,1] # "" DO
  DUM = DUM[2,MAXRECLEN]
 REPEAT
*
 CHKERR = TRUE
 IF DUM[1,3] MATCH "3N" THEN GOSUB 50; * check checksum
 IF DEBUG.ON THEN
  NSEQ = NSEQ+1
  IF NSEQ > 99 THEN NSEQ = 1
  WRITE CMND : AM : DUM ON F.WORK, PORTNO * 100 + NSEQ
 END
 REPLY = DUM[1,4]
 VALUE = DUM[5,MAXRECLEN]
* 
 BEGIN CASE
  CASE REPLY = "742v"
   IF NOT(INVERTING.CASE) THEN
    GOSUB 2100                   ;* iNVERT CASE
   END
   GOSUB 2000                      ;* Send Version number
  CASE CHKERR; NULL
  CASE REPLY = "END"; WORKING = FALSE; HDR.ERR = 2
  CASE REPLY = "File"; GOSUB 500     ;* Check and open file
  CASE REPLY = "Item"; GOSUB 600     ;* Item list
  CASE REPLY = "Fiel"; GOSUB 700     ;* Fields list
  CASE REPLY = "FldI"; GOSUB 710     ;* Field Information
  CASE REPLY = "Impo"; GOSUB 800     ;* Import startup
  CASE REPLY = "Expo"; GOSUB 900     ;* Export startup
  CASE REPLY = "Opti"; GOSUB 1000    ;* Set Options
  CASE REPLY = "Spoo"; GOSUB 1400    ;* Spool
  CASE REPLY = "Vers"; GOSUB 2000    ;* Send Version number
  CASE REPLY = "Buff"; GOSUB 2050    ;* Buffers
  CASE REPLY = "Info"; GOSUB 2060    ;* Host info
 END CASE
*
WHILE WORKING DO
*
REPEAT
* 
IF HDR.ERR THEN
   CMND = "BYE" ; * Tell wIntegrate this program has finished
   GOSUB 40; * Generate Checksum
   PRINT CHKSUM:CMND:CR:
   ECHO ON
   IF ACCOUNT # "" THEN
      DELETE F.MD, QFILE.MD
      DELETE F.MD, QFILE.DATA
   END 
   IF CASE.IS.INVERTED THEN
      GOSUB 2100                            ;* Invert case
   END 
END ELSE
   GOSUB 5200;* Set up parameters required by main program
END
*
RETURN
* 
*----------- Internal subroutines -----------------------
* 
* Generate Checksum for CMND
40 L = LEN(CMND)
CHKSUM = 0
FOR J = 1 TO L
 CHKSUM = CHKSUM + SEQ(CMND[J,1])
NEXT J
CHKSUM = '000' : CHKSUM
CHKSUM = CHKSUM[LEN(CHKSUM)-2,3]
RETURN
* 
* Check check sum
50 L = LEN(DUM)
CHK = 0
FOR J = 4 TO L
 CHK = CHK + SEQ(DUM[J,1])
NEXT J
CHK = '000' : CHK
CHK = CHK[LEN(CHK)-2,3]
* 
IF CHK = DUM[1,3] THEN
 CHKERR = FALSE
 DUM = DUM[4,MAXRECLEN]
END 
RETURN
* 
* 
* Filename
500 IF HOOKS<SSA.PREFILE> = "1" THEN
 CALL @SERVSUB(SSA.PREFILE, MAT SS.ARGS, VALUE)
END
IF VALUE[1,1] = '(' THEN
 ACCOUNT = FIELD(VALUE,' ',1)[2,999]
 VALUE = VALUE[COL2()+1,999]
END ELSE
 ACCOUNT = ''
END 
IF VALUE = "{WINT.FILELIST}" THEN
 IF PRIME.FILES THEN VALUE = "VOC" ELSE VALUE = "MD"
END
DD = FIELD(VALUE, " ",1)
FN = FIELD(VALUE, " ",2)
DDD = ""
DFN = ""
IF FN = "USING" THEN
 FN = ""
 DDD = FIELD(VALUE, " ", 3)
 DFN = FIELD(VALUE, " ", 4)
END ELSE
 IF FIELD(VALUE, " ", 3) = "USING" THEN
  DDD = FIELD(VALUE, " ", 4)
  DFN = FIELD(VALUE, " ", 5)
 END
END
IF FN = "" THEN FN = DD; DD = ""
IF DFN = "" THEN DFN = DDD; DDD = ""
* 
IF ACCOUNT = ACCNAME THEN ACCOUNT = ''
IF ACCOUNT = '' THEN
 FILE.TO.OPEN = FN
 F.MD.TRANS = F.MD
END ELSE
 CALL @MAKEQ(F.MD, QFILE.DATA, QFILE.MD, ACCOUNT, FN)
 OPEN '', QFILE.MD TO F.MD.TRANS ELSE NULL
 FILE.TO.OPEN = QFILE.DATA
END 
* 
OPEN DD, FILE.TO.OPEN TO F.DATA THEN
 FILENAME = VALUE
 DICTOPEN = FALSE
 IF DFN # "" THEN
  OPEN DDD, DFN TO F.DICT THEN DICTOPEN = TRUE
 END ELSE
  IF DD # 'DICT' THEN
   OPEN 'DICT', FILE.TO.OPEN TO F.DICT THEN DICTOPEN = TRUE
  END
 END
 GOSUB 550; * Initialise Variables
END ELSE
 CMND = 'FileBad'
END 
RETURN
* 
* Initialise Transfer Variables
550 CMND = 'FileOK'
ITEMS = ''
FIELDS = ''
OPTIONS = ''
NOFIELDS = 0
ITEMLIST = 0
OVERWRITE = FALSE
APPND = FALSE
CAPTURE = FALSE
SPOOL = FALSE
IDSUPP = FALSE
DICTLIST = FALSE
EIGHTBITS = TRUE
FIELDDESCS = FALSE
FIELDS.LEN = 0
DICTITEMS = ""
USER.LIST = ''
RFMT=0
CHECKKEY = 0
RETURN
* 
* Items
600 ITEMDATA = DUM[7,MAXRECLEN]
WORD = FIELD(ITEMS<1>, " ", 1)
IF WORD = "" THEN WORD = FIELD(ITEMDATA, ' ',1)
CMND = "ItemsOK"
ITEMLIST = FALSE
BEGIN CASE
 CASE WORD = "*"; ITEMS = "*"
 CASE WORD = "#"; ITEMS = "#"
 CASE WORD[1,2] = "#("; GOSUB 605; * Generated key info
 CASE WORD = ""; ITEMS = "*"
 CASE WORD = "{WINT.DICTLIST}"; GOSUB 610; * List to fields
 CASE WORD = "{WINT.ITEMLIST}"; GOSUB 620; * Items list
 CASE WORD = "{WINT.FILELIST}"; GOSUB 630; * Files list
 CASE WORD = "XEQ"; ITEMS = ITEMS : ITEMDATA
 CASE WORD = "REPORT"
  IF ITEMS # "" THEN ITEMS = ITEMS : " "
  ITEMS = ITEMS : ITEMDATA
 CASE WORD = 'GET-LIST'; ITEMS = ITEMS : ITEMDATA
 CASE WORD = 'GET.LIST'; ITEMS = ITEMS : ITEMDATA
 CASE INDEX(SELVERBS, "\":WORD:"\",1)
  IF ITEMS # "" THEN ITEMS = ITEMS : " "
  ITEMS = ITEMS : ITEMDATA
 CASE INDEX(SELSEP,WORD[1,1],1) AND INDEX(MSELVERBS,"\":WORD[2,99]:"\",1)
  IF ITEMS # "" THEN ITEMS = ITEMS : " "
  ITEMS = ITEMS : ITEMDATA 
 CASE 1
  DUM = ITEMS
  BAD = FALSE
  ITEMDATA = TRIM(ITEMDATA)
  IF HOOKS<SSA.PREITEM> = "1" THEN
   SS.EXTRA1 = FN
   SS.EXTRA2 = ACCOUNT
   CALL @SERVSUB(SSA.PREITEM, MAT SS.ARGS, ITEMDATA)
  END
  N = COUNT(ITEMDATA, " ") + (ITEMDATA # '')
  FOR J = 1 TO N
   WORD = FIELD(ITEMDATA, " ", J)
   READV TEST FROM F.DATA, WORD,1 ELSE BAD = TRUE
   DUM<-1> = WORD
  NEXT J
  IF MODE = EXPORT THEN BAD = FALSE
  IF BAD THEN CMND = "ItemsBad"
  ITEMS = DUM
  ITEMLIST = TRUE
END CASE
RETURN
*
* Parse out generated key information
605 ITEMS = "#"
KGFIELD = ""
POS = INDEX(ITEMDATA,"(",1)
LID = LEN(ITEMDATA)
KGF = 1
LOOP
  POS = POS + 1
WHILE POS <= LID DO
  CH = ITEMDATA[POS,1]
  BEGIN CASE
    CASE CH = "," OR CH = ")"
      KEYGEN<KGF> = KGFIELD
      KGF = KGF + 1
      KGFIELD = ""
    CASE CH = '"' OR CH = "'"
      QT = CH
      LOOP
        POS = POS + 1
        CH = ITEMDATA[POS,1]
      WHILE POS <= LID AND CH # QT DO
        KGFIELD = KGFIELD : CH
      REPEAT
    CASE CH = " ";* Ignore spaces
    CASE 1
      KGFIELD = KGFIELD : CH
  END CASE
REPEAT
BAD =0
IF CH # ")" THEN BAD = 1
IF KEYGEN<1> # "" AND NOT(KEYGEN<1> MATCH "1N0N") THEN BAD = 1
IF KEYGEN<2> # "" AND NOT(KEYGEN<2> MATCH "1N0N") THEN BAD = 1
IF BAD THEN CMND = "ItemsBad"
RETURN
*
* List dictionary to file dialog
610 ITEMS = "SELECT DICT "
IF ACCOUNT = "" THEN ITEMS = ITEMS : FN ELSE ITEMS = ITEMS : QFILE.DATA
ITEMS = ITEMS : ' WITH ':DICT.SELEND
DICTLIST = TRUE
IF HOOKS<SSA.FIELDSEL> = "1" THEN
 SS.EXTRA1 = FN
 SS.EXTRA2 = ACCOUNT
 CALL @SERVSUB(SSA.FIELDSEL, MAT SS.ARGS, ITEMS)
 IF SS.RESULT = 2 THEN ITEMLIST = TRUE
END
IF HOOKS<SSA.FIELDCHK> = "1" THEN CHECKKEY = SSA.FIELDCHK
RETURN
*
* List items to dialog
620 ITEMS = 'SELECT '
IF DD # '' THEN ITEMS = ITEMS:DD:' '
IF ACCOUNT = "" THEN ITEMS = ITEMS : FN ELSE ITEMS = ITEMS : QFILE.DATA
ITEMDATA = ITEMDATA[17,99] ;* Lose WINT.ITEMLIST
SEL.TYPE = ITEMDATA[1,1]
ITEMDATA = ITEMDATA[3,99]
BEGIN CASE
 CASE SEL.TYPE = 'A'; NULL
 CASE SEL.TYPE = 'S'
  IF PRIME.STYLE THEN
   ITEMS = ITEMS : ' WITH @ID LIKE "':ITEMDATA:'..."'
  END ELSE ITEMS = ITEMS : ' = "':ITEMDATA:']"'
 CASE SEL.TYPE = 'C'
  IF PRIME.STYLE THEN
   ITEMS = ITEMS : ' WITH @ID LIKE "...':ITEMDATA:'..."'
  END ELSE ITEMS = ITEMS : ' = "[':ITEMDATA:']"'
 CASE SEL.TYPE = 'E'
  IF PRIME.STYLE THEN
   ITEMS = ITEMS:' WITH @ID LIKE "...':ITEMDATA:'"'
  END ELSE
   ITEMS = ITEMS:' = "[':ITEMDATA:'"'
  END
 CASE SEL.TYPE = 'R'
  IF PRIME.STYLE THEN
   ITEMS = ITEMS:' WITH @ID GE "':FIELD(ITEMDATA,';',1):'"'
   ITEMS = ITEMS:' AND WITH @ID LE "' : FIELD(ITEMDATA,';',2) : '"'
  END ELSE
   ITEMS = ITEMS:' GE "':FIELD(ITEMDATA,';',1):'"'
   ITEMS = ITEMS:' AND LE "':FIELD(ITEMDATA,';',2):'"'
  END
END CASE
*
DICTLIST = TRUE                      
*
RETURN
*
* Files list
630 ITEMS = 'SELECT '
IF ACCOUNT = "" THEN ITEMS = ITEMS : FN ELSE ITEMS = ITEMS : QFILE.DATA
ITEMS = ITEMS : " " : FILE.SELEND
DICTLIST = TRUE
IF HOOKS<SSA.FILESEL> = "1" THEN
 ITEMLIST = FALSE
 SS.EXTRA1 = ACCOUNT
 CALL @SERVSUB(SSA.FILESEL, MAT SS.ARGS, ITEMS)
 IF SS.RESULT = 2 THEN ITEMLIST = TRUE
END
IF HOOKS<SSA.FILECHK> = "1" THEN CHECKKEY = SSA.FILECHK
RETURN
*
* Fields
700 FLDDATA = TRIM(DUM[7,MAXRECLEN])
IF HOOKS<SSA.PREFIELD>="1" THEN
  SS.EXTRA1 = FN
  SS.EXTRA2 = ACCOUNT
  CALL @SERVSUB(SSA.PREFIELD, MAT SS.ARGS, FLDDATA)
END
CMND = "FieldsOK"
BAD = FALSE
* 
BEGIN CASE
 CASE FLDDATA = "*"
  IF DICTLIST THEN
   DICTITEMS = 0
   DICTITEMS<1,3> = 10
   DICTITEMS<1,4> = "ID"
  END
  FIELDS = ""
 CASE FLDDATA = ""
  GOSUB 720; * Read key length
  CHECK.MD = FALSE
  WORD = 1
  LOOP
   GOSUB 750; * Read and check dict item
  UNTIL BAD DO
   WORD = WORD+1
  REPEAT
  DICTITEMS = DELETE(DICTITEMS, WORD+1,0,0)
  FIELDS = ""
 CASE 1
  IF MODE = IMPORT AND NOFIELDS = 0 THEN GOSUB 720; * Read Key length
  CHECK.MD = TRUE
  N = COUNT(FLDDATA, " ") + (FLDDATA # '')
  FOR J = 1 TO N UNTIL BAD
   WORD = FIELD(FLDDATA," ", J)
   GOSUB 750; * Process
   IF NOT(BAD) THEN FIELDS = FIELDS : " " : WORD
  NEXT J
  IF BAD THEN CMND = "FieldsBad"; DICTITEMS = ""
END CASE
*
IF DICTITEMS # "" THEN
 STARTFLD = NOFIELDS + 1
 IF STARTFLD < 1 THEN STARTFLD = 1
 NOFIELDS = COUNT(DICTITEMS, AM) + (DICTITEMS # '')
 FOR J = STARTFLD TO NOFIELDS
  CMND = CMND:" ":DICTITEMS<J,3>
 NEXT J
END ELSE NOFIELDS = 0
RETURN
*
* Field Information
710 FLDDATA = TRIM(DUM[9,MAXRECLEN])
CMND = "FldInfoOK"
BAD = FALSE
* 
BEGIN CASE
 CASE FLDDATA = "*"
  IF DICTLIST THEN
   DICTITEMS = 0
   DICTITEMS<1,3> = 10
   DICTITEMS<1,4> = "ID"
  END
  FIELDS = ""
 CASE FLDDATA = ""
  GOSUB 720; * Read key length
  CHECK.MD = FALSE
  WORD = 1
  LOOP
   GOSUB 750; * Read and check dict item
  UNTIL BAD DO
   WORD = WORD+1
  REPEAT
  DICTITEMS = DELETE(DICTITEMS, WORD+1,0,0)
  FIELDS = ""
 CASE 1
  IF MODE = IMPORT AND NOFIELDS = 0 THEN GOSUB 720; * Read Key length
  CHECK.MD = TRUE
  N = COUNT(FLDDATA, " ") + (FLDDATA # '')
  FOR J = 1 TO N UNTIL BAD
   WORD = FIELD(FLDDATA," ", J)
   GOSUB 750; * Process
   IF NOT(BAD) THEN FIELDS = FIELDS : " " : WORD
  NEXT J
  IF BAD THEN CMND = "FldInfoBad"; DICTITEMS = ""
END CASE
*
IF DICTITEMS # "" THEN
 STARTFLD = NOFIELDS + 1
 IF STARTFLD < 1 THEN STARTFLD = 1
 NOFIELDS = COUNT(DICTITEMS, AM) + (DICTITEMS # '')
 IF NOFIELDS THEN CMND = CMND:" "
 FOR J = STARTFLD TO NOFIELDS
  FINFO = DICTITEMS<J>
  IF FINFO<1,8> = "" THEN GOSUB 715; * Figure out missing fields
  CMND = CMND:FINFO<1,3>:",":FINFO<1,6>:",":FINFO<1,7>:",":FINFO<1,8>:",":FINFO<1,9>:";"
 NEXT J
END ELSE NOFIELDS = 0
RETURN
*
* Figure out field type
715 CNV = FINFO<1,2>
TEST.CNV = CNV[1,2]
BEGIN CASE
CASE TEST.CNV = "MD" OR TEST.CNV = "MR" OR TEST.CNV = "ML"
  FINFO<1,8> = 2;* Number type
  IF CNV[3,1] MATCH "1N" THEN FINFO<1,7> = CNV[3,1];* Decimal places
CASE TEST.CNV = "D" OR TEST.CNV = "D2" OR TEST.CNV = "D4"
  FINFO<1,8> = 3;* Date
  FINFO<1,7> = ICONV("3/12/62","D2")[2,1]
  IF FINFO<1,7> = "" THEN FINFO<1,7> = 3
CASE CNV[1,4] = "DDMY"
  FINFO<1,8> = 3;* Date
  FINFO<1,7> = 1
CASE CNV[1,4] = "DMDY"
  FINFO<1,8> = 3;* Date
  FINFO<1,7> = 2
CASE CNV[1,4] = "DYMD"
  FINFO<1,8> = 3;* Date
  FINFO<1,7> = 3
CASE TEST.CNV = "MT"
  FINFO<1,8> = 4;* Time
CASE TEST.CNV = "MC"
  FINFO<1,8> = 1;* String
END CASE
RETURN
* 
* Read key length
720 IF PRIME.FILES THEN KEY.ID = "@ID" ELSE KEY.ID = FN
* 
IF DD = "DICT" THEN
 READ DREC FROM F.MD.TRANS, KEY.ID ELSE DREC = ""
END ELSE
 READ DREC FROM F.DICT, KEY.ID ELSE DREC = ""
END 
* 
DUM = ''
IF DREC # "" THEN
 IF PRIME.FILES THEN
  CALL @CRDICT(KEY.ID, DREC, DUM, MODE, BAD)
  IF BAD THEN DREC = ''
 END ELSE
  DUM = 0
  DUM<1,3> = DREC<10>
  IF LEN(KEY.ID) > DUM<1,3> THEN DUM<1,3> = LEN(KEY.ID)
  DUM<1,4> = FN
 END
END 
IF DREC = '' THEN
 DUM = 0
 DUM<1,3> = 10
 DUM<1,4> = FN
END 
DICTITEMS<-1> = DUM
RETURN
* 
* Read and check dict items
750 FOUND = FALSE
DREC = ""
DUM = ''
IF DICTOPEN THEN
 READ DREC FROM F.DICT, WORD THEN
  FOUND = TRUE
  CALL @CRDICT(WORD, DREC, DUM, MODE, BAD)
 END
END 
IF NOT(FOUND) AND NOT(BAD) AND CHECK.MD THEN
 READ DREC FROM F.MD, WORD THEN FOUND = TRUE
 CALL @CRDICT(WORD, DREC, DUM, MODE, BAD)
END 
IF NOT(FOUND) THEN BAD = TRUE
IF NOT(BAD) THEN DICTITEMS<-1> = DUM
RETURN
* 
* Import
800 MODE = IMPORT
CMND = "ImportOK"
RETURN
* 
* Export
900 MODE = EXPORT
CMND = "ExportOK"
RETURN
* 
* Options
1000 OPTIONS = FIELD(DUM, " ", 2)
IF INDEX(OPTIONS, "O", 1) THEN OVERWRITE = TRUE
IF INDEX(OPTIONS, "A", 1) THEN APPND = TRUE
IF INDEX(OPTIONS, "C", 1) THEN CAPTURE = TRUE
IF INDEX(OPTIONS, "R", 1) THEN RFMT = TRUE
IF RFMT AND NOFIELDS = 0 THEN RFMT = FALSE
IF INDEX(OPTIONS, "I", 1) THEN IDSUPP = TRUE
IF INDEX(OPTIONS, "7", 1) THEN EIGHTBITS = FALSE
IF INDEX(OPTIONS, "D", 1) AND NOFIELDS THEN FIELDDESCS = TRUE
* 
ERR = ''
IF NOFIELDS AND IMPORT THEN
 IF CAPTURE OR RFMT THEN
  FIELDS.LEN = 1
  FOR J = 1 + IDSUPP TO NOFIELDS
   FIELDS.LEN = FIELDS.LEN + DICTITEMS<J,3>
   IF J < NOFIELDS THEN FIELDS.LEN = FIELDS.LEN + 1
  NEXT J
  IF FIELDS.LEN > TERM.WIDTH AND CAPTURE THEN
   ERR = 0
   CALL @TERMWSUB(FIELDS.LEN, ERR)
   IF ERR = 0 THEN TERM.WIDTH = FIELDS.LEN; ERR = ''
  END
 END ELSE
  FOR J = 1 + IDSUPP TO NOFIELDS
   IF DICTITEMS<J,5> # "" THEN ERR = 2
  NEXT J
 END
END 
* 
IF ERR = '' AND USERCHECK # "" THEN GOSUB 1050; * User Check
IF ERR = '' AND HOOKS<SSA.TRANCHK> = "1" THEN GOSUB 1055; * Service check
IF ERR # '' THEN
 CMND = "OptionsBad ":ERR
END ELSE
 CMND = "OptionsOK"
 WORKING = FALSE
END 
* Note: REPORT checks in main program
RETURN
*
* User check for transfer data
1050 GOSUB 1060; * Set up check record
IF DEBUG.ON THEN
 DUM = "Entering routine ":USERCHECK
 WRITE DUM ON F.WORK, "USERCHECK"
END
CALL @USERCHECK(R.CHECK, ERR)
IF DEBUG.ON THEN
 DUM = "Routine exited"
 IF ERR # "" THEN DUM = DUM : ", Error in routine ":ERR
 WRITEV DUM ON F.WORK, "USERCHECK",2
END
IF ERR # '' THEN ERR = 4:ERR
RETURN
*
* Service sub check
1055 GOSUB 1060; * Set up check record
IF DEBUG.ON THEN
 DUM = "Entering routine ":SERVSUB
 WRITE DUM ON F.WORK, "SERVSUB"
END
SS.RESULT = 1
SS.EXTRA1 = ""
CALL @SERVSUB(SSA.TRANCHK, MAT SS.ARGS, R.CHECK)
IF DEBUG.ON THEN
 DUM = "Routine exited"
 IF ERR # "" THEN DUM = DUM : ", Error in routine ":ERR
 WRITEV DUM ON F.WORK, "SERVSUB",2
END
IF SS.RESULT = 0 THEN ERR = 4:' ':SS.EXTRA1
RETURN
*
* Set up check record
1060 R.CHECK = ''
R.CHECK<1> = MODE
IF SPOOL THEN R.CHECK<1> = 3
R.CHECK<2> = ACCOUNT
R.CHECK<3> = DD
R.CHECK<4> = FN
BEGIN CASE
CASE FIELD(ITEMS," ",1) = "REPORT"
   R.CHECK<5> = "*"
   R.CHECK<8> = ITEMS
CASE INDEX(SELSEP, ITEMS[1,1],1)
   R.CHECK<8> = FIELD(ITEMS, ITEMS[1,1],3)
   R.CHECK<5> = FIELD(ITEMS, ITEMS[1,1],2)
CASE 1
   R.CHECK<5> = ITEMS<1>
   R.CHECK<8> = ITEMS<2>
END CASE
R.CHECK<6> = FIELDS
R.CHECK<7> = CAPTURE:VM:OVERWRITE:VM:APPND:VM:IDSUPP:VM:FIELDDESCS:VM:RFMT
R.CHECK<9> = ACCNAME
R.CHECK<10> = PORTNO
RETURN
* 
* Spool file to printer
1400 GOSUB 550;* Initialise
SPOOL = TRUE
MODE = EXPORT
PRINTER ON
PRINT "":
PRINTER OFF
CMND = "SpoolOK"
* Clear file names which aren't used when spooling
DD = ""
DFN = ""
DDD = ""
FILE.TO.OPEN = ""
RETURN
*
* Version
2000 CMND = "PVER":VERSION
RETURN
*
* Buffer sizes
2050 MAX.PC = FIELD(VALUE, " ",2)
IF MAX.PC = "" OR MAX.PC = "0" THEN MAX.PC = 240
BLOCKSIZE = MAX.OUT
IF BLOCKSIZE > MAX.PC - HDRPAD THEN BLOCKSIZE = MAX.PC - HDRPAD
CMND = "HBuffer ":MAX.INP:" ":(BLOCKSIZE + HDRPAD)
RETURN
*
* Host info
2060 CMND = "HInfo ":SEQ(AM)
RETURN
* 
* 
* iNVERT CASE
* 
2100 IF CASE.IS.INVERTED THEN
 DUM = 'PTERM -CASE INVERT'
 CASE.IS.INVERTED = FALSE
END ELSE
 DUM = 'PTERM -CASE NOINVERT'
 CASE.IS.INVERTED = TRUE
END 
* 
CALL @EXECSUB(DUM, '', 0)
INVERTING.CASE = TRUE
* 
RETURN
* 
*
* Initialise transfer program and load machine specific details
5000 CR = CHAR(13)
* 
EOF = FALSE
WORKING = TRUE
CASE.IS.INVERTED = FALSE
INVERTING.CASE = FALSE
FILENAME = ''
ACCOUNT = ''
TERM.WIDTH = ''
SV.LIST = ''
INLIST = ''
SELVERBS = "\SELECT\SSELECT\QSELECT\"
RFMT = FALSE
*
VERSION = VERSION: " (":MACHINE.TYPE:")"
*
READV DEBUG.ON FROM F.BP, 'DEBUG', 1 ELSE DEBUG.ON = ''
IF DEBUG.ON # 1 THEN DEBUG.ON = FALSE
* 
READV USERCHECK FROM F.BP, "USERCHECK",1 ELSE USERCHECK = ''
* 
R.PARAMS = ''
CALL @PARAMSUB(F.MD, R.PARAMS)
MAXRECLEN   = R.PARAMS<1>
PRIME.STYLE = R.PARAMS<2>
IF R.PARAMS<3> = '1' THEN SV.LIST = 0
SELVERBS = SELVERBS : R.PARAMS<4>
PRIME.FILES = R.PARAMS<5>
DICT.SELEND = R.PARAMS<6>
CAPTURE.SELEND = R.PARAMS<7>
FILE.SELEND = R.PARAMS<11>
PRE.EXEC = R.PARAMS<12,1>
POST.EXEC = R.PARAMS<12,2>
*
MAX.INP = R.PARAMS<13,1>
MAX.OUT = R.PARAMS<13,2>
IF MAX.INP = "" THEN MAX.INP = 120
IF MAX.OUT = "" THEN MAX.OUT = 240
*
ACCNAME = R.PARAMS<8>
PORTNO = R.PARAMS<9>
TERM.WIDTH = R.PARAMS<10>
OLD.WIDTH = TERM.WIDTH
* 
QFILE.DATA = 'QIBSDATA' : PORTNO
QFILE.MD   = 'QIBSMD' : PORTNO
K.ITEMLIST = "ITEMLIST." : PORTNO
*
MSELVERBS = SELVERBS:"GET-LIST\GET.LIST\REPORT\"
* 
IF DEBUG.ON THEN
 OPEN '','WIN.WORK' : PORTNO TO F.WORK ELSE
    OPEN '','WIN.WORK' TO F.WORK ELSE DEBUG.ON = FALSE
 END
 IF DEBUG.ON THEN CLEARFILE F.WORK
 NSEQ = 0
END 
*
HOOKS = ""
SS.ARGS(1) = 2; * Id for WIN.TRANSFER
SS.ARGS(2) = R.PARAMS
IF SERVSUB # "" THEN
 CALL @SERVSUB(SSA.INIT, MAT SS.ARGS, HOOKS);* Initialise service routine
END
*
RETURN
* 
* Set up parameters for main program
5200 *
   FILE.INFO<1> = ACCOUNT
   FILE.INFO<2> = FILENAME
   FILE.INFO<3> = DD
   FILE.INFO<4> = DFN
   FILE.INFO<5> = DDD
   FILE.INFO<6> = FILE.TO.OPEN
   ITEM.INFO  = ITEMS
   ITEM.LIST  = ITEMLIST
   FIELD.INFO<1> = NOFIELDS
   FIELD.INFO<2> = FIELDS.LEN
   FIELD.INFO<3> = FIELDS
   DICT.INFO = DICTITEMS
   CASE.INFO<1> = CASE.IS.INVERTED
   CASE.INFO<2> = INVERTING.CASE
   QFILE.INFO<1> = QFILE.DATA
   QFILE.INFO<2> = QFILE.MD
   WORK.INFO<1> = WRKFILE
   WORK.INFO<2> = K.ITEMLIST
   MODE.INFO = MODE
   SUBMODES<1> = SPOOL
RETURN
*
END
