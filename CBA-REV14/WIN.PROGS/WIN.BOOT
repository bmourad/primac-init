* Cut down version of File transfer routine to install host programs
* Copyright (c) 1991-2000. Impact Business Systems 
* Copyright (c) 2000. Informix Corporation. All rights reserved.
* 
* This program is hardcoded to import a single specific file
* 
VERSION='4.21 08/12/00 (BOOT)'
PROMPT ''
ECHO OFF
*
DUM = @(-1); * Stops automatic screen paging
DUM = @(0,0); * As above but for UniVerse
* 
EQU TRUE TO 1,FALSE TO 0
AMVM=1; AMVM<1,2>=2; AMVM<2>=3
AM=AMVM[4,1]
VM=AMVM[2,1]
* 
EQU BLOCKLEN TO 120
EQU STARTUP TO 0,EXPORT TO 2
* 
EQU MAXRECLEN TO 32000
* 
CR=CHAR(13)
CS=CHAR(27):CHAR(1)
ITEMSEP="|"
CHARSUB1="}"
CHARSUB2="{"
AMCHAR="~"
* 
EOF=FALSE
WORKING=TRUE
RXREC=''
SEQKEY=0
FILENAME=''
AN='' 
* 
OPEN '','WIN.PROGS' TO F.BP ELSE STOP "WIN.PROGS IS MISSING"
* Clear api install item used as flag
DELETE F.BP,"API.INSTALL"
* 
MODE=STARTUP
* 
CMND="ConnectOK"
* 
GOSUB 10 ;* Transfer wIntegrate
* 
LOOP 
WHILE WORKING DO
GOSUB 40;* Generate Checksum
PRINT CHKSUM:CMND:CR:
INPUT DUM:
LOOP 
WHILE SEQ(DUM[1,1]) < 31 AND DUM[1,1] # "" DO
DUM=DUM[2,99999]
REPEAT 
CHKERR=TRUE
IF DUM[1,3] MATCH "3N" THEN GOSUB 50;* Check checksum
REPLY=DUM[1,4]
VALUE=DUM[5,999]
* 
BEGIN CASE
CASE CHKERR; NULL
CASE REPLY MATCH "'E'3N"; GOSUB 100;* Export data
CASE REPLY="END"; WORKING=FALSE
CASE REPLY="Expo"; GOSUB 900;* Set Export mode
CASE REPLY="File"; GOSUB 500;* Check and open file
CASE REPLY="Item"; CMND="ItemsOK"
CASE REPLY="Fiel"; CMND="FieldsOK"
CASE REPLY="Opti"; CMND="OptionsOK"
CASE REPLY="Read"; CMND="F000";* Ask for first block
CASE REPLY="Vers"; GOSUB 2000;* Send Version number
END CASE
REPEAT 
* 
IF MODE=EXPORT AND RXREC # '' THEN GOSUB 120;* Write final record
* 
CMND="BYE" ;* Tell wIntegrate this program has finished
GOSUB 40;* Generate Checksum
PRINT CHKSUM:CMND:CR:
ECHO ON
PRINT @(0):
* 
IF FILENAME # "" THEN GOSUB 1000
STOP 
* 
* Internal subroutines 
* 
* Start transfer
10 XFER = 'Script "host\bootexp"'
* 
PRINT CS:XFER:CR:
* 
RETURN 
* 
* 
* Generate Checksum for CMND
40 L=LEN(CMND) 
CHKSUM=0
FOR J=1 TO L
CHKSUM=CHKSUM + SEQ(CMND[J,1])
NEXT J 
CHKSUM='000':CHKSUM
CHKSUM=CHKSUM[LEN(CHKSUM)-2,3]
RETURN 
* 
* Check check sum
50 L=LEN(DUM) 
CHK=0 
FOR J=4 TO L
CHK=CHK + SEQ(DUM[J,1])
NEXT J 
CHK='000':CHK
CHK=CHK[LEN(CHK)-2,3]
IF CHK=DUM[1,3] THEN
CHKERR=FALSE
DUM=DUM[4,99999]
END 
RETURN 
* 
* Receive data exported from PC
100 IF BLOCK # REPLY[2,3] THEN RETURN 
S=AMCHAR; R=AM; GOSUB 150
* 
LOOP 
C=INDEX(VALUE,ITEMSEP,1)
WHILE C DO
DUM=VALUE[C+1,99999]
VALUE=VALUE[1,C-1]
GOSUB 170;* Convert characters
RXREC=RXREC:VALUE
GOSUB 120;* Write record
LEN.RXREC=0
OVERFLOW=0
VALUE=DUM
RXID=''
RXREC=''
REPEAT 
GOSUB 170;* Convert control characters
* 
LEN.RXREC=LEN.RXREC + LEN(VALUE)
IF LEN.RXREC > MAXRECLEN THEN
GOSUB 120;* Write record
OVERFLOW=OVERFLOW + 1
RXREC=''
LEN.RXREC=LEN(VALUE)
END 
RXREC=RXREC:VALUE
BLOCK=(BLOCK + 1) 
BLOCK='000':BLOCK
BLOCK=BLOCK[LEN(BLOCK)-2,3]
CMND='F':BLOCK
RETURN 
* 
* Write record on host
120 ID="" 
* Find or calculate the id
IF RXID='' OR OVERFLOW=0 THEN
RXID=RXREC<1>
RXREC=DELETE(RXREC,1,0,0)
ID=RXID
END 
IF OVERFLOW THEN ID=RXID:'.':OVERFLOW
* 
WRITE RXREC ON F.DATA,ID
RETURN 
* 
* Replace character S with character R in VALUE
150 LOOP 
C=INDEX(VALUE,S,1)
WHILE C DO
VALUE=VALUE[1,C-1]:R:VALUE[C+1,99999]
REPEAT 
RETURN 
* 
* Convert control values from a value
170 POS=0 
LOOP 
C=INDEX(VALUE[POS+1,99999],CHARSUB1,1)
WHILE C DO
C=C + POS
CH=SEQ(VALUE[C+1,1])
POS=C 
IF CH < 64 THEN CH=CH - 32 ELSE CH=CH + 150 
VALUE=VALUE[1,C-1]:CHAR(CH):VALUE[C+2,99999]
REPEAT 
* 
POS=0 
LOOP 
C=INDEX(VALUE[POS+1,99999],CHARSUB2,1)
WHILE C DO
C=C + POS
POS=C 
VALUE=VALUE[1,C-1]:CHAR(SEQ(VALUE[C+1,1]) + 91):VALUE[C+2,99999]
REPEAT 
* 
RETURN 
* 
* Filename
500 IF VALUE[1,1]='(' THEN 
AN=FIELD(VALUE,' ',1)[2,999]
VALUE=VALUE[COL2()+1,999]
END 
AN='' 
DD=FIELD(VALUE," ",1)
FN=FIELD(VALUE," ",2)
IF FN="" THEN FN=DD; DD=""
* 
FILE.TO.OPEN=FN
* 
OPEN DD,FILE.TO.OPEN TO F.DATA THEN
FILENAME=VALUE
DICTOPEN=FALSE
IF DD # "DICT" THEN
OPEN "DICT",FILE.TO.OPEN TO F.DICT THEN DICTOPEN=TRUE
END 
GOSUB 550;* Initialise Variables
END ELSE
CMND='FileBad'
END 
RETURN 
* 
* Initialise transfer variables
550 BLOCK='000' 
RXREC=''
RXID=''
CMND='FileOK'
LEN.RXREC=0
OVERFLOW=0
RETURN 
* 
* Export 
900 MODE=EXPORT 
CMND="ExportOK"
RETURN 
* 
* 
* Compile & catalog programs
1000 READV MACHINE.TYPE FROM F.DATA,'MACHINE.TYPE',1 ELSE MACHINE.TYPE='' 
IF MACHINE.TYPE='' THEN MACHINE.TYPE='GENERIC'
* 
BEGIN CASE
CASE MACHINE.TYPE = 'PR' OR MACHINE.TYPE = 'PI'
SEL='SELECT WIN.PROGS WITH F3 LIKE "... ':MACHINE.TYPE:'..." AND WITH @ID UNLIKE "$..."'
SELECT F.DATA
EOF=FALSE
CMND=''
CMND<-1>='PA'
CMND<-1>='SLEEP 5'
CMND<-1>='BASIC WIN.PROGS WIN.FIX.PI'
CMND<-1>='RUN WIN.PROGS WIN.FIX.PI'
CMND<-1>=SEL
CMND<-1>='BASIC WIN.PROGS'
CMND<-1>='SLEEP 5'
* 
LOOP 
READNEXT KEY ELSE EOF=TRUE
UNTIL EOF DO
IF KEY[1,1] # "$" THEN
READV DUM FROM F.DATA,KEY,3 THEN
IF INDEX(DUM,MACHINE.TYPE,1) # 0 THEN
IF INDEX(DUM, MACHINE.TYPE:'.SUB', 1) = 0 THEN LCL = ' LOCAL' ELSE LCL = ''
CMND<-1>='CATALOG WIN.PROGS ':KEY:LCL
END 
END 
END 
REPEAT 
*
CMND<-1>='RUN WIN.PROGS WIN.ENDBOOT'
* 
OPEN '','VOC' TO F.VOC ELSE CMND=''
IF CMND # '' THEN
WRITE CMND ON F.VOC,"WIN.BOOT.PR"
END 
* 
CASE MACHINE.TYPE = 'UV' OR MACHINE.TYPE = 'UP'
SEL='SELECT WIN.PROGS WITH F3 LIKE "... ':MACHINE.TYPE:'..."'
CMND='PA'
CMND<-1>=SEL
CMND<-1> = 'BASIC WIN.PROGS'
CMND<-1>=SEL
CMND<-1>='CATALOG WIN.PROGS'
CMND<-1>='DATA N'
*
CMND<-1>='WIN.ENDBOOT'
*
OPEN '','VOC' TO F.VOC ELSE CMND=''
IF CMND # '' THEN
WRITE CMND ON F.VOC,"WIN.BOOT.UV"
END 
* 
CASE MACHINE.TYPE = 'UD' OR MACHINE.TYPE = "UC"
SEL='select WIN.PROGS WITH f3 LIKE "... ':MACHINE.TYPE:'..." USING DICT VOC'
CMND='PA'
IF MACHINE.TYPE = "UD" THEN
CMND<-1>="ECLTYPE 'U'"
CMND<-1>="BASICTYPE 'U'"
END ELSE
CMND<-1>="ECLTYPE 'P'"
CMND<-1>="BASICTYPE 'P'"
END
CMND<-1>=SEL
CMND<-1>='BASIC WIN.PROGS'
CMND<-1>=SEL
CMND<-1>='CATALOG WIN.PROGS FORCE'
CMND<-1>='DATA Y'
*
CMND<-1>='WIN.ENDBOOT'
*
OPEN '','VOC' TO F.VOC ELSE CMND = ''
IF CMND # "" THEN
WRITE CMND ON F.VOC, "WIN.BOOT.UD"
READV VMS FROM F.BP, "MACHINE.TYPE",2 ELSE VMS = ''
IF VMS = "VMS" THEN
CMND = "PA"        
CMND<2>="WIN_TRANSFER"
WRITE CMND ON F.VOC, "WIN":".TRANSFER"
CMND<2>="WIN_SERVER"
WRITE CMND ON F.VOC, "WIN":".SERVER"
END
END
* 
CASE MACHINE.TYPE = "MD"
OPEN '','MD' TO F.MD THEN
READ DREC FROM F.MD, "*A3" ELSE
DREC = "A"
DREC<2> = 3
DREC<9> = "L"
DREC<10> = 10
WRITE DREC ON F.MD, "*A3"
END
END
*
END CASE
* 
RETURN 
* 
* Version
2000 CMND="PVER":VERSION 
RETURN 
* 
END
