* WIN.TRANSFER
* Connect to wIntegrate window Program file tranfer routines.
* Compile for: GENERIC AP MD ME PI PR SQ UD UL UP UV UC IN GA
* Copyright (c) 2000. Informix Corporation. All rights reserved.
* Copyright (c) 1991-2000. Impact Business Systems
* 
* Host machine type is read from MACHINE.TYPE record
* 
VERSION = "4.2.1 08/12/2000"
PROMPT ''
ECHO OFF
DUM = @(-1); * Stops automatic screen paging
DUM = @(0,0); * As above but for UniVerse
* 
EQU TRUE TO 1, FALSE TO 0
AMVM=1; AMVM<1,2>=2; AMVM<2>=3
AM=AMVM[4,1]
VM=AMVM[2,1]
* 
EQU STARTUP TO 0, IMPORT TO 1, EXPORT TO 2
EQU HDRPAD TO 10
BLOCKLEN = 240
* 
* Service sub parameters
DIM SS.ARGS(30)
MAT SS.ARGS = ''
EQU SS.PROGS  TO SS.ARGS(1)
EQU SS.PARAM  TO SS.ARGS(2)
EQU SS.RESULT TO SS.ARGS(3)
EQU SS.EXTRA1 TO SS.ARGS(4)
EQU SS.EXTRA2 TO SS.ARGS(5)
*
EQU SSA.INIT    TO 1
EQU SSA.FILESEL TO 2
EQU SSA.FILECHK TO 3
EQU SSA.FIELDSEL TO 4
EQU SSA.FIELDCHK TO 5
EQU SSA.EXECCHK  TO 6
EQU SSA.TRANCHK TO 7
*
DIM R.HDR(30)
MAT R.HDR = ''
*
EQU F.BP         TO R.HDR(1)
EQU F.WORK       TO R.HDR(2)
EQU F.DATA       TO R.HDR(3)
EQU F.MD         TO R.HDR(4)
EQU VERSTRING    TO R.HDR(5)
EQU MACHINE.TYPE TO R.HDR(6)
EQU SERVNAME     TO R.HDR(7)
EQU DEBUG.ON     TO R.HDR(9)
EQU HOOKS        TO R.HDR(10)
EQU BLOCKSIZE    TO R.HDR(11)
EQU OPTIONS      TO R.HDR(12)
EQU FILE.INFO    TO R.HDR(13)
EQU ITEM.INFO    TO R.HDR(14)
EQU ITEM.LIST    TO R.HDR(15)
EQU FIELD.INFO   TO R.HDR(17)
EQU DICT.INFO    TO R.HDR(18)
EQU QFILE.INFO   TO R.HDR(19)
EQU CASE.INFO    TO R.HDR(20)
EQU MODE.INFO    TO R.HDR(21)
EQU SERV.INFO    TO R.HDR(22)
EQU WORK.INFO    TO R.HDR(23)
EQU SUBMODES     TO R.HDR(24)
EQU NSEQ         TO R.HDR(25)
EQU KEYGEN       TO R.HDR(26)
*
HDR.ERR = 0
VERSTRING = VERSION
CALL WIN.TRANHDR(MAT R.HDR, MAT SS.ARGS, HDR.ERR)
IF HDR.ERR THEN STOP
*
R.PARAMS     = SS.PARAM
*
SUB.SUFFIX = ''
IF MACHINE.TYPE # 'GENERIC' THEN SUB.SUFFIX = '.' : MACHINE.TYPE
PARAMSUB = "WIN.PARAM" : SUB.SUFFIX
MAKEQ = "WIN.MAKEQ" : SUB.SUFFIX
CRDICT = "WIN.DICT" : SUB.SUFFIX
ITEMSUB = "WIN.ITEM" : SUB.SUFFIX
EXECSUB = "WIN.EXEC" : SUB.SUFFIX
TERMWSUB = "WIN.TERMW" : SUB.SUFFIX
REFSUB = "WIN.RFMT" : SUB.SUFFIX
*
GOSUB 5000; * Initialise
SERVSUB=SERVNAME
*
GOSUB 40; * Generate Checksum
SNDBLOCK = CHKSUM:CMND:CR
PRINT SNDBLOCK:
* 
LOOP 
 INPUT DUM:
 LOOP
 WHILE SEQ(DUM[1,1]) < 31 AND DUM[1,1] # "" DO
  DUM = DUM[2,MAXRECLEN]
 REPEAT
 CHKERR = TRUE
 IF DUM[1,3] MATCH "3N" THEN GOSUB 50; * check checksum
 IF DEBUG.ON THEN
  NSEQ = NSEQ+1
  IF NSEQ > 99 THEN NSEQ = 1
  WRITE CMND : AM : DUM ON F.WORK, PORTNO * 100 + NSEQ
 END
 REPLY = DUM[1,4]
 VALUE = DUM[5,MAXRECLEN]
 CALC.BLOCK = FALSE
 CMND = ''
* 
 BEGIN CASE
  CASE CHKERR; NULL
  CASE REPLY MATCH "'E'3N"
   IF CHK.BLOCK = REPLY[2,3] THEN
    SNDBLOCK = NXTBLOCK
    CALC.BLOCK = TRUE
   END
  CASE REPLY MATCH "'I'3N" AND MODE = IMPORT
   IF CHK.BLOCK = REPLY[2,3] THEN
    SNDBLOCK = NXTBLOCK
    CALC.BLOCK = TRUE
   END
  CASE REPLY = "CImp" AND MODE = IMPORT; GOSUB 1200; * Capture 
  CASE REPLY = "END"; WORKING = FALSE
  CASE REPLY = "Sele"; GOSUB 1100    ;* Select data for import
  CASE REPLY = "Read"; GOSUB 1900    ;* Start Export
 END CASE
*
WHILE WORKING DO
*
 IF CMND # "" THEN
  GOSUB 40; * Generate Checksum
  SNDBLOCK = CHKSUM:CMND:CR
 END
 PRINT SNDBLOCK:
*
 IF CALC.BLOCK THEN
  BEGIN CASE
   CASE REPLY[1,1] = "E"; GOSUB 100; * Export data
   CASE REPLY[1,1] = "I"; GOSUB 200; * Send Data
  END CASE
  GOSUB 40; * Generate Checksum
  NXTBLOCK = CHKSUM:CMND:CR 
 END
*
REPEAT
* 
IF MODE = EXPORT AND RXREC # '' THEN GOSUB 120; * Write final record
* 
CMND = "BYE" ; * Tell wIntegrate this program has finished
GOSUB 40; * Generate Checksum
PRINT CHKSUM:CMND:CR:
ECHO ON
IF ACCOUNT # "" THEN
 DELETE F.MD, QFILE.MD
 DELETE F.MD, QFILE.DATA
END 
IF CASE.IS.INVERTED THEN
 GOSUB 2100                            ;* Invert case
END 
*
IF RFMT THEN
 CALL @REFSUB(F.DATA, R.RFMT, SV.LIST, TIDYUP, NOITEMS, ERR)
END
*
IF OLD.WIDTH # TERM.WIDTH THEN
 CALL @TERMWSUB(OLD.WIDTH, ERR)
END
*
IF POST.EXEC # '' THEN CALL @EXECSUB(POST.EXEC, '', 0)
*
PRINT @(0):
STOP 
* 
*----------- Internal subroutines -----------------------
* 
* Generate Checksum for CMND
40 L = LEN(CMND)
CHKSUM = 0
FOR J = 1 TO L
 CHKSUM = CHKSUM + SEQ(CMND[J,1])
NEXT J
CHKSUM = '000' : CHKSUM
CHKSUM = CHKSUM[LEN(CHKSUM)-2,3]
RETURN
* 
* Check check sum
50 L = LEN(DUM)
CHK = 0
FOR J = 4 TO L
 CHK = CHK + SEQ(DUM[J,1])
NEXT J
CHK = '000' : CHK
CHK = CHK[LEN(CHK)-2,3]
* 
IF CHK = DUM[1,3] THEN
 CHKERR = FALSE
 DUM = DUM[4,MAXRECLEN]
END 
RETURN
* 
* Receive data Exported from PC
* 
100 S = AMCHAR; R = AM; GOSUB 150
* 
LOOP 
 C = INDEX(VALUE, ITEMSEP, 1)
WHILE C DO
 DUM = VALUE[C+1, MAXRECLEN]
 VALUE = VALUE[1, C-1]
 GOSUB 170; * Convert characters
 RXREC = RXREC : VALUE
 GOSUB 120; * Write record
 LEN.RXREC = 0
 OVERFLOW = 0
 VALUE = DUM
 RXID = ''
 RXREC = ''
REPEAT
GOSUB 170; * Convert control characters
* 
LEN.RXREC = LEN.RXREC + LEN(VALUE)
IF LEN.RXREC > MAXRECLEN THEN
 GOSUB 120; * Write record
 OVERFLOW = OVERFLOW + 1
 RXREC = ''
 LEN.RXREC = LEN(VALUE)
END 
RXREC = RXREC : VALUE
CHK.BLOCK = BLOCK
BLOCK = (BLOCK + 1) 
BLOCK = '000' : BLOCK
BLOCK = BLOCK[LEN(BLOCK)-2,3]
CMND = 'F':BLOCK
RETURN
* 
* Write (or Spool) record on host
120 ID = ""
OK.TO.WRITE = TRUE
* Restructure the record if there is a field list
IF NOFIELDS THEN
 NEWREC = ""
 FOR J = 1 TO NOFIELDS
  VAL = RXREC<J>
  IF DICTITEMS<J,2> # "" AND NOT(SPOOL) THEN
     NO.VALS = COUNT(VAL,VM)+1
     FOR K = 1 TO NO.VALS
       VAL<1,K> = ICONV(VAL<1,K>, DICTITEMS<J,2>)
     NEXT K
  END
  FNO = DICTITEMS<J,1>
  IF FNO THEN NEWREC<FNO> = VAL ELSE RXID = VAL
 NEXT J
 RXREC = NEWREC
END 
* 
* Find or calculate the id
IF RXID = '' OR OVERFLOW = 0 THEN
 BEGIN CASE
  CASE ITEMLIST
   RXID = ITEMS<1>
   ITEMS = DELETE(ITEMS,1,0,0)
  CASE ITEMS = "#"
   RXID = ""
   IF KEYGEN # "" THEN
      IDLEN = KEYGEN<2>
      IF LEN(SEQKEY) < IDLEN THEN
         SEQKEY = STR("0",IDLEN - LEN(SEQKEY)) : SEQKEY
      END
      RXID = KEYGEN<3>:SEQKEY:KEYGEN<4>         
      SEQKEY = SEQKEY + 1
   END
  CASE FIELDS = "" AND NOT(SPOOL)
   RXID = RXREC<1>
   RXREC = DELETE(RXREC,1,0,0)
 END CASE
 IF RXID = "" THEN SEQKEY = SEQKEY+1; RXID = SEQKEY
 ID = RXID
END 
IF OVERFLOW THEN ID = RXID:'.':OVERFLOW
* 
IF NOT(OVERWRITE) AND NOT(SPOOL) THEN
 READ OLDREC FROM F.DATA, ID THEN OK.TO.WRITE = FALSE ELSE OLDREC = ''
 IF APPND THEN
  IF NOT(OK.TO.WRITE) THEN OK.TO.WRITE = TRUE
  IF NOFIELDS THEN
   FOR J = 1 TO NOFIELDS
    FNO = DICTITEMS<J,1>
    IF FNO THEN OLDREC<FNO> = RXREC<FNO>
   NEXT J
   RXREC = OLDREC
  END ELSE
   IF OLDREC # "" THEN RXREC = OLDREC:AM:RXREC
  END
 END
END 
IF OK.TO.WRITE THEN
 IF SPOOL THEN
  GOSUB 180; * Spool data
 END ELSE
  WRITE RXREC ON F.DATA, ID
 END
END 
RETURN
* 
* Replace character S with character R in VALUE
150 LOOP
 C = INDEX(VALUE, S,1)
WHILE C DO
 VALUE = VALUE[1,C-1]:R:VALUE[C+1, MAXRECLEN]
REPEAT
RETURN
* 
* Convert control values from a value
170 POS = 0
LOOP 
 C = INDEX(VALUE[POS+1, MAXRECLEN], CHARSUB1,1)
WHILE C DO
 C = C + POS
 CH = SEQ(VALUE[C+1,1])
 POS = C
 IF CH < 64 THEN CH = CH - 32 ELSE CH = CH + 150
 VALUE = VALUE[1,C-1]: CHAR(CH) : VALUE[C+2,MAXRECLEN]
REPEAT
* 
POS = 0
LOOP 
 C = INDEX(VALUE[POS+1, MAXRECLEN], CHARSUB2,1)
WHILE C DO
 C = C + POS
 POS = C
 VALUE = VALUE[1,C-1]: CHAR(SEQ(VALUE[C+1,1]) + 91) : VALUE[C+2,MAXRECLEN]
REPEAT
* 
RETURN
* 
* Spool PC file
180 IF INFODUE THEN
 SPOOLTYPE = RXREC<1>
 SPOOLPAD = RXREC<2>
 SPOOLFLDS = COUNT(SPOOLPAD, VM)
 SPOOLSEP = RXREC<3>
 INFODUE = FALSE
END ELSE
 PRINTER ON
 N = COUNT(RXREC, AM) + (RXREC # '')
 IF N > SPOOLFLDS AND SPOOLFLDS # 0 THEN N = SPOOLFLDS
 IF SPOOLTYPE = 'R' THEN
  FOR J = 1 TO N
   IF J > 1 AND SPOOLSEP # "" THEN PRINT SPOOLSEP:
   IF SPOOLFLDS THEN
    FRMT = SPOOLPAD<1,J>
    IF FRMT # "" THEN
     FFLD = RXREC<J> : SPACE(FRMT)
     PRINT FFLD[1,FRMT]:
    END
   END ELSE PRINT RXREC<J>:
  NEXT J
  PRINT
 END ELSE
  FOR J = 1 TO N
   PRINT RXREC<J>
  NEXT J
 END
 PRINTER OFF
END 
RETURN
* 
* Import data to PC from pick
200 MORE = TRUE
*
LOOP 
WHILE TXCODEDLEN < BLOCKLEN AND MORE DO
 IF REC = "" THEN
  IF TXMORE = "" THEN
   IF EOF THEN
    MORE = FALSE
   END ELSE
    IF ITEMCNT THEN
     TXCODED = TXCODED : ITEMSEP
     TXCODEDLEN = TXCODEDLEN + 1
    END
    GOSUB 210; * Read next record
   END
  END ELSE
   REC = TXMORE[1,4800]
   TXMORE = TXMORE[4801,MAXRECLEN]
  END
 END
* 
 IF MORE THEN
  IF EIGHTBITS THEN GOSUB 250 ELSE GOSUB 240; * Add data to TXREC
 END
REPEAT
* 
IF TXCODEDLEN <= BLOCKLEN THEN
 TXREC = TXCODED
 TXCODEDLEN = 0
 TXCODED = ''
END ELSE
 N = BLOCKLEN
 IF TXCODED[N,1] = CHARSUB1 OR TXCODED[N,1] = CHARSUB2 THEN N = N - 1
 TXREC = TXCODED[1,N]
 TXCODED = TXCODED[N+1, MAXRECLEN]
 TXCODEDLEN = TXCODEDLEN - N
END
*
IF MORE OR TXCODED # "" THEN CMND = 'X' ELSE CMND = 'L'
CMND = CMND:BLOCK:TXREC
CHK.BLOCK = BLOCK
*
TXREC = ''
BLOCK = (BLOCK + 1)
BLOCK = '000' : BLOCK
BLOCK = BLOCK[LEN(BLOCK)-2,3]
TXLEN = 0
RETURN
* 
* Read next record from the file
210 LOOP
 READ.OK = TRUE
 IF ITEMLIST THEN
  KEY = ITEMS<1>
  ITEMS = DELETE(ITEMS, 1,0,0)
  IF KEY = "" THEN EOF = TRUE
 END ELSE
  READNEXT KEY FROM SV.LIST ELSE EOF = TRUE
 END
 IF NOT(EOF) THEN
  IF CHECKKEY THEN
   CALL @SERVSUB(CHECKKEY, MAT SS.ARGS, KEY)
   READ.OK = SS.RESULT
  END
  IF READ.OK THEN
   READ TXMORE FROM F.DATA, KEY THEN
    IF DD = "DICT" AND TXMORE<1>[1,1] = "D" THEN
     IF NOT(PRIME.FILES) THEN READ.OK = FALSE
    END
    IF READ.OK THEN
     ITEMCNT = ITEMCNT + 1
     IF NOFIELDS THEN
      GOSUB 220; * Reformat Record
     END ELSE
      IF IDSUPP THEN
       KEY = TXMORE<1>
       TXMORE = DELETE(TXMORE,1,0,0)
      END
     END
     IF LEN(TXMORE) > 4800 THEN
      REC = KEY : AM : TXMORE[1, 4800]
      TXMORE = TXMORE[4801, MAXRECLEN]
     END ELSE
      REC = KEY
      IF TXMORE # "" THEN REC = REC : AM : TXMORE
      TXMORE = ''
     END
    END
   END ELSE READ.OK = FALSE
  END
 END
UNTIL READ.OK DO
REPEAT
* 
RETURN
* 
* 
* Reformat Record for transfer of specific fields
220 NEWREC = ""
NEWID = ""
FIRST.FLD = 1 + IDSUPP
FOR J = FIRST.FLD TO NOFIELDS
 AMC = DICTITEMS<J,1>
 IF AMC THEN VAL = TXMORE<AMC> ELSE VAL = KEY
 IF DICTITEMS<J,2> # "" THEN
  N = COUNT(VAL, VM) + (VAL # '')
  FOR K = 1 TO N
   VAL<1,K> = OCONV(VAL<1,K>, DICTITEMS<J, 2>)
  NEXT K
 END
 IF J = FIRST.FLD THEN NEWID = VAL ELSE NEWREC<J-FIRST.FLD> = VAL
NEXT J
KEY = NEWID
TXMORE = NEWREC
RETURN
* 
* Add data to be sent as 7-bit characters (ascii range 32-122)
* First translate common chars quickly
240 VALUE = REC[1,BLOCKLEN]
IF LEN(VALUE) < BLOCKLEN THEN REC = '' ELSE REC = REC[BLOCKLEN+1,MAXRECLEN]
S = CHARSUB2
R = CHARSUB2RPL
GOSUB 270; * Replace
S = CHARSUB1
R = CHARSUB1RPL
GOSUB 270; * Replace
S = ITEMSEP
R = ITEMSEPRPL
GOSUB 270; * Replace
S = AMCHAR
R = AMCHARRPL
GOSUB 270; * Replace
S = AM
R = AMCHAR
GOSUB 270; * Replace
*
J = 0
LOOP 
 J = J + 1
 J1 = J
 LOOP
  CH = VALUE[J1,1]
 UNTIL CH  < MINCHAR OR CH > MAXCHAR DO
  J1 = J1 + 1
 REPEAT
 IF J1 > J THEN
  TL = J1 - J
  TXCODEDLEN = TXCODEDLEN + TL
  TXCODED = TXCODED : VALUE[J,TL]
 END
 J = J1
WHILE CH # "" DO
 CH = SEQ(CH)
 BEGIN CASE
  CASE CH  < 32
   CH = CHARSUB1 : CHAR(CH+32)
   TXCODEDLEN = TXCODEDLEN + 2
  CASE CH > 213
   CH = CHARSUB1 : CHAR(CH - 150)
   TXCODEDLEN = TXCODEDLEN+ 2
  CASE CH > 122
   CH = CHARSUB2 : CHAR(CH - 91)
   TXCODEDLEN = TXCODEDLEN + 2
  CASE 1
   CH = CHAR(CH)
   TXCODEDLEN = TXCODEDLEN + 1
 END CASE
*
 TXCODED = TXCODED : CH
REPEAT
*   
*
RETURN
* 
* Add data to be sent as 8-bit characters
* Only Conversions done are for ITEMSEP and hex char
250 VALUE = REC[1,BLOCKLEN-TXLEN]
L = LEN(VALUE)
S = CHARSUB2
R = CHARSUB2RPL
GOSUB 270; * Replace
IF REPLACED THEN GOSUB 280; * Shorten line
S = CHARSUB1
R = CHARSUB1RPL
GOSUB 270; * Replace
IF REPLACED THEN GOSUB 280; * Shorten line
S = ITEMSEP
R = ITEMSEPRPL
GOSUB 270; * Replace
IF REPLACED THEN GOSUB 280; * Shorten line
S = AMCHAR
R = AMCHARRPL
GOSUB 270; * Replace
IF REPLACED THEN GOSUB 280; * Shorten line
REC = REC[L+1, MAXRECLEN]
TXCODED = TXCODED : VALUE
TXCODEDLEN = LEN(TXCODED)
RETURN
* 
* Replace S with R in VALUE
270 POS = 0                                             
REPLACED = FALSE
LOOP                                                
 C = INDEX(VALUE[POS+1, MAXRECLEN], S,1)       
WHILE C DO                                          
 REPLACED = TRUE
 C = C + POS                                      
 POS = C                                          
 VALUE = VALUE[1,C-1] : R : VALUE[C+1,MAXRECLEN]
REPEAT
RETURN
* 
* Shorten line to 120 characters (L is reduced suitably for orignal record)
280 N = BLOCKLEN
IF VALUE[N,1] = CHARSUB2 THEN N = N - 1
N2 = LEN(VALUE)
FOR J = N+1 TO N2
 IF VALUE[J,1] # CHARSUB2 THEN L = L - 1
NEXT J
VALUE = VALUE[1,N]
RETURN
*
* Select data for import
1100 IF SELDONE = FALSE THEN
 BAD = FALSE
 CAPTURE.SEL = FALSE
 IF NOFIELDS THEN CAPTURE.SEL = CAPTURE
*
 IF RFMT THEN
  R.RFMT = DD:' ':FILE.TO.OPEN
  IF ITEMLIST THEN
   N = DCOUNT(ITEMS, AM)
   FOR J = 1 TO N
    R.RFMT<2> = R.RFMT<2> : ' "':ITEMS<J>:'"'
   NEXT J
  END ELSE R.RFMT<2> = ITEMS<1>
  R.RFMT<3> = ITEMLIST
  R.RFMT<4> = FIELDS
  R.RFMT<5> = FIELDS.LEN
  R.RFMT<6> = PORTNO
  IF DFN # "" THEN R.RFMT<7> = DDD:" ":DFN
  R.RFMT<8> = ITEMS<2>
  CALL @REFSUB(F.DATA, R.RFMT, SV.LIST, TIDYUP, NOITEMS, ERR)
  NOFIELDS = 0;* Transfers all fields
  ITEMLIST = FALSE; * Always returns with a select list
  IF ERR # '' THEN BAD = TRUE
 END ELSE
*
  BEGIN CASE
   CASE ITEMLIST
    IF CAPTURE.SEL THEN
     WRITE ITEMS ON F.BP, K.ITEMLIST
     DUM = 'QSELECT ':WRKFILE:' "':K.ITEMLIST:'"'
     CALL @ITEMSUB(F.DATA, DUM, CAPTURE, NOITEMS, SV.LIST, INLIST)
     DELETE F.BP, K.ITEMLIST
    END
   CASE ITEMS = "*"
    BEGIN CASE
     CASE MACHINE.TYPE = "MD" AND CAPTURE 
      ITEMS = "SELECT "
      IF ACCOUNT = '' THEN
       ITEMS = ITEMS : FILENAME
      END ELSE
       ITEMS = ITEMS : QFILE.DATA
      END
      CALL @ITEMSUB(F.DATA, ITEMS, CAPTURE.SEL, NOITEMS, SV.LIST, INLIST)
     CASE 1
      SELECT F.DATA TO SV.LIST
    END CASE
   CASE 1
    CALL @ITEMSUB(F.DATA, ITEMS, CAPTURE.SEL, NOITEMS, SV.LIST, INLIST)
    IF NOITEMS = 0 THEN BAD = TRUE;ERR = 1
  END CASE
 END
 SELDONE = TRUE
 IF BAD THEN
  CMND = "SelectBad ":ERR
 END ELSE
  IF NOITEMS AND FIELDDESCS THEN NOITEMS = NOITEMS + 1
  IF CAPTURE THEN
   IF USER.LIST = "" THEN
      CMND = "Capture ": NOITEMS
   END ELSE
      CMND = "Capture 0"
   END
  END ELSE
   GOSUB 200; * Get first block
   GOSUB 40; * Generate Checksum
   NXTBLOCK = CHKSUM:CMND:CR    
   CMND = "SelectOK ":NOITEMS
  END
 END
END 
RETURN
* 
* Capture method of Import to PC
1200 IF NOT(LISTDONE) THEN
* 
 IF INVERTING.CASE AND CASE.IS.INVERTED THEN
  GOSUB 2100                         ;* Invert case for Capture
 END
*
 IF NOFIELDS THEN
  GOSUB 1210; * Column listing of fields
 END ELSE
  GOSUB 1220; * Whole record listing
 END 
*
 IF INVERTING.CASE AND NOT(CASE.IS.INVERTED) THEN
  GOSUB 2100                         ;* iNVERT CASE
 END
 LISTDONE = TRUE
END 
* 
CMND = "<EOL>"
RETURN
*
* Capture across screen listing
1210 IF TXREC # "" THEN     ;* Transfer extra info if necessary
 LOOP
  C = INDEX(TXREC, ITEMSEP, 1)
 WHILE C DO
  DUM = TXREC[1,C-1]
  TXREC = TXREC[C+1, MAXRECLEN]
  N = COUNT(DUM, AM) + (DUM # '')
  FOR J = 1 TO N
   FRMT = DICTITEMS<J+IDSUPP,3>
   DUM1 = DUM<J> : SPACE(FRMT)
   PRINT DUM1[1,FRMT] :
   IF J < N THEN PRINT ' ':
  NEXT J
  PRINT
 REPEAT
END
* 
IF USER.LIST # "" THEN
 USER.LIST = USER.LIST[7,MAXRECLEN]; * Remove 'REPORT' from start
 LOOP
 WHILE USER.LIST # "" AND USER.LIST[1,1] = " " DO
  USER.LIST = USER.LIST[2,MAXRECLEN]
 REPEAT
 IF ACCOUNT # '' THEN
  N = INDEX(USER.LIST:' ', ' ':FILENAME:' ', 1)
  IF N THEN
   USER.LIST = USER.LIST[1,N] : QFILE.DATA : USER.LIST[LEN(FILENAME)+N+1,MAXRECLEN]
  END
 END
 SEL = USER.LIST
END ELSE
 SEL = "LIST "
 IF ACCOUNT = "" THEN SEL = SEL:FILENAME ELSE SEL = SEL:QFILE.DATA
 SEL = SEL : " " : FIELDS
END
*
OPTSATEND = ""
IF INDEX(CAPTURE.SELEND,"(",1) THEN
   C = LEN(SEL)
   LOOP
   WHILE C > 0 AND SEL[C,1] = " " DO
      C = C - 1
   REPEAT
   SEL = SEL[1,C]
   LOOP
   WHILE C > 0 AND SEL[C,1] # " " AND SEL[C,1] # "(" DO
     C = C - 1
   REPEAT
  IF SEL[C,1] = "(" THEN
     OPTSATEND = SEL[C+1,999]
     SEL = SEL[1,C-1]
  END
END
SEL = SEL : " "
IF IDSUPP THEN C = 1 ELSE C = INDEX(CAPTURE.SELEND,' ',1) + 1
SEL = SEL : CAPTURE.SELEND[C,999]
SEL = SEL : OPTSATEND
* 
CALL @EXECSUB(SEL, INLIST, NOITEMS)
* 
RETURN
*
* Display all items on screen to be captured
1220 IF TXREC # "" THEN
 LOOP
  C = INDEX(TXREC, ITEMSEP, 1)
 WHILE C DO
  DUM = TXREC[1,C-1]
  TXREC = TXREC[C+1, MAXRECLEN]
  N = COUNT(DUM, AM) + (DUM # '')
  PRINT ' ':DUM<1>
  FOR J = 2 TO N
   PRINT "-": DUM<J>
  NEXT J
  PRINT "|"
 REPEAT
END           
*
LOOP
 IF ITEMLIST THEN
  KEY = ITEMS<1>
  ITEMS = DELETE(ITEMS, 1,0,0)
  IF KEY = "" THEN EOF = TRUE
 END ELSE
  READNEXT KEY FROM SV.LIST ELSE EOF = TRUE
 END
UNTIL EOF DO
 READ TXREC FROM F.DATA, KEY THEN
  IF IDSUPP THEN
   CH = ' '
  END ELSE
   PRINT " ":KEY
   CH = '-'
  END
*               
  N = DCOUNT(TXREC,AM)
  FOR J = 1 TO N
   DUM = TXREC<J>
   L = LEN(DUM)
   PRINT CH:DUM[1,120]
   CH = '+'
   LOOP
    L = L - 120
   WHILE L > 0 DO
    DUM = DUM[121,MAXRECLEN]
    PRINT CH:DUM[1,120]
   REPEAT
   CH = '-'
  NEXT J
  PRINT "|"
 END
REPEAT
*
RETURN
* 
* Start Export 
1900 CMND = "F001" ;* Set up request for next block
GOSUB 40; * Generate Checksum
NXTBLOCK = CHKSUM:CMND:CR
CHK.BLOCK = "000"
BLOCK = "001"
CMND = "F000" ;* Ask for first block
RETURN
* 
* iNVERT CASE
* 
2100 IF CASE.IS.INVERTED THEN
 DUM = 'PTERM -CASE INVERT'
 CASE.IS.INVERTED = FALSE
END ELSE
 DUM = 'PTERM -CASE NOINVERT'
 CASE.IS.INVERTED = TRUE
END 
* 
CALL @EXECSUB(DUM, '', 0)
INVERTING.CASE = TRUE
* 
RETURN
* 
*
* Initialise transfer program and load machine specific details
5000 CR = CHAR(13)
ITEMSEP = "|"; * Character to separate pick items
CHARSUB1 = "}"; * Shift following byte to 0-31 or 214-255
CHARSUB2 = "{"; * Shift following byte to 123-213
AMCHAR = "~"; * Replace AM with this character
* 
ITEMSEPRPL = "{!"
AMCHARRPL = "{#"
CHARSUB1RPL = '{"'
CHARSUB2RPL = "{ "
*
MINCHAR = ' '
MAXCHAR = CHAR(126)
*
CMND = "OptionsOK"
*
* Parameters set up in header transfer
GOSUB 5200; * Get info from header
* 
EOF = FALSE
WORKING = TRUE
RXREC = ''
SEQKEY = 0; * Counter for rolling number ids
IF KEYGEN<1> # "" THEN SEQKEY = KEYGEN<1>
SV.LIST = ''
INLIST = ''
SELVERBS = "\SELECT\SSELECT\QSELECT\"
*
MAXRECLEN   = R.PARAMS<1>
PRIME.STYLE = R.PARAMS<2>
IF R.PARAMS<3> = '1' THEN SV.LIST = 0
SELVERBS    = SELVERBS : R.PARAMS<4>
PRIME.FILES = R.PARAMS<5>
DICT.SELEND = R.PARAMS<6>
CAPTURE.SELEND = R.PARAMS<7>
FILE.SELEND  = R.PARAMS<11>
PRE.EXEC  = R.PARAMS<12,1>
POST.EXEC = R.PARAMS<12,2>
*
ACCNAME = R.PARAMS<8>
PORTNO = R.PARAMS<9>
TERM.WIDTH = R.PARAMS<10>
OLD.WIDTH = TERM.WIDTH
* 
QFILE.DATA = 'QIBSDATA' : PORTNO
QFILE.MD = 'QIBSMD' : PORTNO
K.ITEMLIST = "ITEMLIST." : PORTNO
*
TXLEN = 0
TXREC = ""       
TXMORE = ""      
TXCODEDLEN = 0   
TXCODED = ''     
BLOCK = '000'    
RXREC = ''
RXID = ''
SELDONE = FALSE
LISTDONE = FALSE
NOITEMS = 0
LEN.RXREC = 0
OVERFLOW = 0
ITEMCNT = 0
REC = ''
TIDYUP = 0
R.RFMT = ''
ERR = ''
USER.LIST = ""
*
GOSUB 5100;* Get Options 
IF ITEMLIST = 0 THEN GOSUB 5300;* Sort out items field
RETURN
*
5100 *
OVERWRITE  = FALSE
APPND = FALSE
RFMT = FALSE
FIELDDESCS = FALSE
IDSUPP = FALSE
EIGHTBITS = FALSE
CAPTURE = FALSE
*
IF INDEX(OPTIONS, "O", 1) THEN OVERWRITE = TRUE
IF INDEX(OPTIONS, "A", 1) THEN APPND = TRUE
IF INDEX(OPTIONS, "C", 1) THEN CAPTURE = TRUE
IF INDEX(OPTIONS, "R", 1) THEN RFMT = TRUE
IF RFMT AND NOFIELDS = 0 THEN RFMT = FALSE
IF INDEX(OPTIONS, "I", 1) THEN IDSUPP = TRUE
IF INDEX(OPTIONS, "7", 1) THEN EIGHTBITS = FALSE
IF INDEX(OPTIONS, "D", 1) AND NOFIELDS THEN FIELDDESCS = TRUE
IF INDEX(OPTIONS, "F", 1) THEN
 REC = ''
 FOR J = 1 + IDSUPP TO NOFIELDS
  DUM = DICTITEMS<J, 4>
  REC<-1> = DUM
 NEXT J
 IF REC # "" THEN
  IF CAPTURE THEN
   TXREC = TXREC : REC : ITEMSEP
  END ELSE
   LOOP
   UNTIL REC = '' DO
    IF EIGHTBITS THEN GOSUB 250 ELSE GOSUB 240; * Add data to TXREC
   REPEAT
   TXCODED = TXCODED : ITEMSEP
   TXCODEDLEN = TXCODEDLEN + 1
  END
 END
END 
* 
IF FIELDDESCS THEN
 REC = ''
 FIRST.FLD = 1 + IDSUPP
 FOR J = FIRST.FLD TO NOFIELDS
  REC<J-FIRST.FLD+1> = DICTITEMS<J,4>
 NEXT J
 IF REC # "" THEN                                                      
  IF CAPTURE THEN
   TXREC = TXREC : REC : ITEMSEP
  END ELSE
   IF EIGHTBITS THEN GOSUB 250 ELSE GOSUB 240; * Add data 
  END
 END
 ITEMCNT = 1
END 
* 
RETURN
* 
* Transfer info from header transfer
5200 *
   BLOCKLEN = BLOCKSIZE
   ACCOUNT      = FILE.INFO<1>
   FILENAME     = FILE.INFO<2>
   DD           = FILE.INFO<3>
   DFN          = FILE.INFO<4>
   DDD          = FILE.INFO<5>
   FILE.TO.OPEN = FILE.INFO<6>
   ITEMS     = ITEM.INFO
   ITEMLIST  = ITEM.LIST
   NOFIELDS   = FIELD.INFO<1>
   FIELDS.LEN = FIELD.INFO<2>
   FIELDS     = FIELD.INFO<3>
   DICTITEMS  = DICT.INFO
   CASE.IS.INVERTED = CASE.INFO<1>
   INVERTING.CASE   = CASE.INFO<2>
   QFILE.DATA = QFILE.INFO<1>
   QFILE.MD   = QFILE.INFO<2>
   MODE       = MODE.INFO
   CHECKKEY   = SERV.INFO
   WRKFILE    = WORK.INFO<1>
   K.ITEMLIST = WORK.INFO<2>
   SPOOL = SUBMODES<1>
   IF SPOOL THEN INFODUE = TRUE
RETURN
*
* Sort out items field
5300 SELSEP = "/;|" 
SELCHAR = ITEMS[1,1]
IF INDEX(SELSEP, SELCHAR,1) THEN
   ITEMS = FIELD(ITEMS,SELCHAR,2):AM:FIELD(ITEMS, SELCHAR,3)
   N = 2
END ELSE
   N = 1
END
*
ERR = ''
FOR J = 1 TO N
  FIRST.WORD = FIELD(ITEMS<J>," ",1)
  IF INDEX(SELVERBS, FIRST.WORD,1) THEN
    IF ACCOUNT # '' THEN
      FPOS = INDEX(ITEMS<J>:' ', ' ':FILENAME:' ', 1)
      IF FPOS THEN 
        ITEMS<J> = ITEMS<J>[1,FPOS] : QFILE.DATA : ITEMS<J>[LEN(FILENAME)+FPOS+1,MAXRECLEN] 
      END                                                             
    END                                                              
  END
  IF FIRST.WORD = "REPORT" AND J < N THEN ERR = 3
NEXT J
*
IF FIRST.WORD = "REPORT" THEN
   USER.LIST = ITEMS<N>
   ITEMS = DELETE(ITEMS, N,0,0)
   IF ITEMS = "" THEN ITEMS = "*"
   IF NOT(CAPTURE) OR NOFIELDS = 0 THEN ERR = 3
END
*
IF ERR # '' THEN CMND = "OptionsBad ":ERR
* 
RETURN
*
END
