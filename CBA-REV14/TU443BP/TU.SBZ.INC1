LOOP
GOSUB 1300
IF TXSTATE AND PKT.TYPE # ZNOPKT THEN
BEGIN CASE
CASE PKT.TYPE = ZCANCEL OR PKT.TYPE = ZBRAINTIME
TXSTATE = ZTX.DONE; SBZ.ERR = SEQ(RXINBUFF[7,1])
BEGIN CASE
CASE SBZ.ERR = 1
STATUS = FTE.EOF
CASE SBZ.ERR = 2
STATUS = FTE.ABORT
CASE SBZ.ERR = 3
STATUS = FTE.READ.ERROR
CASE SBZ.ERR = 4
STATUS = FTE.WRITE.ERROR
CASE SBZ.ERR = 5
STATUS = FTE.PROTOCOL.ERROR
CASE SBZ.ERR = 6
STATUS = FTE.CONFIG.ERROR
CASE SBZ.ERR = 7
STATUS = FTE.START.ERROR
CASE SBZ.ERR = 8
STATUS = FTE.INTERNAL.ERROR
CASE SBZ.ERR = 9
STATUS = FTE.OPEN.ERROR
CASE SBZ.ERR = 10
STATUS = FTE.POSITION.ERROR
CASE 1
STATUS = FTE.UNKNOWN.ERROR
END CASE
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' ->Abort'; GOSUB 6000
TRACE = 'RXINBUFF=':RXINBUFF; GOSUB 6000
TRACE = 'RXBUFF=':RXBUFFER; GOSUB 6000
END
IF PKT.TYPE = ZCANCEL THEN
ZPKT.TYPE = ZPKT.EOF; ZLEN = 8; TXPOS = 0; TXFD = 1
POS = TXPOS; IF HEX.OUTPUT THEN HEX.OUTPUT = 0
GOSUB 3000; ZTXBUF = HEXPOS; RXPOS = 0
GOSUB 1000
TXTIMER = TIME() + ZSTART; TXSTATE = ZTX.EOFACK
END ELSE GOTO 900
CASE PKT.TYPE = ZTXTIME OR PKT.TYPE = ZPKT.NACK
IF TXSTATE = ZTX.XWAIT OR TXSTATE = ZTX.REND THEN
ZPKT.TYPE = ZPKT.IDLE; ZLEN = 0; ZTXBUF = ""
GOSUB 1000
TXTIMER = TIME() + ZIDLE
END ELSE
TXRETRIES = TXRETRIES + 1
IF TXRETRIES > ZRETRIES THEN
TXSTATE = ZTX.DONE; STATUS = XFER.RETRY
GOSUB 1250
END ELSE
TXTIMER = 0
IF RXSTATE = ZRX.INIT THEN
BEGIN CASE
CASE TXSTATE = ZTX.SWAIT; TXSTATE = ZTX.START
CASE TXSTATE = ZTX.INITACK; TXSTATE = ZTX.INIT
CASE TXSTATE = ZTX.DATAACK; TXSTATE = ZTX.XDATA
CASE TXSTATE = ZTX.EOFACK; TXSTATE = ZTX.EOF
CASE TXSTATE = ZTX.ENDACK; TXSTATE = ZTX.END
CASE TXSTATE = ZTX.XDATA
IF TXRETRIES > INT(ZRETRIES/2) THEN
GOSUB 1000; TXTIME = TIME() + INT(TIME.OUT / 2)
END
END CASE
END ELSE
IF ZPKT.TYPE # ZPKT.START THEN
GOSUB 1000; TXTIME = TIME() + INT(TIME.OUT / 2)
END
END
END
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' retry - TXSTATE=':TXSTATE
TRACE = TRACE:' & RXSTATE=':RXSTATE; GOSUB 6000
END
END
CASE PKT.TYPE = ZPKT.START OR PKT.TYPE = ZPKT.FTP OR PKT.TYPE = ZPKT.MNC
IF PKT.TYPE = ZPKT.FTP THEN FTP.MODE = 1
IF PKT.TYPE = ZPKT.MNC THEN MNC.MODE = 1
IF TXSTATE = ZTX.START OR TXSTATE = ZTX.SWAIT THEN
TXTIMER = 0; TXRETRIES = 0; TXSTATE = ZTX.INIT
BRAINDEAD = TIME() + ZBRAINDEAD
END
CASE PKT.TYPE = ZPKT.INIT
IF LEN(RXBUF) > 32 THEN
XFEROPTS = RXBUF[2, 16]
TX.XONXOFF = XFEROPTS[ZOPT.TX.XONXOFF, 1]
TX.CTLCHRS = XFEROPTS[ZOPT.TX.CTLCHRS, 1]
TX.HIGHCTL = XFEROPTS[ZOPT.TX.HIGHCTL, 1]
Z = XFEROPTS[ZOPT.TX.HIGHBIT, 1]
IF Z THEN TX.HIGHBIT = Z
TX.CANASC = XFEROPTS[ZOPT.TX.CANASC, 1]
TX.CANRLE = XFEROPTS[ZOPT.TX.CANRLE, 1]
TX.CANKER = XFEROPTS[ZOPT.TX.CANKER, 1]
TX.STREAM = XFEROPTS[ZOPT.TX.STREAM, 1]
RX.XONXOFF = XFEROPTS[ZOPT.RX.XONXOFF, 1]
RX.CTLCHRS = XFEROPTS[ZOPT.RX.CTLCHRS, 1]
RX.HIGHCTL = XFEROPTS[ZOPT.RX.HIGHCTL, 1]
Z = XFEROPTS[ZOPT.RX.HIGHBIT, 1]
IF Z THEN RX.HIGHBIT = Z
RX.CANASC = XFEROPTS[ZOPT.RX.CANASC, 1]
RX.CANRLE = XFEROPTS[ZOPT.RX.CANRLE, 1]
RX.CANKER = XFEROPTS[ZOPT.RX.CANKER, 1]
RX.STREAM = XFEROPTS[ZOPT.RX.STREAM, 1]
HEXPOS = RXBUF[18, 8]; GOSUB 3100; TXBLKLEN = POS
HEXPOS = RXBUF[26, 8]; GOSUB 3100; RXBLKLEN = POS
IF RXSTATE = ZRX.INIT THEN
RXSTATE = ZRX.DATA; TXTIMER = 0
ZPKT.TYPE = ZPKT.INITACK; RXPOS = 0
POS = RXPOS; GOSUB 3000; ZTXBUF = HEXPOS
END
END ELSE
ZPKT.TYPE = ZPKT.NACK; ZTXBUF = ""
TXTIMER = TIME() + TIME.OUT
END
IF RXSTATE = ZRX.INIT OR RXSTATE = ZRX.DATA THEN
ZLEN = LEN(ZTXBUF)
GOSUB 1000
END ELSE
BRAINDEAD = 0; TXTIMER = 0; TXRETRIES = 0
IF TXFD # 1 THEN
RXSTATE = ZRX.DATA; TXSTATE = ZTX.XWAIT
END ELSE
TXLASTACK = TXPOS; TXSTATE = ZTX.XDATA
END
END
CASE PKT.TYPE = ZPKT.INITACK
IF TXSTATE = ZTX.INIT OR TXSTATE = ZTX.INITACK THEN
BRAINDEAD = 0; TXTIMER = 0; TXRETRIES = 0
IF TXFD # 1 THEN
RXSTATE = ZRX.DATA; TXSTATE = ZTX.XWAIT
END ELSE
HEXPOS = RXBUF[2, 8]; GOSUB 3100; TXPOS = POS
IF HEX.OUTPUT THEN TXPOS = TXPOS * 2
IF TXPOS >= 0 THEN
TXLASTACK = TXPOS; TXSTATE = ZTX.XDATA
END ELSE
STATUS = XFER.OK; GOTO 900
END
END
END
CASE PKT.TYPE = ZPKT.DATA OR PKT.TYPE = ZPKT.RXBAD OR PKT.TYPE = ZPKT.LASTDATA
IF RXSTATE = ZRX.DATA THEN
HEXPOS = RXBUF[2, 8]; GOSUB 3100
IF POS # RXPOS OR POS < 0 OR PKT.TYPE = ZPKT.RXBAD THEN
TEST.BAD = 1
IF TU.TRACE THEN
TRACE = 'bad PKT.TYPE=':PKT.TYPE:' POS=':POS:' RXPOS=':RXPOS
GOSUB 6000
END
IF POS <= RXLASTSYNC THEN
RXRETRIES = 0; RXTIMER = 0
END
RXLASTSYNC = RXPOS
IF NOT(RXTIMER) OR TIME() > RXTIMER THEN
IF RXRETRIES > 4 THEN
IF TXSTATE < ZTX.REND AND NOT(HDXLINK) THEN
HDXLINK = 1; RXRETRIES = 0
END
END
RXRETRIES = RXRETRIES + 1
IF RXRETRIES > ZRETRIES THEN
TXSTATE = ZTX.DONE; STATUS = XFER.RETRY
GOSUB 1250
GOTO 900
END
IF RXRETRIES = 1 THEN RXSYNCID = RXSYNCID + 1
RXBLKLEN = INT(RXBLKLEN / 2); I = RXBLKLEN
BEGIN CASE
CASE I <= 64; I = 64
CASE I <= 128; I = 128
CASE I <= 256; I = 256
CASE 1; I = 512
END CASE
POS = RXPOS; GOSUB 3000; ZTXBUF = HEXPOS
POS = I; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
POS = RXSYNCID; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
ZPKT.TYPE = ZPKT.RPOS; ZLEN = 24
GOSUB 1000
RXTIMER = TIME() + TIME.OUT
END
END ELSE
BRAINDEAD = TIME() + ZBRAINDEAD; TEST.BAD = 0
RXPKTLEN = RXPKTLEN - 8
RXBLKLEN = RXPKTLEN
RXBUFFER = RXBUFFER:RXBUF[10, RXPKTLEN]
RXTIMER = 0; RXRETRIES = 0; RXLASTSYNC = RXPOS
IF HEX.OUTPUT THEN RXPKTLEN = INT(RXPKTLEN / 2)
RXPOS = RXPOS + RXPKTLEN
IF NOT(BINARY) THEN
AMS = COUNT(RXBUF, AM)
RXPOS = RXPOS + AMS
TOT.AM.COUNT = TOT.AM.COUNT + AMS
END
IF RXWINDOW AND PKT.TYPE # ZPKT.LASTDATA THEN
RXLASTACK = RXPOS
GOSUB 1230
CACHE.PTR = CACHE.PTR + 1
CACHE(CACHE.PTR) = RXBUFFER; RXBUFFER = ""
IF CACHE.PTR > 29 THEN
FOR I = 1 TO 30
RXBUFFER = RXBUFFER:CACHE(I); CACHE(I) = ''
IF SPLIT.SIZE THEN
IF LEN(RXBUFFER) > SPLIT.SIZE THEN
SPLIT.CNT = SPLIT.CNT + 1
CACHE.ID = RXITEM:DOT:SPLIT.CNT
WRITE RXBUFFER ON F.RXFILE, CACHE.ID
RXBUFFER = ''
STATUS = FTE.USING.CACHE
RTN.STR<1,-1> = CACHE.ID
END
END
NEXT I
CACHE.PTR = 1
CACHE(CACHE.PTR) = RXBUFFER; RXBUFFER = ""
END
END
IF NOT(RXSTART) THEN RXSTART = TIME()
IF PKT.TYPE = ZPKT.LASTDATA THEN
ZPKT.TYPE = ZPKT.EOF; ZLEN = 8; TXPOS = RXPOS
POS = TXPOS; IF HEX.OUTPUT THEN HEX.OUTPUT = 0
GOSUB 3000; ZTXBUF = HEXPOS
GOSUB 1000
TXTIMER = TIME() + ZSTART; TXSTATE = ZTX.EOFACK
END
END
END
CASE PKT.TYPE = ZPKT.DATAACK
IF TXSTATE = ZTX.XDATA OR TXSTATE = ZTX.DATAACK OR TXSTATE = ZTX.XWAIT OR TXSTATE = ZTX.EOF OR TXSTATE = ZTX.EOFACK THEN
HEXPOS = RXBUF[2, 8]; GOSUB 3100
IF TXWINDOW AND POS > TXLASTACK THEN
TXLASTACK = POS
IF TXSTATE = ZTX.DATAACK AND TXPOS < (TXLASTACK + TXWINDOW) THEN
TXSTATE = ZTX.XDATA; TXRETRIES = 0; TXTIMER = 0
END
END
END
CASE PKT.TYPE = ZPKT.RPOS
IF TXSTATE = ZTX.XDATA OR TXSTATE = ZTX.DATAACK OR TXSTATE = ZTX.XWAIT OR TXSTATE = ZTX.EOF OR TXSTATE = ZTX.EOFACK THEN
HEXPOS = RXBUF[2, 8]; GOSUB 3100; REQPOS = POS
RTXPOS = REQPOS; IF HEX.OUTPUT THEN RTXPOS = RTXPOS * 2
HEXPOS = RXBUF[18, 8]; GOSUB 3100; SYNCID = POS
IF SYNCID # TXSYNCID AND TXPOS # RTXPOS THEN
IF SYNCID # TXSYNCID THEN
TXSYNCID = SYNCID; TXRETRIES = 1
END ELSE TXRETRIES = TXRETRIES + 1
TXTIMER = 0
IF TXPOS < 0 THEN
TXSTATE = ZTX.EOF; TXPOS = -2
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' TXPOS=':TXPOS:' REQPOS=':REQPOS
TRACE = TRACE:' TXSYNCID=':TXSYNCID:' SYNCID=':SYNCID
GOSUB 6000
END
END ELSE
HEXPOS = RXBUF[10, 8]; GOSUB 3100; BLKLEN = POS
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' TXPOS=':TXPOS:' REQPOS=':REQPOS
TRACE = TRACE:' TXSYNCID=':TXSYNCID:' SYNCID=':SYNCID
TRACE = TRACE:' TXBLKLEN=':TXBLKLEN:' BLKLEN=':BLKLEN
GOSUB 6000
END
IF TXBLKLEN > BLKLEN THEN
TXBLKLEN = BLKLEN
END ELSE
TXBLKLEN = INT(TXBLKLEN / 2)
END
BEGIN CASE
CASE TXBLKLEN <= 32; TXBLKLEN = 64
IF NOT(TX.HIGHBIT) THEN TX.HIGHBIT = 1
CASE TXBLKLEN <= 64; TXBLKLEN = 64
CASE TXBLKLEN <= 128; TXBLKLEN = 128
CASE TXBLKLEN <= 256; TXBLKLEN = 256
CASE 1; TXBLKLEN = 512
END CASE
TXGOODBYTES = 0
TXGOODNEEDED = TXGOODNEEDED + 512
IF TXGOODNEEDED > 8192 THEN TXGOODNEEDED = 8192
IF TXSTATE # ZTX.XWAIT THEN TXSTATE = ZTX.XDATA
TXPOS = RTXPOS
END
END ELSE
IF SYNCID # TXSYNCID THEN
TXRETRIES = 1
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' TXPOS=':TXPOS:' SYNCID=':SYNCID
TRACE = TRACE:' TXSYNCID=':TXSYNCID:' TXRETRIES=':TXRETRIES
TRACE = TRACE:' SYNC=':SYNCID:' RPOS=':REQPOS
HEXPOS = RXBUF[10, 8]; GOSUB 3100
TRACE = TRACE:' BLKL=':POS; GOSUB 6000
END
END ELSE
TXPOS = RTXPOS; TXRETRIES = TXRETRIES + 1
IF TU.TRACE THEN
TRACE = 'PKT.TYPE=':PKT.TYPE:' TXPOS=':TXPOS:' SYNCID=':SYNCID
TRACE = TRACE:' TXSYNCID=':TXSYNCID:' TXRETRIES=':TXRETRIES
TRACE = TRACE:' SYNC=':SYNCID:' RPOS=':REQPOS
HEXPOS = RXBUF[10, 8]; GOSUB 3100
TRACE = TRACE:' BLKL=':POS; GOSUB 6000
END
END
END
IF TXRETRIES > ZRETRIES THEN
TXSTATE = ZTX.DONE; STATE = XFER.ABORT
GOSUB 1250
END
END
CASE PKT.TYPE = ZPKT.EOF
IF RXSTATE = ZRX.DATA THEN
HEXPOS = RXBUF[2, 8]; GOSUB 3100
IF POS < 0 THEN
RXSTATE = ZRX.INIT; BRAINDEAD = TIME() + ZBRAINDEAD
END ELSE
IF POS < RXPOS THEN
IF POS + TOT.AM.COUNT = RXPOS THEN POS = RXPOS
END
IF POS # RXPOS THEN
IF POS <= RXLASTSYNC THEN
RXRETRIES = 0; RXTIMER = 0
END
RXLASTSYNC = RXPOS
IF NOT(RXTIMER) OR TIME() > RXTIMER THEN
RXRETRIES = RXRETRIES + 1
IF RXRETRIES > ZRETRIES THEN
TXSTATE = ZTX.DONE; STATUS = XFER.ABORT
GOSUB 1250
END ELSE
IF RXRETRIES = 1 THEN RXSYNCID = RXSYNCID + 1
RXBLKLEN = INT(RXBLKLEN / 2); I = RXBLKLEN
BEGIN CASE
CASE I <= 64; I = 64
CASE I <= 128; I = 128
CASE I <= 256; I = 256
CASE 1; I = 512
END CASE
POS = RXPOS; GOSUB 3000; ZTXBUF = HEXPOS
POS = I; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
POS = RXSYNCID; GOSUB 3000; ZTXBUF = ZTXBUF:HEXPOS
ZPKT.TYPE = ZPKT.RPOS; ZLEN = 24
GOSUB 1000
RXTIMER = TIME() + TIME.OUT
END
END
END ELSE
RXSTATE = ZRX.INIT; BRAINDEAD = TIME() + ZBRAINDEAD
END
END
END
IF RXSTATE = ZRX.INIT THEN
IF TXSTATE = ZTX.SWAIT THEN TXSTATE = ZTX.REND
ZPKT.TYPE = ZPKT.EOFACK; ZLEN = 0; ZTXBUF = ""
GOSUB 1000
IF TXFD # 1 THEN
GOSUB 5000
TXSTATE = ZTX.DONE; STATUS = XFER.OK
END
END
CASE PKT.TYPE = ZPKT.EOFACK
IF TXSTATE = ZTX.EOF OR TXSTATE = ZTX.EOFACK THEN
IF TXFD # 1 THEN GOSUB 5000
BRAINDEAD = TIME() + ZBRAINDEAD
TXSTATE = ZTX.DONE
END
CASE PKT.TYPE = ZPKT.EOFTP
FTP.ERR = RXBUF[2,1]
IF SPLIT.SIZE THEN NULL ELSE
IF TXFD # 1 THEN
IF RXBUF[2, 1] = '0' THEN GOSUB 5000
END
IF RUNNING.NT THEN
EXECUTE "!DEL ":PFNAME CAPTURING CAPT; !*UDT*!
!@!EXECUTE OS.EXEC:' ':RM.CMD:' ':PFNAME CAPTURING CAPT ; !*UV,UP*!
END ELSE
EXECUTE '!rm ':PFNAME CAPTURING CAPT ;!*UDT*!
!@!EXECUTE "sh -c 'rm ":PFNAME:"'" CAPTURING CAPT ; !*UV,UP*!
END
!@!%UNLINK(PFNAME); !*AP*!
IF TU.TRACE THEN TRACE = "Removing ":PFNAME; GOSUB 6000
END
BRAINDEAD = TIME() + ZBRAINDEAD; TXSTATE = ZTX.DONE
BEGIN CASE
CASE FTP.ERR = 0 AND SPLIT.SIZE
STATUS = FTE.USING.FTP
RTN.STR = PFNAME
CASE FTP.ERR = 0
STATUS = XFER.OK
CASE FTP.ERR = 1
STATUS = FTE.FTP.LOADWINSOCK
CASE FTP.ERR = 2
STATUS = FTE.FTP.LOGINFAILED
CASE FTP.ERR = 3
STATUS = FTE.FTP.CONNECTFAILED
CASE FTP.ERR = 4
STATUS = FTE.FTP.OPFAILED
CASE FTP.ERR = 5
STATUS = FTE.FTP.ABORT
CASE FTP.ERR = 6
STATUS = FTE.FTP.WINSOCK
CASE FTP.ERR = 7
STATUS = FTE.FTP.FILEACCESS
CASE 1
STATUS = FTE.UNKNOWN.ERROR
END CASE
CASE PKT.TYPE = ZPKT.EOMNC
FT.ERR = RXBUF[2,1]
PFNAME = FTPDIR:"SBZ.UL.":PORTNO
IF SPLIT.SIZE THEN NULL ELSE
IF TXFD # 1 THEN
IF RXBUF[2, 1] = '0' THEN GOSUB 5000
END
IF RUNNING.NT THEN
EXECUTE "!DEL ":PFNAME CAPTURING CAPT; !*UDT*!
!@!EXECUTE OS.EXEC:' ':RM.CMD:' ':PFNAME CAPTURING CAPT ; !*UV,UP*!
END ELSE
EXECUTE '!rm ':PFNAME CAPTURING CAPT ;!*UDT*!
!@!EXECUTE "sh -c 'rm ":PFNAME:"'" CAPTURING CAPT ; !*UV,UP*!
END
!@!%UNLINK(PFNAME); !*AP*!
IF TU.TRACE THEN TRACE = "Removing ":PFNAME; GOSUB 6000
END
BRAINDEAD = TIME() + ZBRAINDEAD; TXSTATE = ZTX.DONE
BEGIN CASE
CASE FT.ERR = 0 AND SPLIT.SIZE
STATUS = FTE.USING.FTP
RTN.STR = PFNAME
CASE FT.ERR = 0
STATUS = XFER.OK
CASE FT.ERR = 7
STATUS = FTE.FTP.FILEACCESS
CASE 1
STATUS = FTE.UNKNOWN.ERROR
END CASE
CASE PKT.TYPE = ZPKT.IDLE
IF TXSTATE = ZTX.XWAIT THEN
HDXLINK = 0; TXTIMER = 0
TXRETRIES = 0; TXSTATE = ZTX.XDATA
END ELSE
IF TXSTATE > ZTX.INITACK AND TXSTATE < ZTX.REND THEN
BRAINDEAD = TIME() + ZBRAINDEAD
END
END
CASE PKT.TYPE = ZPKT.END
IF TXSTATE = ZTX.END OR TXSTATE = ZTX.ENDACK THEN
ZPKT.TYPE = ZPKT.END; ZLEN = 0; ZTXBUF = ""
GOSUB 1000
END
IF TXFD # 1 THEN GOSUB 5000
TXSTATE = ZTX.DONE; STATUS = XFER.OK
END CASE
BEGIN CASE
CASE TXSTATE = ZTX.START OR TXSTATE = ZTX.SWAIT
IF RXSTATE = ZRX.WAIT THEN TXTIMER = 0; TXSTATE = ZTX.INIT
CASE TXSTATE = ZTX.XDATA
IF RXSTATE AND HDXLINK THEN
TXTIMER = TIME() + ZIDLE; TXSTATE = ZTX.XWAIT
END
CASE TXSTATE = ZTX.XWAIT
IF NOT(RXSTATE) THEN
TXTIMER = 0; TXRETRIES = 0; TXSTATE = ZTX.XDATA
END
CASE TXSTATE = ZTX.REND
IF NOT(RXSTATE) THEN
TXTIMER = 0; TXRETRIES = 0; TXSTATE = ZTX.END
END
END CASE
IF RX.STREAM OR TX.STREAM THEN PKT.TYPE = ZNOPKT
END
WHILE TXSTATE AND PKT.TYPE # ZNOPKT DO
REPEAT
