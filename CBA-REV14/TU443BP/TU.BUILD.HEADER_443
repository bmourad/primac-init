SUBROUTINE TU.BUILD.HEADER_443(HOSTFILENAME, FIELDLIST, HEADER, APPLICATION, STATUS)
 INCLUDE TU443BP USER.INCLUDE.H
*
** SBClient Host 3GL API
** Copyright (C) Ardent Software Inc. 1998
** Copyright (C) UniData, Inc. 1996, 1997
** Copyright (C) System Builder Corporation. 1995
**
**      This software is the proprietary property and contains
**      trade secrets of Ardent Software, Inc. Any unauthorized use,
**      disclosure or duplication is strictly prohibited.
**      All rights reserved.
*
***************************************************************************
*-* TU.BUILD.HEADER(Pickfilename, Fieldlist, Header, Application,
*-* Status)
*-*
*-* This is an internal function that converts a fieldlist into
*-* an internal format for the API
*-*
*-* [P] Pickfilename The name of the pick file
*-*
*-* [P] Fieldlist List of dictionary definitions of fields.
*-*
*-* [R] Header        This the internal representation of the dictionary definitions
*-*
*-* [P] Application   This is the name of the application being used under
*-* WINDOWS, this is used to call the correct OCONV converter.
*-*
*-* [R] Status This is an indication of the success or failure of the
*-* subroutine. A successful call will return with zero
*-* Status and failure will return with a non-zero value.
***************************************************************************
 INCLUDE TU443BP SPECIAL.H
*
 INCLUDE TU443BP TU.API.H
*
 INCLUDE TU443BP HEADER.H
*
 INCLUDE TU443BP TU.ERRORCODES.H
*
*
EQU EXCLUDE.WORDS TO ',BREAK-ON,BREAK.ON,BREAK.SUP,TOTAL,AVERAGE,PERCENTAGE,'; *JM 10/2/95: INCLUDE BREAK.SUP
*
IF TU.TRACE THEN
OPEN '','TUSTATE' TO TUSTATE THEN
WRITEV ('BUILD.HEADER':VM:HOSTFILENAME:VM:FIELDLIST:VM:APPLICATION) ON TUSTATE,('TRACE.':PORTNO),-1
END
END
*
HOSTFILENAME = HOSTFILENAME<1>; STATUS = 0
OPEN 'DICT',HOSTFILENAME TO DICTFILE ELSE
OPEN '','TUSTATE' TO TUSTATE ELSE STATUS = FTE.TUSTATE.OPEN.ERROR; RETURN
WRITE (FTE.FILE.OPEN.ERROR:AM:'DICT ':HOSTFILENAME) ON TUSTATE,'ERROR.':PORTNO
STATUS = FTE.FILE.OPEN.ERROR
RETURN
END
HEADER = ''
BORT = ''
DICTCOUNT = 0
FIELDLIST = TRIM(FIELDLIST)
FIELDCOUNT = COUNT(FIELDLIST, ' ') + (FIELDLIST # '')
FOR I = 1 TO FIELDCOUNT
DICTNAME = FIELD(FIELDLIST, ' ', I)
BEGIN CASE
CASE INDEX(EXCLUDE.WORDS,',':DICTNAME:',',1); *JM 10/2/95: INCLUDE BREAK.SUP
BORT = DICTNAME[1, 1]
CASE DICTNAME[1,1] = '"'; *JM 10/2/95: Exclude BREAK/TOTAL TEXT
LOOP
UNTIL DICTNAME[LEN(DICTNAME),1] = '"' OR I>FIELDCOUNT DO
I = I + 1
DICTNAME = FIELD(FIELDLIST, ' ', I)
REPEAT
CASE 1
IF DICTNAME[LEN(DICTNAME) - 4, 5] # '-SUPP' AND DICTNAME[LEN(DICTNAME) - 3, 4] # '.SUP' THEN
DICTCOUNT = DICTCOUNT + 1
HEADER<HED.DICTNAME,DICTCOUNT> = DICTNAME; * name of dictionary definition
HEADER<HED.BORT,DICTCOUNT> = BORT; * BREAK or TOTAL modifier
READ DICTDEF FROM DICTFILE,DICTNAME ELSE
OPEN '','TUSTATE' TO TUSTATE ELSE STATUS = 999; RETURN
WRITE (202:AM:'TU.BUILD.HEADER':AM:'DICT ':HOSTFILENAME:' ':DICTNAME) ON TUSTATE,'ERROR.':PORTNO
CRT 'Unable to read ':DICTNAME:' from ':HOSTFILENAME
STATUS = FTE.INVALID.DICT.ITEM
RETURN
END
DCT = ICONV(DICTDEF[1,1] ,'MCU')
BEGIN CASE
CASE INDEX('ASX', DCT, 1)
TEXT = DICTDEF<3>
GOSUB 100; * remove VM, SPACE and DOTS
BEGIN CASE
CASE DICTDEF<2> = ''
HEADER<HED.POSITION,DICTCOUNT> = (-1)
CASE NOT(NUM(DICTDEF<2>))
HEADER<HED.POSITION,DICTCOUNT> = (-1)
CASE DICTDEF<8> # ''
HEADER<HED.POSITION,DICTCOUNT> = (-1)
CASE 1
HEADER<HED.POSITION,DICTCOUNT> = DICTDEF<2>
END CASE
HEADER<HED.JUST,DICTCOUNT> = DICTDEF<9>; * justification
HEADER<HED.LENGTH,DICTCOUNT> = DICTDEF<10>; * length
HEADER<HED.OCONV,DICTCOUNT> = DICTDEF<7>; * output CONVersion
CASE INDEX('DIV', DCT, 1)
TEXT = DICTDEF<4>
GOSUB 100
BEGIN CASE
CASE DICTDEF[1,1] = 'I'
HEADER<HED.POSITION,DICTCOUNT> = (-1)
CASE DICTDEF<2> = ''
HEADER<HED.POSITION,DICTCOUNT> = (-1)
CASE NOT(NUM(DICTDEF<2>))
HEADER<HED.POSITION,DICTCOUNT> = (-1)
CASE 1
HEADER<HED.POSITION,DICTCOUNT> = DICTDEF<2>
END CASE
HEADER<HED.JUST,DICTCOUNT> = DICTDEF<5>[LEN(DICTDEF<5>), 1]
HEADER<HED.LENGTH,DICTCOUNT> = DICTDEF<5>[1, LEN(DICTDEF<5>) - 1]
HEADER<HED.OCONV,DICTCOUNT> = DICTDEF<3>
CASE 1
OPEN '','TUSTATE' TO TUSTATE ELSE STATUS = 999; RETURN
WRITE (24:AM:DICTNAME) ON TUSTATE,'ERROR.':PORTNO
STATUS = 24
RETURN
END CASE
END
*           IF LEN(HEADER<HED.HEADING,DICTCOUNT>) > HEADER<HED.LENGTH,DICTCOUNT> THEN
*             HEADER<HED.LENGTH,DICTCOUNT> = LEN(HEADER<HED.HEADING,DICTCOUNT>) + 1
*           END
CONV = HEADER<HED.OCONV,DICTCOUNT>
MASK = ''
IF CONV # '' THEN
BEGIN CASE
CASE APPLICATION = 'EXCEL'
CALL TU.EXCEL.MASK_443(CONV, MASK)
CASE APPLICATION = '123W'
CALL TU.123.MASK_443(CONV, MASK)
CASE 1
CONV = ''
END CASE
HEADER<HED.MASK,DICTCOUNT> = MASK; * excel MASK
HEADER<HED.CONV,DICTCOUNT> = CONV; * output CONVersion
END
BORT = ''
END CASE
NEXT I
HEADER<HED.HOSTFILENAME> = HOSTFILENAME
HEADER<HED.FIELDLIST> = FIELDLIST
RETURN
*
100 *
L = LEN(TEXT)
LOOP
P = INDEX(TEXT, VM, 1)
WHILE (P > 0) DO
TEXT = TEXT[1, P - 1]:UNDER:TEXT[P + 1, L]
REPEAT
LOOP
P = INDEX(TEXT, SPC, 1)
WHILE (P > 0) DO
TEXT = TEXT[1, P - 1]:UNDER:TEXT[P + 1, L]
REPEAT
LOOP
P = INDEX(TEXT, DOT, 1)
WHILE (P > 0) DO
TEXT = TEXT[1, P - 1]:UNDER:TEXT[P + 1, L]
REPEAT
HEADER<HED.HEADING,DICTCOUNT> = TEXT; * HEADER
RETURN
END
