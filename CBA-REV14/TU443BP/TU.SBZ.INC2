1300 * Recieve Packet
RXBUF = ""; PKT.TYPE = ZNOPKT; RXRLE = 0; RXPKTFORMAT = 0
IF RX.STREAM OR TX.STREAM THEN
INKEY.FLAG = 1
!@!GET RXINBUFF FROM PORTNO UNTIL CR; !*GA*!
END ELSE
 INCLUDE TU443BP INKEY.MORE ; !*-GA*!
!@!INKEY.FLAG = 1; !*GA*!
!@!GET RXINBUFF FROM PORTNO UNTIL CR WAITING 1 ELSE INKEY.FLAG = 0; !*GA*!
END
IF INKEY.FLAG THEN
P = 0; RXDLE = 0
INPUT RXINBUFF:; !*-GA*!
IF TU.TRACE THEN TRACE = 'I<-':OCONV(RXINBUFF, 'MCP'); GOSUB 6000
LOOP
RXLEN = LEN(RXINBUFF); IF RXLEN THEN PKT.TYPE = ZPKT.RXBAD
SUBP = 0
LOOP
SUBP = SUBP + 1
CH = RXINBUFF[SUBP, 1]; BYTE = SEQ(CH)
WHILE SUBP <= RXLEN AND P <= ZMAXPKTLEN DO
IF RXDLE OR CH = ZDLE THEN
BEGIN CASE
CASE CH = ZDLE; RXDLE = RXDLE + 1
IF RXDLE > 5 THEN PKT.TYPE = ZCANCEL; RETURN
CASE BYTE = ZBYTE.PKTEND
CRCRESULT = 0; HEXOUT = 0
IF HEX.OUTPUT AND (RXBUF[1, 1] = ZPKT.DATA OR RXBUF[1, 1] = ZPKT.LASTDATA) THEN HEXOUT = 1
BEGIN CASE
CASE RXPKTFORMAT = ZFMT.BINPKT OR RXPKTFORMAT = ZFMT.BIN255
RXPKTLEN = LEN(RXBUF); NEWINP = ''; RXRLE = 0
FOR P = 1 TO RXPKTLEN
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
IF RXPKTFORMAT = ZFMT.BIN255 THEN
IF CH = "\" THEN
IF RXBUF[P, 3] = BYTE255 THEN
P = P + 3; BYTE = 255
END
END
END
BEGIN CASE
CASE CH = ZRLE.CHAR AND RX.CANRLE AND RXRLE < 2
IF RXRLE THEN
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; RXRLE = 0
CRCRESULT = CRCRESULT + BYTE
END ELSE RXRLE = 1
CASE RXRLE
IF RXRLE = 1 THEN
RXRLE = SEQ(CH) - 30
IF RXRLE < 3 THEN RXRLE = 0
END ELSE
IF CH = ZRLE.CHAR THEN P = P + 1
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:STR(CH, RXRLE)
CRCRESULT = CRCRESULT + (BYTE * RXRLE)
RXRLE = 0
END
CASE HEXOUT AND P > 9
CRCRESULT = CRCRESULT + BYTE
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
NEWINP = NEWINP:CH
CASE 1; NEWINP = NEWINP:CH
CRCRESULT = CRCRESULT + BYTE
END CASE
NEXT P
RXBUF = NEWINP; NEWINP = ''; RXRLE = 0
RXPKTLEN = LEN(RXBUF); CH = RXBUF[1, 1]
CASE RXPKTFORMAT = ZFMT.HEXPKT
RXPKTLEN = LEN(RXBUF); NEWINP = ''; RXRLE = 0
FOR P = 1 TO RXPKTLEN
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
BEGIN CASE
CASE CH = ZRLE.CHAR AND RX.CANRLE AND RXRLE < 2
IF RXRLE THEN
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; RXRLE = 0
CRCRESULT = CRCRESULT + BYTE
END ELSE RXRLE = 1
CASE RXRLE
IF RXRLE = 1 THEN
RXRLE = SEQ(CH) - 30
IF RXRLE < 3 THEN RXRLE = 0
END ELSE
IF CH = ZRLE.CHAR THEN P = P + 1
IF CH = '\' THEN
P = P + 1; CH = RXBUF[P, 1]
IF CH # '\' THEN
P = P + 1; CH = OCONV(CH:RXBUF[P, 1], 'MCU')
BYTE = ICONV(CH, MX.CONV)
IF BYTE # 255 THEN
CH = CHAR(BYTE)
END ELSE
IF FF.ALLOW THEN CH = CHAR(BYTE) ELSE CH = "~"
END
END
END
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:STR(CH, RXRLE)
CRCRESULT = CRCRESULT + (BYTE * RXRLE)
RXRLE = 0
END
CASE 1
IF CH = '\' THEN
P = P + 1; CH = RXBUF[P, 1]
IF CH # '\' THEN
P = P + 1; CH = OCONV(CH:RXBUF[P, 1], 'MCU')
BYTE = ICONV(CH, MX.CONV)
IF BYTE # 255 THEN
CH = CHAR(BYTE)
END ELSE
IF FF.ALLOW THEN CH = CHAR(BYTE) ELSE CH = "~"
END
END
END
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; CRCRESULT = MOD(CRCRESULT + BYTE, 256)
END CASE
NEXT P
RXBUF = NEWINP; NEWINP = ''; RXRLE = 0
RXPKTLEN = LEN(RXBUF); CH = RXBUF[1, 1]
CASE RXPKTFORMAT = ZFMT.ASCPKT
RXPKTLEN = LEN(RXBUF); NEWINP = ''; RXRLE = 0
FOR P = 1 TO RXPKTLEN
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
BEGIN CASE
CASE CH = ZRLE.CHAR AND RX.CANRLE AND RXRLE < 2
IF RXRLE THEN
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; RXRLE = 0
CRCRESULT = CRCRESULT + BYTE
END ELSE RXRLE = 1
CASE RXRLE
IF RXRLE = 1 THEN
RXRLE = SEQ(CH) - 30
IF RXRLE < 3 THEN RXRLE = 0
END ELSE
IF CH = ZRLE.CHAR THEN P = P + 1
BEGIN CASE
CASE CH = '\'; P = P + 1; CH = RXBUF[P, 1]
IF CH # '\' THEN BYTE = SEQ(CH) + 128; CH = CHAR(BYTE)
CASE CH = '/'; P = P + 1; CH = RXBUF[P, 1]
IF CH # '/' THEN BYTE = SEQ(CH) + 128; CH = CHAR(BYTE)
END CASE
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:STR(CH, RXRLE)
CRCRESULT = CRCRESULT + (BYTE * RXRLE)
RXRLE = 0
END
CASE 1
BEGIN CASE
CASE CH = '\'; P = P + 1; CH = RXBUF[P, 1]
IF CH # '\' THEN BYTE = SEQ(CH) + 128; CH = CHAR(BYTE)
CASE CH = '/'; P = P + 1; C = RXBUF[P, 1]
IF CH # '/' THEN BYTE = SEQ(CH) + 128; CH = CHAR(BYTE)
END CASE
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; CRCRESULT = CRCRESULT + BYTE
END CASE
NEXT P
RXBUF = NEWINP; NEWINP = ''; RXRLE = 0
RXPKTLEN = LEN(RXBUF); CH = RXBUF[1, 1]
CASE RXPKTFORMAT = ZFMT.KERMIT
RXPKTLEN = LEN(RXBUF); NEWINP = ''; RXRLE = 0
FOR P = 1 TO RXPKTLEN
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
BEGIN CASE
CASE CH = ZRLE.CHAR AND RX.CANRLE AND RXRLE < 2
IF RXRLE THEN
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END
NEWINP = NEWINP:CH; RXRLE = 0
CRCRESULT = CRCRESULT + BYTE
END ELSE RXRLE = 1
CASE RXRLE
IF RXRLE = 1 THEN
RXRLE = SEQ(CH) - 30
IF RXRLE < 3 THEN RXRLE = 0
END ELSE
IF CH = ZRLE.CHAR THEN P = P + 1
IF BYTE > 121 AND BYTE < 126 THEN
KOC = KS(126 - BYTE, 1); P = P + 1
CH = RXBUF[P, 1]; BYTE = SEQ(CH)
END
BYTE = BYTE + KOC
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END ELSE CH = CHAR(BYTE)
NEWINP = NEWINP:STR(CH, RXRLE)
CRCRESULT = CRCRESULT + (BYTE * RXRLE)
RXRLE = 0
END
CASE BYTE > 121; KOC = KS(126 - BYTE, 1)
CASE 1
BYTE = BYTE + KOC
IF HEXOUT AND P > 9 THEN
CH = OCONV(BYTE, MX.CONV)
IF LEN(CH) = 1 THEN CH = '0':CH
END ELSE CH = CHAR(BYTE)
NEWINP = NEWINP:CH; CRCRESULT = CRCRESULT + BYTE
END CASE
NEXT P
RXBUF = NEWINP; NEWINP = ''; RXRLE = 0
RXPKTLEN = LEN(RXBUF); CH = RXBUF[1, 1]
CASE 1; CH = ZNOPKT; RXPKTLEN = 0
END CASE
IF CH # ZNOPKT THEN
IF RXPKTLEN < 1 THEN CH = ZNOPKT; GOTO 1390
CRC = RXINBUFF[SUBP+1, 2]; CRC = OCONV(CRC, 'MCU')
CRC = ICONV(CRC, MX.CONV) + 0
GOSUB 2000
N = CRCRESULT + 0
RXPKTLEN = RXPKTLEN - 1
IF N = CRC THEN
PKT.TYPE = RXBUF[1, 1]; RETURN
END ELSE
IF TU.TRACE THEN
TRACE = 'Bad CRC: ':N:' # ':CRC:' ZLEN=':ZLEN
GOSUB 6000
END
END
END
PKT.TYPE = ZPKT.RXBAD; RETURN
CASE BYTE >= ZBYTE.BINPKT AND BYTE <= ZBYTE.KERMIT
RXPKTFORMAT = CH; RXDLE = 0; P = 1; RXBUF = ""; KO = 1; KOC = 0
IF TEST.BAD THEN
IF RXINBUFF[SUBP+1, 1] = ZPKT.DATA THEN
HEXPOS = RXINBUFF[SUBP+2, 8]; GOSUB 3100
IF POS # RXPOS THEN
RXBUF = RXINBUFF[SUBP+1, 9]
IF TU.TRACE THEN TRACE = 'I<-ZPKT.BAD'; GOSUB 6000
PKT.TYPE = ZPKT.RXBAD; RETURN
END
END
END
CASE BYTE < 32 OR BYTE = 127; GOTO 1390
CASE BYTE = 191
IF HEX.OUTPUT OR NOT(FF.ALLOW) THEN
RXPKTFORMAT = ZFMT.BIN255
RXBUF = RXBUF:BYTE255
END ELSE
RXBUF = RXBUF:CHAR(255)
END
P = P + 1; RXDLE = 0
CASE 1
IF BYTE > 63 AND BYTE < 188 THEN
RXBUF = RXBUF:CHAR(BYTE - 64)
END ELSE
RXBUF = RXBUF:CHAR(BYTE + 64)
END
P = P + 1; RXDLE = 0
END CASE
END ELSE
IF BYTE < 32 OR BYTE = 127 THEN GOTO 1390
RXBUF = RXBUF:CH; P = P + 1
END
1390 *
REPEAT
IF P <= ZMAXPKTLEN THEN
IF TX.STREAM OR RX.STREAM THEN
INKEY.FLAG = 1
!@!GET RXINBUFF FROM PORTNO UNTIL CR; !*GA*!
END ELSE
 INCLUDE TU443BP INKEY.MORE ;!*-GA*!
!@!INKEY.FLAG = 1; !*GA*!
!@!GET RXINBUFF FROM PORTNO UNTIL CR WAITING 1 ELSE INKEY.FLAG = 0; !*GA*!
END
IF INKEY.FLAG THEN
INPUT RXINBUFF: ;!*-GA*!
IF TU.TRACE THEN TRACE = 'i<-':OCONV(RXINBUFF, 'MCP'); GOSUB 6000
END ELSE P = 0; RXINBUFF = ''
END ELSE P = 0; RXINBUFF = ''
WHILE P OR RXINBUFF # '' DO
REPEAT
END
T = TIME()
IF BRAINDEAD AND T > BRAINDEAD THEN
PKT.TYPE = ZBRAINTIME
END
IF TXTIMER AND T > TXTIMER THEN
PKT.TYPE = ZTXTIME
END
RETURN
2000 * Test CRC wrt ZLEN
IF NOT(NON.RESILIENT) THEN CRCRESULT = ZLEN
2100 * build HEX CRC bytes
CRCRESULT = MOD(CRCRESULT, 256)
HEXCRC = OCONV(CRCRESULT, MX.CONV); HEXCRC = OCONV(HEXCRC, 'MCL')
IF LEN(HEXCRC) < 2 THEN HEXCRC = STR('0', 2-LEN(HEXCRC)):HEXCRC
RETURN
3000 * Convert decimal signed POS into Hex HEXPOS
IF POS >= 0 THEN
HEXPOS = OCONV(POS, MX.CONV); HEXPOS = OCONV(HEXPOS, 'MCL')
IF LEN(HEXPOS) < 8 THEN HEXPOS = STR('0', 8-LEN(HEXPOS)):HEXPOS
END ELSE
HEXPOS = "FFFFFFF"; APOS = 16 + POS; XPOS = OCONV(APOS, MX.CONV)
IF LEN(XPOS) > 1 THEN XPOS = XPOS[LEN(XPOS), 1]
HEXPOS = HEXPOS:XPOS; HEXPOS = OCONV(HEXPOS, 'MCL')
END
RETURN
3100 * Convert HEXPOS into decimal signed POS
IF HEXPOS = "" THEN POS = 0; RETURN
HEXPOS = OCONV(HEXPOS, 'MCU')
POS = ICONV(HEXPOS, MX.CONV)
IF POS > 4294967279 THEN POS = POS - 4294967296
RETURN
5000 * Update output
IF FTP.MODE OR MNC.MODE THEN
RXBUFFER = ''
IF MNC.MODE THEN PFNAME = FTPDIR:"SBZ.UL.":PORTNO
OK = 1 ; BYTE.PTR = 0; NOCONVERT ON ;!*UDT*!
OSOPEN PFNAME TO F.TMP ELSE STATUS = FTE.HOSTFILE.OPEN.ERROR ; RETURN ;!*UDT*!
LOOP WHILE OK DO ;!*UDT*!
OSBREAD DATA.IN FROM F.TMP AT BYTE.PTR LENGTH BLK.SIZE ON ERROR DATA.IN = "" ;!*UDT*!
BYTE.PTR = BYTE.PTR + BLK.SIZE ;!*UDT*!
IF DATA.IN = "" THEN OK = 0 ;!*UDT*!
RXBUFFER = RXBUFFER:DATA.IN ;!*UDT*!
REPEAT ;!*UDT*!
NOCONVERT OFF ; !*UDT*!
!@!OK = 1 ; !*UV,UP*!
!@!OPENSEQ PFNAME TO F.TMP THEN ; !*UV,UP*!
!@!LOOP WHILE OK DO ; !*UV,UP*!
!@!READBLK DATA.IN FROM F.TMP,BLK.SIZE ELSE DATA.IN = '' ; !*UV,UP*!
!@!IF DATA.IN = "" THEN OK = 0 ; !*UV,UP*!
!@!RXBUFFER = RXBUFFER:DATA.IN ; !*UV,UP*!
!@!REPEAT ; !*UV,UP*!
!@!CLOSESEQ F.TMP ; !*UV,UP*!
!@!END ; !*UV,UP*!
!@!L = 10000; POINTER = 1; !*AP*!
!@!DIM MATRIX(100); MAT MATRIX = ''; !*AP*!
!@!F.TMP = %OPEN(PFNAME, 2); !*AP*!
!@!IF F.TMP < 0 THEN RETURN; !*AP*!
!@!CHAR BUFFER[L]; !*AP*!
!@!LOOP; !*AP*!
!@!N = %READ(F.TMP, BUFFER, L); !*AP*!
!@!IF N THEN; !*AP*!
!@!IF N = L THEN; !*AP*!
!@!MATRIX(POINTER) = BUFFER; !*AP*!
!@!END ELSE; !*AP*!
!@!MATRIX(POINTER) = BUFFER[1, N]; !*AP*!
!@!END; !*AP*!
!@!POINTER = POINTER + 1; !*AP*!
!@!IF POINTER > 100 THEN; !*AP*!
!@!MATBUILD RXBUFFER FROM MATRIX USING ""; !*AP*!
!@!MAT MATRIX = ""; !*AP*!
!@!MATRIX(1) = RXBUFFER; POINTER = 2; RXBUFFER = ''; !*AP*!
!@!END; !*AP*!
!@!END; !*AP*!
!@!WHILE N = L DO; !*AP*!
!@!REPEAT; !*AP*!
!@!MATBUILD RXBUFFER FROM MATRIX USING ""; !*AP*!
!@!MAT MATRIX = ""; !*AP*!
!@!%CLOSE(F.TMP); !*AP*!
END
IF CACHE.PTR THEN
IF RXBUFFER > "" THEN
CACHE.PTR = CACHE.PTR + 1
CACHE(CACHE.PTR) = RXBUFFER; RXBUFFER = ""
END
FOR I = 1 TO CACHE.PTR
RXBUFFER = RXBUFFER:CACHE(I); CACHE(I) = ''
IF SPLIT.SIZE THEN
IF LEN(RXBUFFER) > SPLIT.SIZE THEN
SPLIT.CNT = SPLIT.CNT + 1
CACHE.ID = RXITEM:DOT:SPLIT.CNT
WRITE RXBUFFER ON F.RXFILE, CACHE.ID
RXBUFFER = ''
STATUS = FTE.USING.CACHE
RTN.STR<1,-1> = CACHE.ID
END
END
NEXT I
END
IF SPOOLER.OUTPUT THEN
BUFLEN = LEN(RXBUFFER); L = 80
IF BUFLEN THEN
PRINTER ON
FOR I = 1 TO BUFLEN STEP L
PRINT RXBUFFER[I, L]:
NEXT I
PRINTER OFF; RXBUFFER = ""
END
RETURN
END
IF RXITEM = "" THEN
IF TU.TRACE THEN TRACE = "In memory transfer."; GOSUB 6000
RXITEM = RXBUFFER; RXBUFFER = ""
END ELSE
IF BINARY AND OS.FILE THEN
IF TU.TRACE THEN TRACE = "Binary transfer, writting OS file."; GOSUB 6000
!@!WRITEBLK RXBUFFER ON F.RXFILE ELSE STATUS = FTE.WRITE.ERROR; !*UP,UV*!
!@!!!!FLUSH F.RXFILE ELSE NULL ; !*UV,UP*!
!@!CLOSESEQ F.RXFILE ; !*UV,UP*!
NOCONVERT ON; !*UDT,UDTVMS*!
OSBWRITE RXBUFFER ON F.RXFILE AT 0 ON ERROR STATUS = FTE.WRITE.ERROR; !*UDT,UDTVMS*!
NOCONVERT OFF; !*UDT,UDTVMS*!
OSCLOSE F.RXFILE ON ERROR NULL ;!*UDT,UDTVMS*!
END ELSE
IF TU.TRACE THEN TRACE = "Non binary transfer, writting to DB file."; GOSUB 6000
WRITE RXBUFFER ON F.RXFILE, RXITEM
END
RTN.STR<1,-1> = RXITEM
END
RETURN
6000 * Output TRACE data
TU.TRACE = TU.TRACE + 1; SBMMV = MOD(TU.TRACE,DBGMOD)
SBMMID = 'SBZ.':PORTNO:'.':INT(TU.TRACE / DBGMOD)
TRACE = OCONV(TIME(), 'MTS'):SPCE:TRACE
WRITEV TRACE ON TUSTATE,SBMMID,SBMMV
RETURN
