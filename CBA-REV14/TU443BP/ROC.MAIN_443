SUBROUTINE ROC.MAIN_443(ROC.CMD, OBJNAME, ATTR, VALS, ERR)
*
** SBClient Host 3GL API
** Copyright (C) Ardent Software Inc. 1998
** Copyright (C) UniData, Inc. 1996, 1997
** Copyright (C) System Builder Corporation. 1995
**
**      This software is the proprietary property and contains
**      trade secrets of Ardent Software, Inc. Any unauthorized use,
**      disclosure or duplication is strictly prohibited.
**      All rights reserved.
*
*
* Description : Main Interface For 3GL Library
*
 INCLUDE TU443BP USER.INCLUDE.H
 INCLUDE TU443BP TU.API.H
 INCLUDE TU443BP SPECIAL.H
 INCLUDE TU443BP ROC.MAIN.H
 INCLUDE TU443BP OS.DELAY.H
 INCLUDE TU443BP TU.ERRORCODES.H
*
DEBUGMODE = FALSE; ZZSTR = ''
*
OPEN '','TUSTATE' TO TUSTATE ELSE
ERR = FTE.TUSTATE.OPEN.ERROR
RETURN
END
OPEN '','TUCONFIG' TO F.TUCONFIG ELSE
ERR = FTE.TUCONFIG.OPEN.ERROR
RETURN
END
*
READV MAX.CMD.LEN FROM F.TUCONFIG, 'FT.TRIGGER', 1 ELSE MAX.CMD.LEN = 0
IF MAX.CMD.LEN < 512 OR NOT(NUM(MAX.CMD.LEN)) THEN
MAX.CMD.LEN = 512
END
READ PAD.PACKETS FROM TUSTATE, 'PAD*':ACCTNAME:'*':PORTNO ELSE PAD.PACKETS = 0
IF PAD.PACKETS # "" THEN
PAD.PACKETS = PAD.PACKETS<1> + 0
GUISEQS<GUI.END> = GUISEQS<GUI.END>:ESC.CHAR:"_PAD":STR(CHAR(1), PAD.PACKETS):TU.TAIL
END
*
IF TU.TRACE THEN
READ LAST FROM TUSTATE,'LAST.':PORTNO ELSE LAST = 0
LAST = LAST + 1
WRITE LAST ON TUSTATE,'LAST.':PORTNO
CMD = 'CREATE':AM:'DESTROY':AM:'SET.ATTRIB':AM:'GET.ATTRIB':AM:'EVENT':AM:'GET.HANDLE':AM:'INIT':AM:'INPUT':AM:'SERVE'
CMD = CMD<ROC.CMD>
WRITE (CMD:AM:OBJNAME:AM:'A=':ATTR:AM:'V=':VALS) ON TUSTATE,('TRACE.':PORTNO:'.':(LAST "R%3"))
END
IF DEBUGMODE THEN CRT; CRT "ROC Request ":ROC.CMD
*
PROMPT NUL
*
DATA.PTR = 0; SAVE.DATA = NUL; ERR = 0; SERVING = FALSE
*
*
* Save 'stacked' data if we will be 'waiting for response'
*
LOOP
STACK = SYSTEM(10)
!@!STACK = 0 ;!*ULT*!
WHILE STACK DO
INPUT STUFF:
DATA.PTR = DATA.PTR+1
SAVE.DATA<DATA.PTR> = STUFF
REPEAT
*
* Issue ROC command and wait for response.
*
*
* Build MESSAGE type String(s) to Transmit via Base Transport class
*
BEGIN CASE
CASE ROC.CMD = ROC.SET.ATTRIB; * Set Attribute(s) in Remote Object
CMD.LINE = ROC.FS:OBJNAME
CMD.LINE = CMD.LINE:ROC.FS:ATTR
CMD.LINE = CMD.LINE:ROC.FS:VALS
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.SETATTRIB>:CMD.LINE
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.GET.ATTRIB; * Get Attribute(s) from Remote Object
CMD.LINE = ROC.FS:OBJNAME:ROC.FS:ATTR
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.GETATTRIB>:CMD.LINE
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.INPUT; * Get Input from Remote Object
CMD.LINE = ROC.FS:OBJNAME:ROC.FS:ATTR
CMD.LINE = CMD.LINE:ROC.FS:VALS
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<GUI.INPUT>:CMD.LINE
GOSUB 1000; * Issue RPC via Base transport Class
IF NOT(RVAL.ERR) THEN; * True if 'set attribute' call was ok!
GOSUB 1100; * go wait for 'real' response!
END
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.GET.EVENT
CMD.LINE = ROC.FS:"this":ROC.FS:"rpc_server"
CMD.LINE = CMD.LINE:ROC.FS:1
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.SETATTRIB>:CMD.LINE
IF DEBUGMODE THEN CRT "Starting Up"
GOSUB 1000; * Issue RPC via Base transport Class
IF NOT(RVAL.ERR) THEN
GOSUB 1100; * Get Next Event
IF NOT(RVAL.ERR) THEN
VALS = RVAL
ERR = FALSE
RESPONSE = FALSE
GOSUB 500
END ELSE ERR = TRUE; VALS = NUL
END ELSE ERR = TRUE; VALS = NUL
CASE ROC.CMD = ROC.SERVE; * Get Input from Remote Object Server
MD.FILE = 'VOC'; !*PI/O,PR1ME,UDT,UDTVMS,UP,UV*!
!@!MD.FILE = 'MD'; !*ADDS,ALTOS,AP,GA,MRX,PICK,SEQ,ULT*!
OPEN MD.FILE TO MDFL ELSE
MD.FILE = 'MD'
OPEN '',MD.FILE TO MDFL ELSE RETURN
END
CALL ROC.SET_443("this", "rpc_server", 1, ERR)
CMD.LINE = ROC.FS:OBJNAME:ROC.FS:ATTR
CMD.LINE = CMD.LINE:ROC.FS:VALS
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.SETATTRIB>:CMD.LINE
IF DEBUGMODE THEN CRT "Starting Up"
GOSUB 1000; * Issue RPC via Base transport Class
IF NOT(RVAL.ERR) THEN; * True if 'set attribute' call was ok!
SERVING = TRUE
DEBUGMODE = FALSE
CMD.LINE = NUL
FUNC = NUL
LOOP WHILE SERVING DO
IF DEBUGMODE THEN CRT "Server ":
GOSUB 1100
IF NOT(RVAL.ERR) THEN
ANS = RVAL
FUNC = OCONV(ANS<1>, "MCU")
IF FUNC NE NUL AND FUNC = OCONV(FUNC, "MCP") THEN
ARRAY = DELETE(ANS, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ANS<1>; ARRAY = ANS; !*MRX*!
VALUE = NUL
ERROR = FALSE
IF TU.TRACE THEN
READ LAST FROM TUSTATE,'LAST.':PORTNO ELSE LAST = 0
LAST = LAST + 1
WRITE LAST ON TUSTATE,'LAST.':PORTNO
WRITE ('rpc.':FUNC:AM:'A=':ARRAY:AM:'V=':VALUE) ON TUSTATE,('TRACE.':PORTNO:'.':(LAST "R%3"))
END
IF DEBUGMODE THEN
CRT
CRT 'Function "':OCONV(FUNC, "MCP"):'"'
END
BEGIN CASE
CASE FUNC = "OFF" OR FUNC = "END"
SERVING = FALSE
RVAL.VALS = ARRAY
RESPONSE = TRUE; GOSUB 500
CASE FUNC = "CALLBACK" AND ARRAY<1> = "EXIT"
SERVING = FALSE
RVAL.VALS = ARRAY<2>
RESPONSE = FALSE; GOSUB 500
CASE FUNC = "CALLBACK"
FUNC = ARRAY<1>
 INCLUDE TU443BP CHECK.IN.MD.H
*
IF PRESENT THEN
ARRAY = DELETE(ARRAY, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ARRAY<1> ; !*MRX*!
PARAMS = ARRAY<1>
EVENTSTR = DELETE(ARRAY, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ARRAY<1>; EVENTSTR = ARRAY; !*MRX*!
EXITSTRING = NUL
FUNC_443 = FUNC : "_443"
CALL @FUNC_443(EVENTSTR, PARAMS, EXITSTRING)
IF EXITSTRING NE NUL THEN
RVAL.VALS = EXITSTRING
SERVING = FALSE
END
IF DEBUGMODE THEN CRT "Called OK"
RESPONSE = FALSE; GOSUB 500
END ELSE
IF DEBUGMODE THEN CRT "No Such Function"
ERROR = TRUE
VALUE = "Invalid Function Call ":FUNC
END
CASE TRUE
FUNC = "RPC.":FUNC
BEGIN CASE
CASE FUNC = "RPC.READ"; GOSUB 501
CASE FUNC = "RPC.READU"; GOSUB 502
CASE FUNC = "RPC.WRITE"; GOSUB 503
CASE FUNC = "RPC.WRITEU"; GOSUB 504
CASE FUNC = "RPC.RELEASE"; GOSUB 505
CASE FUNC = "RPC.DELETE"; GOSUB 506
CASE TRUE
 INCLUDE TU443BP CHECK.IN.MD.H
*
IF PRESENT THEN
VALUE = ""
FUNC_443 = FUNC : "_443"
CALL @FUNC_443(ARRAY, VALUE, ERROR)
IF ERROR THEN CALL TU.RESOLVE.STATUS_443(ERROR, VALUE)
IF DEBUGMODE THEN CRT "Called OK, ":VALUE
END ELSE
IF DEBUGMODE THEN CRT "No Such Function"
ERROR = TRUE
VALUE = "Invalid Function Call ":FUNC
END
END CASE
ABORTFLAG = TRUE
IF DEBUGMODE THEN CRT "Checking For User Abort ... ":
CALL ROC.MAIN_443(ROC.SET.ATTRIB, 'this', 'rpc_abort', ABORTFLAG, ERR)
IF DEBUGMODE THEN CRT "<":ABORTFLAG:"> ":
IF NOT(ERR) THEN
IF NOT(ABORTFLAG) THEN
IF DEBUGMODE THEN CRT " None Detected"
IF DEBUGMODE THEN CRT "Responding ... ":
RESPONSE = ERROR:AM:VALUE; GOSUB 500
END ELSE
IF DEBUGMODE THEN CRT "Detected. Not Responding"
END
END ELSE
RVAL.VALS ="Server Failed To Respond"
SERVING = FALSE
RVAL.ERR = TRUE
IF DEBUGMODE THEN CRT "Cannot Access Server"
END
CASE NUL
END CASE
END
END ELSE
SERVING = FALSE
RVAL.ERR = FALSE
IF DEBUGMODE THEN CRT "Server Failure"
END
REPEAT
IF FUNC = "OFF" THEN
PRINT
PRINT 'Logging Off'
CHAIN "OFF"
END
END
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.CREATE; * Create Object
CMD.LINE = ROC.FS:OBJNAME:ROC.FS:ATTR
CMD.LINE = CMD.LINE:ROC.FS:VALS
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.CREATE>:CMD.LINE
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.DESTROY; * Destroy Object
CMD.LINE = ROC.FS:OBJNAME
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.DESTROY>:CMD.LINE
GOSUB 1000; * Issue RPC via Base transport Class
ERR = RVAL.ERR
CASE ROC.CMD = ROC.EVENT; * Wait for Event
CMD.LINE = ROC.FS:OBJNAME
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.EVENT>:CMD.LINE
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.GET.HANDLE; * raw get handle function
CMD.LINE = ROC.FS:OBJNAME
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.GETHANDLE>:CMD.LINE
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.POP
CMD.LINE = GUISEQS<GUI.TOKEN.POP>
CRT CMD.LINE:GUISEQS<GUI.END>:
ERR = FALSE
CASE ROC.CMD = ROC.INIT; * Initialise Remote Object Call Server
CMD.LINE = GUISEQS<GUI.TOKEN.SET>:TOKENS<1, ASCII.TOKEN>:TOKENS<1,ROC.LDN>
GOSUB 1000; * Issue RPC to Base transport class
OBJNAME=RVAL.OBJNAME
VALS = RVAL.VALS
ERR = RVAL.ERR
END CASE
*
* Restore previously 'stacked' data
*
IF DATA.PTR THEN
FOR I = 1 TO DATA.PTR
DATA SAVE.DATA<I>
NEXT I
END
RETURN
*
500 * RPC Response Method
*
CALL ROC.MAIN_443(ROC.SET.ATTRIB, 'this', 'rpc_respond', RESPONSE, ERR)
IF DEBUGMODE THEN CRT "<":VALUE:"> ":
IF ERR THEN
RVAL.VALS = "Server Failed To Respond"
SERVING = FALSE
RVAL.ERR = TRUE
IF DEBUGMODE THEN CRT "Failed !!"
END ELSE
IF DEBUGMODE THEN CRT "OK"
SERVERVAL = SERVING
CALL ROC.MAIN_443(ROC.SET.ATTRIB, 'this', 'rpc_available', SERVERVAL, ERR)
END
RETURN
*
501 * RPC.READ
*
* Description : Stored Procedure To Read An Item From File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
READ ITEM FROM FN, ITEMNAME ELSE
ERROR = 1
VALUE = ITEMNAME:' Not In File ':FILENAME
RETURN
END
VALS = ARRAY<3>
IF VALS = '' THEN
VALUE = ITEM
RETURN
END
VALUE = ''
D=DCOUNT(VALS, ',')
FOR A=1 TO D
ATT = FIELD(VALS, ',', A)
IF NOT(NUM(ATT)) THEN ERROR = 1; VALUE = 'Illegal Attribute Read Request - ':ATT; RETURN
IF ATT <1 OR ATT NE INT(ATT) THEN ERROR=1; VALUE = 'Illegal Attribute Read Request - ':ATT; RETURN
VALUE<-1> = ITEM<ATT>
NEXT A
RETURN
*
502 * RPC.READU
*
* Description : Stored Procedure To Read An Item From File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
READU ITEM FROM FN, ITEMNAME ELSE
ERROR = 1
VALUE = ITEMNAME:' Not In File ':FILENAME
RETURN
END
VALS = ARRAY<3>
IF VALS = '' THEN
VALUE = ITEM
RETURN
END
VALUE = ''
D=DCOUNT(VALS, ',')
FOR A=1 TO D
ATT = FIELD(VALS, ',', A)
IF NOT(NUM(ATT)) THEN ERROR = 1; VALUE = 'Illegal Attribute Read Request - ':ATT; RETURN
IF ATT <1 OR ATT NE INT(ATT) THEN ERROR=1; VALUE = 'Illegal Attribute Read Request - ':ATT; RETURN
VALUE<-1> = ITEM<ATT>
NEXT A
RETURN
*
503 * RPC.WRITE
*
* Description : Stored Procedure To Write An Item To File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
IF ITEMNAME = '' THEN VALUE = 'NUL Item Name'; ERROR=1; RETURN
BINARY = ARRAY<3>
ITEM = ARRAY
FOR ILOOP = 1 TO 3
ITEM = DELETE(ITEM, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ITEM<1> ; !*MRX*!
NEXT ILOOP
WRITE ITEM ON FN, ITEMNAME
RETURN
*
504 * RPC.WRITEU
*
* Description : Stored Procedure To Write An Item To File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
IF ITEMNAME = '' THEN VALUE = 'NUL Item Name'; ERROR=1; RETURN
BINARY = ARRAY<3>
ITEM = ARRAY
FOR ILOOP = 1 TO 3
ITEM = DELETE(ITEM, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ITEM<1> ; !*MRX*!
NEXT ILOOP
WRITEU ITEM ON FN, ITEMNAME
RETURN
*
505 * RPC.RELEASE
*
* Description : Stored Procedure To Write An Item To File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
IF ITEMNAME = '' THEN VALUE = 'NUL Item Name'; ERROR=1; RETURN
RELEASE FN, ITEMNAME
RETURN
*
506 * RPC.DELETE
*
* Description : Stored Procedure To Delete An Item from a File (Can use AMC list of Ids)
*
ERROR = 0; VALUE = ''; FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
IDLIST = ARRAY<2>
NUM.IDS = COUNT(IDLIST, VM) + (IDLIST # "")
IF NOT(NUM.IDS) THEN
ERROR = 1
VALUE = "No Items in List"
RETURN
END
FOR I = 1 TO NUM.IDS
DELETE FN, IDLIST<I>
NEXT I
RETURN
*
*********************************************************
* Perform Remote Proceedure Call
*********************************************************
1000 *
IF LEN(CMD.LINE) > MAX.CMD.LEN THEN
* Use file transfer module for robust transfer
OPTIONS = 'BH'
DESCRIPTION = NUL; ERROR = FALSE
CALL TU.DOWNLOAD_443(CMD.LINE, '', OPTIONS, DESCRIPTION, ERROR)
*-* Temporary fix for FTP error handling.
IF ERROR THEN
RVAL.ERR = TRUE
RVAL.VALS = NUL
RETURN
END
END ELSE
STRING = CMD.LINE
OLD = ROC.US; NEW = TOKENS<1, ASCII.TOKEN>:"0"; GOSUB 2000
OLD = ROC.FS; NEW = TOKENS<1, ASCII.TOKEN>:"1"; GOSUB 2000
OLD = SVM; NEW = TOKENS<1, ASCII.TOKEN>:"2"; GOSUB 2000
OLD = VM; NEW = TOKENS<1, ASCII.TOKEN>:"3"; GOSUB 2000
OLD = AM; NEW = TOKENS<1, ASCII.TOKEN>:"4"; GOSUB 2000
OLD = CR:LF; NEW = TOKENS<1, ASCII.TOKEN>:"6"; GOSUB 2000
OLD = CR; NEW = TOKENS<1, ASCII.TOKEN>:"5"; GOSUB 2000
CMD.LINE = STRING
*      CRT
*      CALL STR2SRC(CMD.LINE[1, 50])
CRT CMD.LINE:GUISEQS<GUI.END>:
END
*
* Wait for response to command!
*
1100 *
DONE = 0
RETRIES = 0
*
 INCLUDE TU443BP ECHO.OFF.H
*
LOOP
IF DEBUGMODE THEN
DEBUGMODE = DEBUGMODE + 1
IF DEBUGMODE > 9 THEN DEBUGMODE = 1
END
IF DEBUGMODE THEN CRT "Waiting .... ":
*
 INCLUDE TU443BP INPUT.CHAR
*
GUIFOUND = 0
IF DEBUGMODE THEN CRT "(":BYTE:")":
IF BYTE = 4 AND SERVING THEN
IF NOT(DEBUGMODE) THEN
CRT; CRT 'Debug Mode On'
CALL ROC.MAIN_443(ROC.SET.ATTRIB, 'this', 'rpc_debug', TRUE, ERR)
DEBUGMODE = TRUE
END ELSE
CRT; CRT 'Debug Mode Off'
CALL ROC.MAIN_443(ROC.SET.ATTRIB, 'this', 'rpc_debug', FALSE, ERR)
DEBUGMODE = FALSE
END
END
IF BYTE = 8 THEN CRT GUISEQS<GUI.LEADIN>:'a':GUISEQS<GUI.END>:
IF BYTE = 8 AND DEBUGMODE THEN CRT; CRT TIMEDATE():" Sent ACK"
IF BYTE = 2 OR BYTE = 24 THEN; * Ctrl B or Ctrl X Detected
IF BYTE = 24 THEN SLEEP 1
FIRST.CH = CH
 INCLUDE TU443BP INPUT.MORE
*
IF DEBUGMODE THEN
IF NOT(MORE) THEN CRT " No More !":
END
IF MORE THEN
 INCLUDE TU443BP INPUT.CHAR
*
IF BYTE = 2 THEN GUIFOUND = 1
IF DEBUGMODE THEN CRT "(":BYTE:")":
IF BYTE = 24 THEN
RVAL.ERR = TRUE
RVAL.VALS = NUL
GO 1190
END
END
IF GUIFOUND THEN; * GUI lead-in sequence found!
INPUT RVAL:; !*-GA*!
!@!GET RVAL FROM PORTNO UNTIL CR ; !*GA*!
*CRT "gui.ch":;ZZSTR = RVAL;GOSUB 9420
IF DEBUGMODE THEN
FOR A = 1 TO 65 UNTIL A > LEN(RVAL)
C = RVAL[A, 1]
S = SEQ(C)
IF S<32 OR S>127 THEN
CRT "(":S:")":
END ELSE CRT C:
NEXT A
END
BEGIN CASE
CASE RVAL[1, 1] = NAK AND RVAL[2,1] = 'U'
CRT GUISEQS<GUI.LEADIN>:'a':GUISEQS<GUI.END>:
IF DEBUGMODE THEN CRT; CRT TIMEDATE():" Sent ACK"
GOSUB 1200; * Upload Via Data Transfer
IF ERROR THEN
IF DEBUGMODE THEN CRT; CRT "Upload Error"
IF SERVING THEN
RVAL = NUL
RVAL.ERR = FALSE
GO 1190
END ELSE
RVAL = NUL
CRT CMD.LINE:GUISEQS<GUI.END>:
RETRIES = RETRIES + 1
END
END ELSE
RVAL = ITEMID
GOSUB 2100
DONE = TRUE
END
CASE RVAL[1, 1] = NAK
* Error !!! Retry...
CRT CMD.LINE:GUISEQS<GUI.END>:
RETRIES = RETRIES + 1
IF RETRIES > 10 THEN STOP
CASE 1
CRT GUISEQS<GUI.LEADIN>:'a':GUISEQS<GUI.END>:
IF DEBUGMODE THEN CRT; CRT TIMEDATE():" Sent ACK"
GOSUB 2100
DONE = TRUE
END CASE
END
IF DEBUGMODE THEN CRT
END
UNTIL DONE DO REPEAT
1190 *
 INCLUDE TU443BP ECHO.ON.H
*
*
*CRT "vals":;ZZSTR = RVAL.VALS;GOSUB 9420
*CRT "err":;ZZSTR = RVAL.ERR;GOSUB 9420
RETURN
1200 *
PCFILENAME = NUL; * Object will be fed the data
OPEN 'TUSTATE' TO F.DESTFILE ELSE; * Dummy file variable
CRT "No TUSTATE file !!"; STOP
END
ITEMID = NUL; * We'll receive our data here
OPTIONS = RVAL[3, LEN(RVAL)]
DESCRIPTION = NUL
ERROR = 0
CALL TU.UPLOAD_443(PCFILENAME, F.DESTFILE, ITEMID, OPTIONS, DESCRIPTION, ERROR)
RETURN
*
*********************************************************
* Replace delimiters with substitute delimiters.
*********************************************************
2000 *
 INCLUDE TU443BP SWAP.STRINGS.H
*
RETURN
*
*********************************************************
*    Do receive Token translations
*********************************************************
2100 *
STRING = RVAL
*   CALL STR2SRC(RVAL[1, 50])
OLD = TOKENS<1, ASCII.TOKEN>:"0"; NEW = ROC.US; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"1"; NEW = ROC.FS; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"2"; NEW = SVM; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"3"; NEW = VM; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"4"; NEW = AM; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"6"; NEW = CR:LF; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"5"; NEW = CR; GOSUB 2000
RVAL = STRING
*   CALL STR2SRC(RVAL[1, 50])
*
RVAL.OBJNAME = FIELD(RVAL, ROC.FS, 1)
RVAL.ATTRS = FIELD(RVAL, ROC.FS, 2)
RVAL.VALS = FIELD(RVAL, ROC.FS, 3)
RVAL.ERR = FIELD(RVAL, ROC.FS, 4)
*   CRT "ERR=":RVAL.ERR
RETURN
*
5000 * RPC Read, Write, Read+Lock, Write+Retain and Release routines
*
* Note: These functions must be local to this program so that the locks actually work !!!
*
RETURN
*
5100 * RPC Write+Retain Routine (Must be in this program)
*
*
*********************************************************
*    debug routines
*********************************************************
9420 * debug routine, dump string ZZSTR in 'nice' format
ZZL = LEN(ZZSTR)
*CRT 'len=':ZZL
CRT '=':
FOR ZZI = 1 TO ZZL
ZZS = SEQ(ZZSTR[ZZI,1])
IF ZZS >= 32 AND ZZS <= 127 THEN
CRT ZZSTR[ZZI,1]:
END ELSE
CRT "<":ZZS:">":
END
NEXT ZZI
CRT ':'
RETURN
*
*********************************************************
*    THE END
*********************************************************
END
