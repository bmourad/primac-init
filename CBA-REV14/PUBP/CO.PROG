*
EQU VM TO CHAR(253)
EQU AM TO CHAR(254)
EQU SVM TO CHAR(252)
EQU TRUE TO 1
EQU FALSE TO 0
EQU BELL TO CHAR(7) 
EQU CEOL TO @(-4)
EQU CLR TO @(-1)
EQU CEOS TO @(-3)
*
*  def of last edit rec from CO.CONFIG record LAST.EDIT.<username>
*
EQU LE.DATE    TO 1
EQU LE.TIME    TO 2
EQU LE.FILE    TO 3
EQU LE.ITEM    TO 4
EQU LE.REAL.FNAME TO 5
*
EQU A.LOG.USER    TO 1
EQU A.LOG.DATE    TO 2
EQU A.LOG.TIME    TO 3
EQU A.LOG.T.C.NUM TO 4
EQU A.LOG.REASON  TO 5 
* COPY OF TASK CPYLIB
*
**************************
*  TASK FILE DEFINITION  *
*     KEY = TASK ID      *
**************************
      TSK.REC.SIZE = 50
      DIM TSK.REC(50)
      EQU TSK.MASTER        TO TSK.REC(1)    ;* Master task ID
      EQU TSK.CUST          TO TSK.REC(2)    ;* Customer ID
      EQU TSK.CSF           TO TSK.REC(3)    ;* Customer support form number
      EQU TSK.PHASE         TO TSK.REC(4)    ;* Installation phase or "0"
      EQU TSK.DIV           TO TSK.REC(5)    ;* Division #
      EQU TSK.STATUS        TO TSK.REC(6)    ;* Task status ;* MV(N)
      EQU TSK.STAT.DATE     TO TSK.REC(7)    ;* Task status date ;* MV(N)
      EQU TSK.CONTACT       TO TSK.REC(8)    ;* Contact name
      EQU TSK.INIT          TO TSK.REC(9)    ;* Enter operator ID
      EQU TSK.SYS           TO TSK.REC(10)   ;* System name
      EQU TSK.TYPE          TO TSK.REC(11)   ;* Task type (A,C,D,E,I,S)
      EQU TSK.ENT.DATE      TO TSK.REC(12)   ;* Task entry date
      EQU TSK.EXP.DATE      TO TSK.REC(13)   ;* Task completion expected date
      EQU TSK.SHORT.DESC    TO TSK.REC(14)   ;* Task short description
      EQU TSK.ATTACH        TO TSK.REC(15)   ;* Attachment codes
      EQU TSK.EST.HRS       TO TSK.REC(16)   ;* Estimated completion time
      EQU TSK.ACT.HRS       TO TSK.REC(17)   ;* Actual completion time
      EQU TSK.BILL          TO TSK.REC(18)   ;* Billable code
      EQU TSK.BILL.HRS      TO TSK.REC(19)   ;* Billable hours
      EQU TSK.BILL.AMT      TO TSK.REC(20)   ;* Billable amount
      EQU TSK.DESC          TO TSK.REC(21)   ;* (MV1) Task full description
      EQU TSK.EMP           TO TSK.REC(22)   ;* (MV2) Employee ID for time entry
      EQU TSK.EMP.HRS       TO TSK.REC(23)   ;* (MV2) Time worked
      EQU TSK.EMP.SEQ       TO TSK.REC(24)   ;* (MV2)SVM Time transaction number
      EQU TSK.TRN.ACCT      TO TSK.REC(25)   ;* (MV3) Transfer-from account
      EQU TSK.TRN.SYS       TO TSK.REC(26)   ;* Not Used
      EQU TSK.POM           TO TSK.REC(26)   ;* POM calculation
      EQU TSK.TRN.FILE      TO TSK.REC(27)   ;* (MV3) Transfer file name
      EQU TSK.TRN.ITEM      TO TSK.REC(28)   ;* (MV3) Transfer item name
      EQU TSK.TRN.TYPE      TO TSK.REC(29)   ;* (MV3) Transfer type
      EQU TSK.TRN.FUNC      TO TSK.REC(30)   ;* (MV3) Transfer function
      EQU TSK.TRN.CUST      TO TSK.REC(31)   ;* (MV4) Transfer-to customer
      EQU TSK.TRN.DATE      TO TSK.REC(32)   ;* (MV4) Transfer completion date
      EQU TSK.TRN.CDATE     TO TSK.REC(33)   ;* Transfer completed for all
      EQU TSK.TCH.HRS       TO TSK.REC(34)
      EQU TSK.TCH.ACT       TO TSK.REC(35)
      EQU TSK.QC.HRS        TO TSK.REC(36)
      EQU TSK.QC.ACT        TO TSK.REC(37)
      EQU TSK.DOC.HRS       TO TSK.REC(38)
      EQU TSK.DOC.ACT       TO TSK.REC(39)
      EQU TSK.DUE.DATE      TO TSK.REC(40) ;* MV(N)
      EQU TSK.I.EMP         TO TSK.REC(41) ;* MV(N)
      EQU TSK.I.STATUS      TO TSK.REC(42) ;* MV(N)
      EQU TSK.I.STAT.DATE   TO TSK.REC(43) ;* MV(N)
      EQU TSK.I.STAT.TIME   TO TSK.REC(44) ;* MV(N)
      EQU TSK.REV           TO TSK.REC(45)
      EQU TSK.COMMITTED     TO TSK.REC(46)
      EQU TSK.PRINT.DATE    TO TSK.REC(47)
      EQU TSK.CSF.CODE      TO TSK.REC(48)
      EQU TSK.CSF.DESC      TO TSK.REC(49)
      EQU TSK.PROD          TO TSK.REC(50)
*      
*
RECHECK=FALSE
ERRMSG=''
FNAME="CO.FILE"
OPEN "",FNAME TO CO.FILE ELSE 
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="CO.WORK"
OPEN "",FNAME TO CO.WORK ELSE 
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="CO.CONFIG"
OPEN "",FNAME TO CO.CONFIG ELSE 
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="CO.FILELOG"
OPEN "",FNAME TO CO.FILELOG ELSE 
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="DEVBP"
OPEN "DEVBP" TO DEVBP ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="DEV.SCREENS"
OPEN "DEV.SCREENS" TO DEV.SCREENS ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="DEVPROCS"
OPEN "DEVPROCS" TO DEVPROCS ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="DEV.CPYLIB"
OPEN FNAME TO DEV.CPYLIB ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
FNAME="VOC"
OPEN FNAME TO VOC ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
FNAME="CO.ARCHIVE"
OPEN FNAME TO CO.ARCHIVE ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
FNAME="CSF.TRACK"
OPEN FNAME TO CSF.TRACK ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
FNAME="TASK"
OPEN FNAME TO TASK ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
*
*
*
USERNAME = @LOGNAME
*PRINT "DEBUG AT BEGIN YN":
*INPUT RESPO
*IF RESPO = "Y" THEN DEBUG
PORT = @TTY
CTIME=TIME()
OTIME=OCONV(CTIME,"MTHS")
CDATE=DATE()
ODATE=OCONV(CDATE,"D4/")
COMMENT.STR="*"
ITEM=''
ITEMLIST=''
IN.DEV.ACCT=FALSE
LOGTO.CHECKIN=FALSE
GOT.CO.PERMISSION=FALSE
*
PROMPT ' '
*
IF ERRMSG # "" THEN
  PRINT @(0,23):CEOS:ERRMSG
  PRINT 'Enter "RETURN":':
  INPUT XX
  STOP
END
*
PROCREAD CMD ELSE 
  PRINT @(0,23):CEOS:'Command not run correctly use "CO".  Enter "RETURN":':
  INPUT XX
  STOP
END
NUMCMDS = DCOUNT(CMD,AM)
IF NOT(CMD<1> = "CO" OR CMD<1> = "CO." OR CMD<1> = "COT") THEN
  PRINT @(0,23):CEOS:'Command not run correctly use "CO".  Enter "RETURN":':
  INPUT XX
  STOP
END
IF NUMCMDS = 1 AND CMD<1> # 'CO.' THEN
  GOSUB L1000.DISPLAY.HELP
  STOP
END
READ BPFILE.LIST FROM CO.CONFIG,"BPFILE.LIST" ELSE
  XX="APSBP":VM:"ARSBP":VM:"CBABP":VM:"CNVBP":VM:"EP4BP":VM:"EPSBP":VM:"FASBP"
  XX=XX:VM:"GLSBP":VM:"ICSBP":VM:"JCSBP":VM:"JESBP":VM:"NDCBP":VM:"OPSBP"
  XX=XX:VM:"PMCBP":VM:"POSBP":VM:"PR4BP":VM:"PRSBP":VM:"PSSBP":VM:"QPLBP"
  XX=XX:VM:"SASBP":VM:"UTLBP":VM:"SISBP"
  XX=XX:VM:"FUNBP":VM:"RCVBP":VM:"WTRBP"
  WRITE XX ON CO.CONFIG,"BPFILE.LIST"
  BPFILE.LIST=XX
END
FILE.LIST = BPFILE.LIST
READ PROCFILE.LIST FROM CO.CONFIG,"PROCFILE.LIST" ELSE
  XX="APSPROCS":VM:"ARSPROCS":VM:"CBAPROCS":VM:"CNVPROCS":VM:"EP4PROCS"
  XX=XX:VM:"EPSPROCS":VM:"FASPROCS":VM:"GLSPROCS":VM:"ICSPROCS":VM:"JCSPROCS"
  XX=XX:VM:"JESPROCS":VM:"NDCPROCS":VM:"OPSPROCS":VM:"PMCPROCS":VM:"POSPROCS"
  XX=XX:VM:"PR4PROCS":VM:"PRSPROCS":VM:"PSSPROCS":VM:"QPLPROCS":VM:"SASPROCS"
  XX=XX:VM:"UTLPROCS"
  WRITE XX ON CO.CONFIG,"PROCFILE.LIST"
  PROCFILE.LIST=XX
END
NUMAM = DCOUNT(PROCFILE.LIST,VM)
FOR I = 1 TO NUMAM
  LOCATE PROCFILE.LIST<1,I> IN FILE.LIST<1>,1 BY "AL" SETTING POS ELSE
    FILE.LIST = INSERT(FILE.LIST,1,POS;PROCFILE.LIST<1,I>)
  END
NEXT I
READ SCREENFILE.LIST FROM CO.CONFIG,"SCREEENFILE.LIST" ELSE
  XX="APS.SCREENS":VM:"ARS.SCREENS":VM:"CBA.SCREENS":VM:"CNV.SCREENS"
  XX=XX:VM:"EP4.SCREENS":VM:"EPS.SCREENS":VM:"FAS.SCREENS":VM:"GLS.SCREENS"
  XX=XX:VM:"ICS.SCREENS":VM:"JCS.SCREENS":VM:"JES.SCREENS":VM:"NDC.SCREENS"
  XX=XX:VM:"OPS.SCREENS":VM:"PMC.SCREENS":VM:"POS.SCREENS":VM:"PR4.SCREENS"
  XX=XX:VM:"PRS.SCREENS":VM:"PSS.SCREENS":VM:"QPL.SCREENS":VM:"SAS.SCREENS"
  XX=XX:VM:"UTL.SCREENS"
  WRITE XX ON CO.CONFIG,"SCREENFILE.LIST"
  SCREENFILE.LIST=XX
END
NUMAM = DCOUNT(SCREENFILE.LIST,VM)
FOR I = 1 TO NUMAM
  LOCATE SCREENFILE.LIST<1,I> IN FILE.LIST<1>,1 BY "AL" SETTING POS ELSE
    FILE.LIST = INSERT(FILE.LIST,1,POS;SCREENFILE.LIST<1,I>)
  END
NEXT I
READ CPYLIBFILE.LIST FROM CO.CONFIG,"CPYLIBFILE.LIST" ELSE
  XX="APS.CPYLIB":VM:"ARS.CPYLIB":VM:"CBA.CPYLIB":VM:"CNV.CPYLIB":VM:"EP4.CPYLIB"
  XX=XX:VM:"EPS.CPYLIB":VM:"FAS.CPYLIB":VM:"GLS.CPYLIB":VM:"ICS.CPYLIB":VM:"JCS.CPYLIB"
  XX=XX:VM:"JES.CPYLIB":VM:"NDC.CPYLIB":VM:"OPS.CPYLIB":VM:"PMC.CPYLIB":VM:"POS.CPYLIB"
  XX=XX:VM:"PR4.CPYLIB":VM:"PRS.CPYLIB":VM:"PSS.CPYLIB":VM:"QPL.CPYLIB":VM:"SAS.CPYLIB"
  XX=XX:VM:"UTL.CPYLIB"     
  WRITE XX ON CO.CONFIG,"CPYLIBFILE.LIST"
  CPYLIBFILE.LIST=XX
END
NUMAM = DCOUNT(CPYLIBFILE.LIST,VM)
FOR I = 1 TO NUMAM
  LOCATE CPYLIBFILE.LIST<1,I> IN FILE.LIST<1>,1 BY "AL" SETTING POS ELSE
    FILE.LIST = INSERT(FILE.LIST,1,POS;CPYLIBFILE.LIST<1,I>)
  END
NEXT I
READ DEV.ACCT.LIST FROM CO.CONFIG,"DEV.ACCT.LIST" ELSE
  DEV.ACCT.LIST="CBA-DEV10A"
  WRITE DEV.ACCT.LIST ON CO.CONFIG,"DEV.ACCT.LIST"
END
*
BAIL.NOW=0
IF CMD<NUMCMDS>[1,1] = "(" THEN
  * pick options and continue
  OPTIONS = CMD<NUMCMDS>[2,99]
  NUMOPT = DCOUNT(OPTIONS,",")
  FOR OCTR = 1 TO NUMOPT
    CURROPT=FIELD(OPTIONS,",",OCTR)
    BEGIN CASE
      CASE CURROPT = "C"
        GOSUB L3000.PROCESS.C.OPT
    END CASE
  NEXT OCTR
  NUMCMDS=NUMCMDS-1
END
IF BAIL.NOW THEN STOP
*
GOSUB L2000.GET.EDITOR
*
IF BAIL.NOW THEN STOP
*
GOSUB L21000.PROCESS.PW
*
*
IF @LOGNAME='lanny' THEN DEBUG
DO.CHECKIN=FALSE
ITEMLIST=''
IF NUMCMDS >= 2 OR CMD<1> = 'CO../' THEN
  IF CMD<1> = 'CO../' THEN
    READ LAST.EDIT.REC FROM CO.CONFIG,"LAST.EDIT.":USERNAME THEN
      FNAME = LAST.EDIT.REC<LE.FILE>
      ITEM = LAST.EDIT.REC<LE.ITEM>
      IF FNAME = "" THEN GOSUB L6000.GET.FNAME
      IF FNAME # 'X' THEN 
        IF ITEM = '' THEN GOSUB L5000.GET.ITEM
      END
      ITEMLIST=ITEM
    END ELSE
      * last edit unknown 
      LAST.EDIT.REC=''
      GOSUB L6000.GET.FNAME
      ITEM=''
      IF FNAME # 'X' THEN
        GOSUB L5000.GET.ITEM
      END
      LAST.EDIT.REC<LE.REAL.FNAME>=FNAME
    END
    READFNAME=FNAME
    OFILENAME=LAST.EDIT.REC<LE.REAL.FNAME>
    *
    GOSUB L17000.COMPARE.ITEMS
    *
    VAL.RESP=0
    LOOP
    UNTIL VAL.RESP DO
      PRINT "Do you wish to check this pgm in now? U-Undo changes (U/YES/N<cr>) :":
      INPUT RESP
      BEGIN CASE
        CASE RESP = 'YES'
          VAL.RESP=1
          DO.CHECKIN=TRUE
        CASE RESP = 'U'
          VAL.RESP=1
          GOSUB L26000.PROCESS.REVERT
          STOP
        CASE RESP='Y'
          PRINT 
          PRINT "'Y' is not a valid response"
        CASE 1
          ITEMLIST=ITEM
          VAL.RESP=1
      END CASE
    REPEAT
  END ELSE
    PART2 = CMD<2>
    *  the thing here is that PART2 could be an ED,AE,ED+,PSE or fname
    IF PART2 = "ED" OR PART2 = "AE" OR PART2 = "ED+" OR PART2 = "PSE" THEN
      EDITOR.OF.CHOICE = PART2
      IF CMD<3> # "" THEN
        FNAME = CMD<3>
        ITEMLIST=''
        FOR II = 4 TO NUMCMDS
          ITEMLIST<-1>=CMD<II>
          ITEM=ITEMLIST<1>
        NEXT II
      END ELSE
        GOSUB L6000.GET.FNAME
        IF FNAME # "X" THEN
          GOSUB L5000.GET.ITEM
        END
      END
    END ELSE
      * PART 2 IS FILE NAME AND BEYOND IS ITEMLIST
      FNAME=CMD<2>
      ITEMLIST=''
      ITEM=''
      FOR II = 3 TO NUMCMDS
        ITEMLIST<-1> = CMD<II>
        ITEM=ITEMLIST<1>
      NEXT II
    END
    IF FNAME # "X" AND FNAME # "" THEN
      CHECK.READ=0
      GOSUB L25000.CHECK.READ
      IF CHECK.READ < 1 THEN STOP
      IF ITEMLIST = '' AND ITEM = '' THEN
        DONE = 0
        LOOP
          READNEXT ID ELSE DONE=1
        UNTIL DONE DO
          ITEMLIST<-1> = ID
          ITEM=ID
        REPEAT
      END
    END
    IF FNAME = '' OR FNAME = 'X' OR ITEM='' THEN
      * this is where we bail
      STOP
    END
    IF ITEMLIST = '' AND ITEM # "" THEN
      ITEMLIST=ITEM
    END
    * handle get last item and start edit
    OFILENAME=FNAME
  END
  GOSUB L4000.PROCESS.ITEMLIST
END
STOP
*
L1000.DISPLAY.HELP: *
*
PRINT @(0,23):
PRINT "The Check Out Utility 'CO' will check program and proc file items out"
PRINT " the syntax for CO is "
PRINT "   CO {ED,AE,ED+,PSE} <filename> {<itemname> <itemname>} {(C}"
PRINT "   where {ED,AE,ED+,PSE} is the editor if different than your config editor"
PRINT "   where <filename> - is the filename (REQUIRED)"
PRINT "   where {<itemname> <itemname>} - is the items to edit."
PRINT "     if itemname is not specified and a list is active then, items in the"
PRINT "     list will be edited, if no list is active and no item specified"
PRINT "     you will be prompted for an itemname"
PRINT "   where (C is to setup or change the perferred setup          "
PRINT
PRINT " To specify which Editor for each user enter use the '(C' option"
PRINT "  you will be prompted for editor choice."
PRINT
*PRINT "CO. will also be supported where the last item edited will be recalled"
PRINT
PRINT 'Enter "RETURN":':
INPUT XX
RETURN
*
L2000.GET.EDITOR: *
*
READ EDITOR.OF.CHOICE FROM CO.CONFIG,"EDITOR.":USERNAME ELSE
  GOSUB L3000.PROCESS.C.OPT
END
RETURN
*
L3000.PROCESS.C.OPT: *
*
BAIL.NOW=0
LOOP
  VAL.CHOICE=1
  PRINT @(0,23):CEOS:"Choose editor, 1)AE, 2)ED, 3)ED+, 4)PSE or 'X' to Exit :":
  INPUT CHOICE
  BEGIN CASE 
    CASE CHOICE='1'
      EDITOR.OF.CHOICE="AE"
    CASE CHOICE='2'
      EDITOR.OF.CHOICE="ED"
    CASE CHOICE='3'
      EDITOR.OF.CHOICE="ED+"
    CASE CHOICE='4'
      EDITOR.OF.CHOICE="PSE"
    CASE CHOICE='X'
      BAIL.NOW=1
    CASE 1
      VAL.CHOICE=0
  END CASE
UNTIL VAL.CHOICE DO
REPEAT
IF NOT(BAIL.NOW) THEN
  WRITE EDITOR.OF.CHOICE ON CO.CONFIG,"EDITOR.":USERNAME
END
*
RETURN
*
*
L4000.PROCESS.ITEMLIST: *
*
IF DO.CHECKIN THEN
  ITEM=ITEMLIST<1,1>
  GOSUB L15000.DO.CHECKIN.NOW
END ELSE
  NUM.ITEMS =DCOUNT(ITEMLIST,AM)
  FOR IPTR = 1 TO NUM.ITEMS
    ITEM=ITEMLIST<IPTR>
    GOSUB L7000.CHECK.FNAME
    VERB = EDITOR.OF.CHOICE:" ":READFNAME:" ":ITEM
*    PRINT VERB
*    INPUT WAIT
    IF READFNAME = "CO.WORK" THEN
      READ ORIG.REC FROM CO.WORK,ITEM ELSE ORIG.REC=''
      PRINT @(0,23):CEOS:"This edit session is view only.  Enter 'RETURN' :":
      INPUT RESP
    END
    IF READFNAME # "" AND ITEM # "" THEN
      UDTEXECUTE VERB
      IF READFNAME = "CO.WORK" THEN
        READ CHG.REC FROM CO.WORK,ITEM ELSE CHG.REC=''
        IF ORIG.REC # CHG.REC THEN
          *  the record has been changed in the view only editor.  let the user
          *   know and continue
          PRINT @(0,23):CEOS:"The record just edited was changed.  The changes will not"
          PRINT "be saved due to the edit session being view only.  Enter 'RETURN':":
          INPUT RESP
        END
        DELETE CO.WORK,ITEM
      END ELSE
        *  check for changes while away
        GOSUB L17000.COMPARE.ITEMS
        PRINT @(0,23):CEOS:
        PRINT "Do you wish to check this pgm in now? U-Undo changes (U/YES/N<cr>) :":
        INPUT RESP
        IF RESP='U' THEN
          GOSUB L26000.PROCESS.REVERT
          STOP
        END
        IF RESP = 'YES' OR RESP = "Y" THEN
          IF RESP = "Y" THEN
            PRINT "This will check in the pgm are you sure? Y/N":
            INPUT RESP1
            IF RESP1 = "Y" THEN
              GOSUB L15000.DO.CHECKIN.NOW
            END
          END ELSE
            GOSUB L15000.DO.CHECKIN.NOW
          END
        END ELSE
          LRF = LEN(READFNAME)
          IF READFNAME[LRF-1,2] = 'BP' THEN
            PRINT @(0,23):CEOS:"Do you wish to compile this program (Y/N<cr>) :":
            INPUT RESP
            OPTIONS = "{U (D"
            IF RESP = 'Y' THEN
* REMOVE PROMPT BELOW FOR COMPILE OPTIONS IT IS IN DEV MODE JUST USE EM
*
*              PRINT 'Do you want any options (eg {U (D ...) (Y/N<cr>) :': 
*              INPUT RESP
*              IF RESP='Y' THEN
*                PRINT 'Enter Options   :':
*                INPUT OPTIONS
*              END ELSE
*                OPTIONS=''
*              END
*
              VERB = "PBASIC ":READFNAME:" ":ITEM:" ":OPTIONS
              PRINT VERB
              PERFORM VERB
              * CAPTURING JUNK
              JUNK=''
              IF JUNK # "" THEN
                NUM.LINES=DCOUNT(JUNK,AM)
                FOR II = 1 TO NUM.LINES
                  PRINT JUNK<II>
                NEXT II
              END
            END
          END
        END
      END
    END
*    PRINT "BACK FROM ":VERB
*    INPUT WAIT
  NEXT IPTR
END
RETURN
*
L5000.GET.ITEM: *
MSG="Enter Item Name "
PRINT @(0,23):CEOS:MSG:
INPUT ITEM
*
RETURN
*
L6000.GET.FNAME: *
MSG="Enter File Name "
PRINT @(0,23):CEOS:MSG
INPUT FNAME
*
RETURN
*
L7000.CHECK.FNAME: *
* this routine will determine if the file is in the to be checked out from
*  list or if normal editing can continue
*   if the fname is in the to be checkd out list then make sure pgm is
*    not already checkd out
*    if it is warn user prompt for view permission and do the view
*    if it is not ask the user if they want to check it out y - do the ck out
*      n-do the view
*
READFNAME='' ; FTYPE=''
*
*
LOGTO.CHECKIN=FALSE
IN.DEV.ACCT=FALSE
RESTRICT.VIEW=FALSE
SPECIAL.NAME=FALSE
*
*
NUM.DEV.ACCTS=DCOUNT(DEV.ACCT.LIST,AM)
ACCT=@WHO
FOR I = 1 TO NUM.DEV.ACCTS
  IF DEV.ACCT.LIST<I> = ACCT THEN
    IN.DEV.ACCT=TRUE
    LOGTO.CHECKIN=TRUE
  END
NEXT I
IF (FNAME = "DEVBP" OR FNAME="DEVPROCS" OR FNAME="DEV.SCREENS" OR FNAME="DEV.CPYLIB") AND CMD<1> # "CO." THEN
  * only allow this if the user is in a dev account
  IF IN.DEV.ACCT THEN
    PRINT "Unable to check out for ":FNAME
    STOP
  END
END
FTYPE=''
OKNAME=0
LOCATE FNAME IN FILE.LIST<1>,1 SETTING POS THEN
  OKNAME = 1
END
SKIPCHECKOUT=0
IF (FNAME = "DEVBP" OR FNAME="DEVPROCS" OR FNAME="DEV.SCREENS" OR FNAME="DEV.CPYLIB") AND CMD<1> = "CO." THEN
  OKNAME=1
  BEGIN CASE
    CASE FNAME='DEVBP'
      FTYPE='B' ; CMTSTR="*" ; READFNAME="DEVBP"
    CASE FNAME='DEVPROCS'
      FTYPE='P' ; CMTSTR="C" ; READFNAME="DEVPROCS"
    CASE FNAME="DEV.SCREENS"
      FTYPE='S' ; CMTSTR='*' ;READFNAME="DEV.SCREENS"
    CASE FNAME="DEV.CPYLIB"
      FTYPE='C' ; CMTSTR="*" ;READNAME="DEV.CPYLIB"
  END CASE
  SKIPCHECKOUT=1
END
*
*  make sure that file being worked upon is local to this account
*
IF FNAME # READFNAME THEN
   GOSUB L27000CKFNAME   ;* PROCESS NAMES
END ;* IF FNAME # READNAME    
*
*
IF OKNAME THEN
  * the fname is in the check out list
  *
  IF FTYPE = '' THEN
    FTYPE='B' ; CMTSTR="*" ; READFNAME='DEVBP'
  END
  LOCATE FNAME IN BPFILE.LIST<1>,1 SETTING POS THEN
    FTYPE='B' ; CMTSTR= "*" ; READFNAME="DEVBP"
  END ELSE    
    LOCATE FNAME IN PROCFILE.LIST<1>,1 SETTING POS THEN
      FTYPE='P' ; CMTSTR="C" ; READFNAME="DEVPROCS"
    END ELSE
      LOCATE FNAME IN SCREENFILE.LIST<1>,1 SETTING POS THEN
        FTYPE='S' ; CMTSTR='*' ;READFNAME="DEV.SCREENS"
      END ELSE
        LOCATE FNAME IN CPYLIBFILE.LIST<1>,1 SETTING POS THEN
          FTYPE='C' ; CMTSTR='*' ; READFNAME="DEV.CPYLIB"
        END
      END
    END
  END
  IF NOT(SKIPCHECKOUT) THEN
    IF RESTRICT.VIEW THEN
      * the user only gets access through the view facility
      * working on the process of read only files and useraccess restricted
      * to viewing the pgm without update capibilities.
      *
      GOSUB L11000.PROCESS.VIEW.READ
      *
    END ELSE
      *
      GOSUB L9000.PROCESS.READ
      *
    END  ;* RESTRICT VIEW 
  END ;* SKP CHK OUT
END ELSE
  GOSUB L11000.PROCESS.VIEW.READ
END
RETURN
*
*
L8000.PRINT.SDIFF: *
*
* expects TEMFILENAME to contain the original file from checkout
*         ITEM to be the item name that was checked out
XX=''
XX<1>='PQN'
XX<-1>="HSDIFF"
XX<-1>="STON"
XX<-1>="HCO.FILE<"
XX<-1>="H":TEMFILENAME:"*":ITEM:"<"
XX<-1>="H":TEMFILENAME:"<"
XX<-1>="H":ITEM:"<"
XX<-1>="HS<"
XX<-1>="P"
WRITE XX ON VOC,"TEMPVOCITEM*":USERNAME
UDTEXECUTE "TEMPVOCITEM*":USERNAME
DELETE VOC,"TEMPVOCITEM*":USERNAME
*
RETURN
*
*
*
L9000.PROCESS.READ: *
*
IF ITEM="" THEN RETURN
READ REC FROM CO.FILE,FNAME:"*":ITEM THEN
  *  this pgm is in the check out copy file
  * determine if this is the same user
  READ LOGREC FROM CO.FILELOG,FNAME:"*":ITEM THEN
    IF LOGREC<A.LOG.USER>=USERNAME THEN
      * this is the same user set readfname and return
*      READFNAME=LOGREC<A.LOG.FILE>
    END ELSE
      C.RESPONSE.OK=TRUE
      * this is not the same user set user for view and warn
      MESG="This record is checked out by ":LOGREC<A.LOG.USER>:", do you wish to View (Y/N/C)? :"
      PRINT @(0,22):CEOS:MESG:
      *
      GOSUB L10000.PROCESS.VIEW.RESPONSE
      C.RESPONSE.OK=FALSE
      *
    END
  END ELSE
    * error condition not filelog to go with co.file record
    *create again with appoligy
    PRINT "Error with Check Out utility.  The Orig version of the item Checked"
    PRINT "Out is in the file but the log of the check out is missing.  Do you"
    PRINT "wish to continue.  C-Continue this will force another checkout, or"
    PRINT "A-Abort.  (C/A) :":
    VAL.RESP=0
    LOOP
    UNTIL VAL.RESP DO
      INPUT RESP
      IF RESP='A' OR RESP='C' THEN
        VAL.RESP=TRUE
      END ELSE
      END
    REPEAT
    IF RESP='A' THEN STOP 
  END
END ELSE 
  * not checked out find out if they want to check it out and buile
  * filelog
  IF GOT.CO.PERMISSION THEN
    GOSUB L13000.DO.CHECK.OUT
  END ELSE
    PRINT "Do you wish to check out this item (Y/N) :":
    VAL.RESP=0
    LOOP
    UNTIL VAL.RESP DO
      INPUT RESP
      IF RESP='Y' OR RESP='N' THEN
        VAL.RESP=TRUE
        IF RESP='N' THEN
          MESG="Do you wish to View (Y/N)? :"
          PRINT @(0,23):CEOS:MESG:
          *
          C.RESPONSE.OK=FALSE
          GOSUB L10000.PROCESS.VIEW.RESPONSE
          *
        END ELSE
          *
          GOSUB L13000.DO.CHECK.OUT
          *
        END
      END
    REPEAT
  END
END
*
RETURN
*
*
L10000.PROCESS.VIEW.RESPONSE: *
*
INPUT RESP
BEGIN CASE
  CASE RESP[1,1]='Y'
    GOSUB L11000.PROCESS.VIEW.READ ; *
  CASE RESP[1,1]='C' AND C.RESPONSE.OK
    GOSUB L20000.PROCESS.RECHECKOUT ; *
  CASE RESP[1,1]#'Y'
    READFNAME=''
END CASE
*
RETURN
*
*
L11000.PROCESS.VIEW.READ: *
*
READFNAME = "CO.WORK"
OPEN "",FNAME TO TEMPFNAME THEN
  READ REC FROM TEMPFNAME,ITEM ELSE REC=''
  REC=INSERT(REC,1;"TMP CK OUT ":CDATE:" ":CTIME)
  WRITE REC ON CO.WORK,ITEM
END ELSE
  * error condition the file in fname could not be opened
  PRINT @(0,23):CEOS:FNAME:" could not be opened.  Enter 'RETURN' :":
  INPUT RESP
  READFNAME=''
END
*
RETURN
*
*
L12000.CHECK.SPEC.FNAME: *
*
BEGIN CASE
  CASE LPART='BP'
    FTYPE='B' ; CMTSTR="*" ; READFNAME="DEVBP"
  CASE LPART='PROCS'
    FTYPE='P' ; CMTSTR="C" ; READFNAME="DEVPROCS"
  CASE LPART=".SCREENS"
    FTYPE='S' ; CMTSTR='*' ;READFNAME="DEV.SCREENS"
  CASE LPART=".CPYLIB"
    FTYPE='C' ; CMTSTR="*" ;READNAME="DEV.CPYLIB"
END CASE
IF FTYPE = '' THEN
  * this edit is not for <client>bp,<client>procs... but is for
  *  <client>LPART and this is not a checkout file
  PRINT "This is not a file for the CheckOut Utility."
  STOP
END
OKNAME=TRUE
RESTRICT.VIEW=FALSE
SPECIAL.NAME=TRUE
RETURN
*
*
L13000.DO.CHECK.OUT:
*
* this part will check out the pgm from the check out file location and
*  flag it as checked out so no one else can edit it.  Information needed
*  is task or csf ; number ; reason ; 
*
DEVERROR=0
BEGIN CASE
  CASE RECHECK
  CASE FTYPE='B'
    READ REC FROM DEVBP,ITEM THEN
      *THIS IS A PROBLEM  SHOULD NOT BE HERE
      DEVERROR=1
      ERRFILE="DEVBP"
    END
  CASE FTYPE='P'
    READ REC FROM DEVPROCS,ITEM THEN
      *THIS IS A PROBLEM  SHOULD NOT BE HERE
      DEVERROR=1
      ERRFILE="DEVPROCS"
    END
  CASE FTYPE='S'
    READ REC FROM DEV.SCREENS,ITEM THEN
      *THIS IS A PROBLEM  SHOULD NOT BE HERE
      DEVERROR=1
      ERRFILE="DEV.SCREENS"
    END
  CASE FTYPE='C'
    READ REC FROM DEV.CPYLIB,ITEM THEN
      *THIS IS A PROBLEM  SHOULD NOT BE HERE
      DEVERROR=1
      ERRFILE="DEV.CPYLIB"
    END
END CASE
IF DEVERROR = 1 THEN
  * THIS IS A BAIL POINT THE DEV<FILE> ITEM IS PRESENT AND THIS IS NOT GOOD
  PRINT "Unable to continue the ":ERRFILE:" record for ":ITEM:" is present"
  PRINT "you must resolve this issue before this item can be checked out."
  STOP
END
REASON='' ; C.OR.T = '' ; TNUMBER=''
DO.BAIL=0
VALID.RESPONSE=FALSE
LOOP
UNTIL VALID.RESPONSE DO
  IF IN.DEV.ACCT THEN
    PRINT @(0,23):CEOS:"Enter T-Task :":
    C.OR.T = 'T'
  END ELSE
    PRINT @(0,23):CEOS:"Enter C-CSF or T-Task (C/T) :":
    INPUT C.OR.T
  END
  IF C.OR.T = 'C' OR C.OR.T = 'T' THEN
    IF NOT(IN.DEV.ACCT) THEN
      VALID.RESPONSE = TRUE
    END ELSE
      IF C.OR.T = 'C' THEN
        PRINT @(0,23):BELL:"CSF is not allowed in Dev/Release accounts"
      END ELSE
        VALID.RESPONSE=TRUE
      END
    END
  END ELSE
    IF C.OR.T = '^' OR C.OR.T=CHAR(27) THEN
      DO.BAIL=1
      VALID.RESPONSE=TRUE
    END ELSE
      PRINT @(0,23):BELL:C.OR.T:" is not a Valid response try 'C' or 'T'.  Enter 'RETURN'":
      INPUT XX
      PRINT @(0,23):CEOS:
    END
  END
REPEAT
IF DO.BAIL THEN RETURN
IF C.OR.T='T' THEN IS.TASK=TRUE ELSE IS.TASK=FALSE
VALID.RESPONSE=FALSE
LOOP
UNTIL VALID.RESPONSE DO
  IF IS.TASK THEN
    PRINT @(0,23):"Enter the number associated with this Task :":
  END ELSE
    PRINT @(0,23):"Enter the number associated with this CSF :":
  END
  INPUT TNUMBER
  IF TNUMBER#"" AND NUM(TNUMBER) THEN
    IF IS.TASK THEN
      READ TTREC FROM TASK,TNUMBER THEN
        VALID.RESPONSE=TRUE
      END ELSE
        PRINT @(0,23):CEOS:BELL:TNUMBER:" is not a valid task number"
      END
    END ELSE
      READ TTREC FROM CSF.TRACK,TNUMBER THEN
        VALID.RESPONSE=TRUE
      END ELSE
        PRINT @(0,23):CEOS:BELL:TNUMBER:" is not a valid CSF number"
      END
    END
  END ELSE
    IF TNUMBER = '^' OR TNUMBER=CHAR(27) THEN
      DO.BAIL=1
      VALID.RESPONSE=TRUE
    END ELSE
      PRINT @(0,23):BELL:TNUMBER:" is not a Valid response.  Enter 'RETURN'":
      INPUT XX
      PRINT @(0,23):CEOS:
    END
  END
REPEAT
IF DO.BAIL THEN RETURN
VALID.RESPONSE=FALSE
REASON.STR=''
PRINT @(0,23):CEOS:"Enter reason,  conclude reason with 'END' on a line by itself"
LOOP
UNTIL VALID.RESPONSE DO
  PRINT ":":
  INPUT REASON
  REASON=TRIM(REASON)
  IF REASON#"" AND REASON#"^" AND REASON#CHAR(27) THEN
    IF REASON = "END" THEN
      IF REASON.STR= "" THEN
        PRINT "Need some text for a reason..."
      END ELSE
        VALID.RESPONSE=TRUE
      END
    END ELSE
      IF REASON.STR # "" THEN
        REASON.STR=REASON.STR:" ":REASON
      END ELSE
        REASON.STR=REASON
      END
    END
  END ELSE
    IF REASON = '^' OR REASON=CHAR(27) THEN
      DO.BAIL=1
      VALID.RESPONSE=TRUE
    END ELSE
      PRINT @(0,23):BELL:REASON:" is not a Valid response.  Enter 'RETURN'":
      INPUT XX
      PRINT @(0,23):CEOS:
    END
  END
REPEAT
IF DO.BAIL THEN RETURN
* at this point REASON, TNUMBER, and C.OR.T are setup
* also from above FNAME and ITEM and USERNAME are setup
* setup record in lock file, copy record to hold location and update
*  pgm with new comment and copy into dev file.
SVCMT=''
OPEN FNAME TO TEMPFNAME THEN
  READ REC FROM TEMPFNAME,ITEM THEN
    IF RECHECK THEN
      * special case for revist to checkout to re checkout
      OTIME=OCONV(TIME(),"MTHS")
      ODATE=OCONV(DATE(),"D4/")
      TEMPID = FNAME:"*":ITEM:"*":ODATE:"*":OTIME
      BEGIN CASE
        CASE FTYPE='B'
          READ REC FROM DEVBP,ITEM ELSE
            PRINT "ERROR Cannot read ":ITEM:" from DEVBP" ; STOP
          END
        CASE FTYPE='P'
          READ REC FROM DEVPROCS,ITEM ELSE
            PRINT "ERROR Cannot read ":ITEM:" from DEVPROCS" ; STOP
          END
        CASE FTYPE='S'
          READ REC FROM DEV.SCREENS,ITEM ELSE
            PRINT "ERROR Cannot read ":ITEM:" from DEV.SCREENS" ; STOP
          END
        CASE FTYPE='C'
          READ REC FROM DEV.CPYLIB,ITEM ELSE
            PRINT "ERROR Cannot read ":ITEM:" from DEV.CPYLIB" ; STOP
          END
      END CASE
      WRITE REC ON CO.ARCHIVE,TEMPID          
    END
    GOSUB L14000.PROCESS.CKOUT
  END ELSE
    * THERE IS NO REC BY THIS NAME
    PRINT "No item exists by this name ":ITEM:" in the file ":FNAME
    PRINT "A NEW item will be created.  Do you still wish to check it out (Y/N) :":
    INPUT RES
    IF RES='Y' THEN
      IF FNAME[LEN(FNAME)-1,2] = "BP" THEN
        READ REC FROM CO.CONFIG,"NEW.REC.TEMPLATE" ELSE REC=''
        GOSUB L24000.PROCESS.TEMPLATE
      END ELSE
        REC=''
      END
      TEMPID = FNAME:"*":ITEM:"*":ODATE:"*":OTIME
      WRITE REC ON CO.ARCHIVE,TEMPID
      WRITE REC ON TEMPFNAME,ITEM
      GOSUB L14000.PROCESS.CKOUT
    END
  END
END ELSE
  ERR="UNABLE TO OPEN ":FNAME
  PRINT ERR
  STOP
END
RETURN        
*
L14000.PROCESS.CKOUT:
*
ADDVAL = CMTSTR:C.OR.T:TNUMBER:" ":USERNAME:" ":ODATE:" * "
TEMPSTR=ADDVAL
LEN.ADD = LEN(ADDVAL)
ORIG.REC=REC
COMMENT.SPACE = 73 - LEN.ADD
COMMENT.FILL= LEN.ADD
IF LEN(REASON.STR) < COMMENT.SPACE THEN
  ADDVAL = ADDVAL:REASON.STR
  NUMADD = 1
END ELSE
  NUM.WORD=DCOUNT(REASON.STR," ")
  NEW.COMMENT='' ; TCOMMT='' ; WCOMMT='' 
  FOR I = 1 TO NUM.WORD
    CURRWORD = FIELD(REASON.STR," ",I)
    IF TCOMMT = "" THEN
      TCOMMT = CURRWORD
    END ELSE
      TCOMMT = TCOMMT:" ":CURRWORD
    END
    IF LEN(TCOMMT) < COMMENT.SPACE THEN
      WCOMMT = TCOMMT
    END ELSE
      IF NEW.COMMENT = '' THEN
        NEW.COMMENT = WCOMMT
      END ELSE
        NEW.COMMENT<-1> = WCOMMT
      END
      WCOMMT = ''
      TCOMMT=CURRWORD
    END
  NEXT I
  IF WCOMMT # "" THEN
    IF NEW.COMMENT = '' THEN
      NEW.COMMENT = WCOMMT
    END ELSE
      NEW.COMMENT<-1> = WCOMMT
    END
  END ELSE
    IF TCOMMT # "" THEN
      IF NEW.COMMENT = "" THEN
        NEW.COMMENT = TCOMMT
      END ELSE
        NEW.COMMENT<-1>=TCOMMT
      END
    END
  END
  NUMADD = DCOUNT(NEW.COMMENT,AM)
  ADDVAL = NEW.COMMENT
END
* determine insert line
*
STPLOOP=FALSE
NUMITMLINES=DCOUNT(REC,AM)
FOUNDCOM=FALSE ; FOUNDCOPY=FALSE
HOLDPTR=2
LEN.FNAME=LEN(FNAME)
IF FNAME[LEN.FNAME-1,2] = 'BP' THEN
  FOR II = 2 TO NUMITMLINES WHILE NOT(STPLOOP)
    IF II > 150 THEN
      *  did nt find a place to insert then use line 2
      STPLOOP=TRUE
    END ELSE
      IF REC<II>[1,6]="*COPY>" THEN
        LASTWORD=TRIM(FIELD(REC<II>,">",3))
        IF INDEX(LASTWORD,"COM",1) THEN
          * this is likely a common stmt found a common mark it and continue
          HOLDPTR=II
          FOUNDCOM=TRUE
        END ELSE
          IF FOUNDCOM OR FOUNDCOPY THEN 
            * this is the first line past the common stmts and is not a common
            STPLOOP=TRUE
          END ELSE
            * this is a copy stmt not common found yet continue
          END
        END 
        FOUNDCOPY=TRUE
      END ELSE
        IF FOUNDCOM OR FOUNDCOPY THEN
          * this is the first line past a found common or cpylib
          *  and should escape here
          STPLOOP=TRUE
        END
      END
    END
  NEXT II
  PART1=FALSE
  IF FOUNDCOM OR FOUNDCOPY OR STPLOOP OR TRUE THEN
    STPLOOP=FALSE
    FOR II = 2 TO 150 WHILE NOT(STPLOOP)
      IF TRIM(REC<II>[1,7]) = "*ENDDOC" THEN
        HOLDPTR=II-1
        IF HOLDPTR < 2 THEN HOLDPTR=2
        STPLOOP=TRUE
        FOUNDCOM=TRUE
      END ELSE
        IF INDEX(REC<II>,"DESCRIPTION",1) OR PART1 THEN
          IF NOT(PART1) THEN
            PART1=TRUE
          END ELSE
            IF INDEX(REC<II>,"****************************",1) THEN
              HOLDPTR=II-1
              IF HOLDPTR < 2 THEN HOLDPTR=2
              STPLOOP=TRUE
              FOUNDCOM=TRUE
            END
          END
        END
      END
    NEXT II
  END
END
*
IF FOUNDCOM THEN
  HOLDPTR=HOLDPTR+1
END
FOR I = NUMADD TO 1 STEP (-1)
  IF I > 1 THEN
    CURRVAL = CMTSTR:SPACE(COMMENT.FILL-1):ADDVAL<I>
  END ELSE
    IF NUMADD > 1 THEN
      ADDVAL<I> = TEMPSTR:ADDVAL<I>
    END
    CURRVAL = ADDVAL<I>
  END
  REC = INSERT(REC,HOLDPTR;CURRVAL)
  IF SVCMT = '' THEN
    SVCMT=ADDVAL<I>
  END ELSE
    SVCMT=ADDVAL<I>:" ":SVCMT
  END
NEXT I
BEGIN CASE
  CASE FTYPE='B'
    WRITE REC ON DEVBP, ITEM
    READFNAME='DEVBP'
  CASE FTYPE='P'
    WRITE REC ON DEVPROCS, ITEM
    READFNAME='DEVPROCS'
  CASE FTYPE='S'
    WRITE REC ON DEV.SCREENS,ITEM
    READFNAME='DEV.SCREENS'
  CASE FTYPE='C'
    WRITE REC ON DEV.CPYLIB,ITEM
    READFNAME='DEV.CPYLIB'
END CASE
IF NOT(RECHECK) THEN
  WRITE ORIG.REC ON CO.FILE,FNAME:"*":ITEM
END
LER=''
LER<LE.DATE>=CDATE
LER<LE.TIME>=CTIME
LER<LE.FILE>=READFNAME
LER<LE.ITEM>=ITEM
LER<LE.REAL.FNAME>=FNAME
LOGF=''
LOGF<A.LOG.USER> = USERNAME
LOGF<A.LOG.DATE> = CDATE
LOGF<A.LOG.TIME> = CTIME
LOGF<A.LOG.T.C.NUM>=C.OR.T:TNUMBER
LOGF<A.LOG.REASON>=SVCMT    
IF RECHECK THEN
  READ TEMPREC FROM CO.FILELOG,FNAME:"*":ITEM THEN
    WRITE TEMPREC ON CO.FILELOG,FNAME:"*":ITEM:"*":DATE():"*":TIME()
  END
END
WRITE LER ON CO.CONFIG,"LAST.EDIT.":USERNAME
WRITE LOGF ON CO.FILELOG,FNAME:"*":ITEM
RECHECK=FALSE
*
RETURN
*
L15000.DO.CHECKIN.NOW: *
*
CTIME=TIME()
OTIME=OCONV(CTIME,"MTHS")
CDATE=DATE()
ODATE=OCONV(CDATE,"D4/")
OPEN READFNAME TO TEMPFILE THEN
  READ REC FROM TEMPFILE,ITEM THEN
    OPEN FNAME TO TEMP2FILE THEN
      WRITE REC ON TEMP2FILE,ITEM
      READ LOGF FROM CO.FILELOG,FNAME:"*":ITEM ELSE LOGF="UNK"
      WRITE LOGF ON CO.FILELOG,FNAME:"*":ITEM:"*":CDATE:"*":CTIME
      DELETE CO.FILELOG,FNAME:"*":ITEM
      DELETE CO.CONFIG,"LAST.EDIT.":USERNAME
*      DELETE TEMPFILE,ITEM
      READ TTREC FROM CO.FILE,FNAME:"*":ITEM THEN
        WRITE TTREC ON CO.ARCHIVE,FNAME:"*":ITEM:"*":ODATE:"*":OTIME
      END
      DELETE CO.FILE,FNAME:"*":ITEM
      LASTTWO = FNAME[LEN(FNAME)-1,2]
      IF LOGTO.CHECKIN = TRUE AND LASTTWO = "BP" THEN
        GOSUB L15400.PROCESS.REMOTE.COMPILE
      END ELSE
        IF LASTTWO ="BP" THEN
          GOSUB L15500.PROCESS.LOCAL.COMPILE
        END
      END
      DELETE TEMPFILE,ITEM
      *   add logic to add item to task
      IF LOGF<A.LOG.T.C.NUM>[1,1]="T" THEN
        *   this is a task maybe update the task with this item
        *
        TASKNUM = LOGF<A.LOG.T.C.NUM>[2,99]
        MATREAD TSK.REC FROM TASK,TASKNUM THEN
          NUMVALS = DCOUNT(TSK.TRN.ACCT,@VM)
          ITEMFND=0
          FOR TTT = 1 TO NUMVALS
            IF TSK.TRN.ACCT<1,TTT> = ACCT THEN
              IF TSK.TRN.FILE<1,TTT> = FNAME THEN
                IF TSK.TRN.ITEM<1,TTT> = ITEM THEN
                  ITEMFND = 1
                END
              END
            END
          NEXT TTT
          IF NOT(ITEMFND) THEN
            *  determine type
            FTYPE=FNAME[LEN(FNAME)-1,2]
            IF FTYPE = "BP" THEN
              NFTYPE='B'
            END ELSE
              IF FTYPE='CS' THEN
                NFTYPE = 'P'
              END ELSE
                IF FTYPE='NS' THEN
                  NFTYPE='S'
                END ELSE
                  NFTYPE='B'
                END
              END
            END
            TSK.TRN.ACCT<1,NUMVALS+1> = ACCT
            TSK.TRN.FILE<1,NUMVALS+1> = FNAME
            TSK.TRN.ITEM<1,NUMVALS+1> = ITEM
            TSK.TRN.TYPE<1,NUMVALS+1> = NFTYPE
            TSK.TRN.FUNC<1,NUMVALS+1> = 'O'
            MATWRITE TSK.REC ON TASK,TASKNUM
          END
        END
      END    
    END
  END
END
RETURN
*
L15400.PROCESS.REMOTE.COMPILE: *
*
*  first do a local compile to clean up the USER.SCRATCH file
*
PRINT "Performing local compile to clean up USER.SCRATCH"
VERB = "PBASIC ":READFNAME:" ":ITEM
UDTEXECUTE VERB CAPTURING JUNK
*  now process the real compile
PRINT "Preparing for remote logto"
READ TMD FROM VOC,FNAME THEN
  PATHDATA = TMD<2>
  NUM.SEPS=DCOUNT(PATHDATA,"/")
  NUM.SEPS=NUM.SEPS-1
  NPATHDATA=''
  FOR PTS = 1 TO NUM.SEPS
    IF PTS=1 THEN
      NPATHDATA=FIELD(PATHDATA,"/",1)
    END ELSE
      NPATHDATA=NPATHDATA:"/":FIELD(PATHDATA,"/",PTS)
    END
  NEXT PTS
* THIS IS A DEBUG LOCATION
*PRINT 'DO DEBUG YN':
*INPUT RESPO
*IF RESPO='Y' THEN DEBUG
  VERB = "LOGTO ":NPATHDATA
  MDREC    ="HGET.LOG.NAME"
  MDREC<-1>="P"
  MDREC<-1>="IF %1 # %LOGNAME% GO 9898"
  MDREC<-1>="X"
  MDREC<-1>="9898 C"
  CURR.LOC = @PATH
  TEMPQPTR='F'
  TEMPQPTR<-1>=NPATHDATA:"/VOC"
  TEMPQPTR<-1>=NPATHDATA:"/D_VOC"
  WRITE TEMPQPTR ON VOC,"CHKIN.PTR*":USERNAME
  OPEN "CHKIN.PTR*":USERNAME TO REMOTE.VOC THEN
    READU REMOTE.LOGIN FROM REMOTE.VOC,"LOGIN" THEN
      OUTMDREC = REMOTE.LOGIN<1>
      TEMPMDREC=MDREC
      TEMPMDREC=CHANGE(TEMPMDREC,"%LOGNAME%",USERNAME)
      OUTMDREC<2> = TEMPMDREC
      NUMAM = DCOUNT(REMOTE.LOGIN,@AM)
      FOR III = 2 TO NUMAM
        OUTMDREC=OUTMDREC:@AM:REMOTE.LOGIN<III>
      NEXT III
      WRITEU OUTMDREC ON REMOTE.VOC,"LOGIN"
      PRINT "Logto ":NPATHDATA:" for PBASIC"
      UDTEXECUTE VERB CAPTURING JUNK
      VERB = "PBASIC ":FNAME:" ":ITEM
      PRINT "Performing PBASIC"
      UDTEXECUTE VERB CAPTURING JUNK
      PRINT JUNK
      PRINT "Logging back"
      VERB = "LOGTO ":CURR.LOC
      UDTEXECUTE VERB CAPTURING JUNK
      WRITE REMOTE.LOGIN ON REMOTE.VOC,"LOGIN"
      DELETE VOC,"CHKIN.PTR*":USERNAME
      OPEN "SAVEDLISTS" TO SAVEDLISTS THEN
        LISTIDNAME="CHKIN.ITEM*":USERNAME
        WRITE ITEM ON SAVEDLISTS,LISTIDNAME:"000"
        TPROC="PQN"
        TPROC<-1>="HCLEAR.LOCAL.PTR"
        TPROC<-1>="STON"
        TPROC<-1>="H":LISTIDNAME:"<"
        TPROC<-1>="P"
        PRINT "Running CLEAR.LOCAL.PTR program to clean up MDs"
        WRITE TPROC ON VOC, "CHKIN.PQ*":USERNAME
        UDTEXECUTE "CHKIN.PQ*":USERNAME CAPTURING JUNK
        DELETE VOC,"CHKIN.PQ*":USERNAME
        DELETE SAVEDLISTS,LISTIDNAME:"000"
      END
    END
  END
  DELETE VOC,"CHKIN.PTR*":USERNAME
END
*
RETURN
*
L15500.PROCESS.LOCAL.COMPILE: *
*
IF LASTTWO # "BP" THEN RETURN
PRINT "Performing compile on ":ITEM
VERB = "PBASIC ":FNAME:" ":ITEM
UDTEXECUTE VERB CAPTURING JUNK
PRINT JUNK
*
RETURN
*
L16000.PROCESS.CUST.FILENAME: *
*
IF NOT(OKNAME) THEN
  * check here for customer name files
  RESTRICT.VIEW=TRUE
  IF (INDEX(ACCT,"-",1) AND FIELD(ACCT,"-",1)="CBA") THEN
    * the customername is here get it
    CUSTNAME=FIELD(ACCT,"-",2)
    LEN.CUST=LEN(CUSTNAME)
    IF FNAME[1,LEN.CUST] = CUSTNAME THEN
      * check last part to see if it is bp,proc,screen,cpylib
      LPART=FNAME[LEN.CUST+1,99]
      GOSUB L12000.CHECK.SPEC.FNAME
    END ELSE
      * this is a checkout attemp and the custname does not equal the
      *  CBA-<cust> name of the account.   See if it is in the Cust
      *  table 
      READ CUST.NAMES FROM CO.CONFIG,"CUST.NAMES" THEN
        NUM.CUST=DCOUNT(CUST.NAMES,AM)
        FND.CUST=FALSE
        FOR I = 1 TO NUM.CUST WHILE NOT(FND.CUST)
          IF CUSTNAME = CUST.NAMES<I,1> THEN
            FND.CUST=TRUE
            TMPNAME=CUST.NAMES<I,2>
          END
        NEXT I
        IF FND.CUST THEN
          LENTMP=LEN(TMPNAME)
          LPART=FNAME[LENTMP+1,99]
          GOSUB L12000.CHECK.SPEC.FNAME
        END
      END ELSE
        * unable to read item from co.config CUST.NAMES 
      END
    END
  END ELSE    
    * this is not a CBA account and not a l
    PRINT "Only use the Check Out utility in CBA accounts."
    STOP
  END
END ELSE
  IF (INDEX(ACCT,"-",1) AND FIELD(ACCT,"-",1)="CBA") OR ACCT[1,4]="RND1" THEN
    * this is a CBA account ok to check out here
  END ELSE
    PRINT "Only use the Check Out utility in CBA accounts."
    STOP
  END
END ;* IF OKNAME   this is a file in the filelist      
*
RETURN
*
*
L17000.COMPARE.ITEMS:
*
READ TEMP1 FROM CO.FILE,OFILENAME:"*":ITEM THEN
  OPEN OFILENAME TO TEMPFNAME THEN
    READ TEMP2 FROM TEMPFNAME, ITEM THEN
      IF LEN(TEMP1) = LEN(TEMP2) THEN
        * these items are the same number of bytes
      END ELSE
        VALRES=FALSE
        LOOP 
        WHILE NOT(VALRES) DO
          PRINT "The original record from ":FNAME:" has changed"
          PRINT "  since it was checked out.  Manually determine difference."
          PRINT "  X-Exit , I-Ignore, S-Sdiff:":
          INPUT RESP
          IF RESP = 'X' THEN VALRES=1
          IF RESP = 'I' THEN VALRES=1
          IF RESP = 'S' THEN
            TEMFILENAME=OFILENAME
            GOSUB L8000.PRINT.SDIFF
            VALRES=1
          END
        REPEAT
        IF RESP='X' THEN STOP
      END
    END ELSE
      * readfail on original record
    END
  END ELSE
    * open fail on file to check out from
  END
END ELSE
  * read fail of checked out copy
END
*
RETURN
*
L18000.CHECK.LCL.ITEM:
*
READ TREC FROM VOC,FNAME THEN
  IF NOT(INDEX(TREC<2>,"/",1)) THEN
    * this is a local file 
    OPEN FNAME TO TEMPFILENAME THEN
      READ TITEM FROM TEMPFILENAME,ITEM THEN
        *  this is a problem the item already exists warn the user
        * and stop
        PRINT @(0,23):CEOS:"The item ":ITEM:" already exists in the file ":FNAME
        PRINT "Check it out from there."
        STOP
      END ELSE
        IF DO.CPY THEN
          OPEN ORIGFNAME TO ORIGTEMPFILENAME THEN
            READ TREC FROM ORIGTEMPFILENAME,ITEM THEN
              WRITE TREC ON TEMPFILENAME,ITEM
              RESTRICT.VIEW=FALSE
            END ELSE
              PRINT @(0,23):CEOS:"The item ":ITEM:" is not on file in the file ":ORIGFNAME
              STOP
            END
          END ;* OPEN ORIGFNAME....
        END
      END ;* READ TITEM ....
    END ;* OPEN FNAME....
  END ;* IF NOT(INDEX,"/...  
END  ;* READ TREC FROM VOC..          
*
RETURN
*
L19000.SETUP.FNAME:
*
ORIGFNAME=FNAME
CUSTNAME=FIELD(ACCT,"-",2)
LEN.CUST=LEN(CUSTNAME)
READ CUST.NAMES FROM CO.CONFIG,"CUST.NAMES" THEN
  NUM.CUST=DCOUNT(CUST.NAMES,AM)
  FND.CUST=FALSE
  FOR I = 1 TO NUM.CUST WHILE NOT(FND.CUST)
    IF CUSTNAME = CUST.NAMES<I,1> THEN
      FND.CUST=TRUE
      TMPNAME=CUST.NAMES<I,2>
    END
  NEXT I
  IF FND.CUST THEN
    LEN.CUST=LEN(TMPNAME)
    CUSTNAME=TMPNAME
  END
END
*  build fname
*
BEGIN CASE 
  CASE FILETYPE='B'
    FNAME=CUSTNAME:"BP"
  CASE FILETYPE='C'
    FNAME=CUSTNAME:".CPYLIB"
  CASE FILETYPE='P'
    FNAME=CUSTNAME:"PROCS"
  CASE FILETYPE='S'
    FNAME=CUSTNAME:'.SCREENS'
END CASE
*
RETURN
*
L20000.PROCESS.RECHECKOUT:
*
RECHECK=TRUE
GOSUB L13000.DO.CHECK.OUT
*
RECHECK=FALSE
IF DO.BAIL THEN STOP
*
RETURN
*
L21000.PROCESS.PW:
*
PW.OK=FALSE
PW.PASS.CNT=0
CTIME=TIME()
LOOP
  PW.PASS.CNT = PW.PASS.CNT + 1
UNTIL PW.PASS.CNT > 3 OR PW.OK DO
  READ PWREC FROM CO.CONFIG,"PW.":USERNAME ELSE PWREC="CBA":CTIME
  PRINT "Enter Password for ":USERNAME:" or 'C' to Change :":
  ECHO OFF
  INPUT RESP
  ECHO ON
  PRINT
  IF RESP = "C" OR PWREC = "CBA":CTIME THEN
    * get password
    IF PWREC="CBA":CTIME THEN
      * skip getting old password
      PW.OK=TRUE
    END ELSE
      PRINT "Enter Old Password for verification :":
      ECHO OFF
      INPUT WORK.PW
      ECHO ON
      PRINT
      * verify
      GOSUB L22000.VERIFY.PW
    END
    IF NOT(PW.OK) THEN STOP
    PW.OK=FALSE
    IF PWREC="CBA":CTIME THEN
      SAVE.RESULT=RESP
    END ELSE
      GOSUB L23010.BUILD.PW
      SAVE.RESULT = USERPW
    END
    GOSUB L23010.BUILD.PW
    IF SAVE.RESULT = USERPW THEN
      WRITE USERPW ON CO.CONFIG,"PW.":USERNAME
      PW.OK=TRUE
    END ELSE
*      PRINT "Unable to verify password"
*      STOP
    END
    * get newpassword and get newpassword compare and save
    * if verify and able to save then set PW.OK=TRUE
  END ELSE
    WORK.PW=RESP
    * verify
    GOSUB L22000.VERIFY.PW
*    IF NOT(PW.OK) THEN STOP
  END
REPEAT
IF PW.PASS.CNT > 4 THEN STOP
IF NOT(PW.OK) THEN STOP
*
RETURN
*
L22000.VERIFY.PW:
*
*    decrypt pw
*
IF WORK.PW = PWREC<1> THEN
  PW.OK=TRUE
END
*
RETURN
*
L23010.BUILD.PW:
*  encrypt pw
*
PRINT "Enter your new Password :":
ECHO OFF
INPUT RESP
ECHO ON
PRINT
USERPW=RESP
*
*
RETURN
*
L24000.PROCESS.TEMPLATE:
*
ODATE=OCONV(DATE(),"D4/")
REC=CHANGE(REC,"%PGMNAME%",ITEM)
REC=CHANGE(REC,"%TODAY%",ODATE)
REC=CHANGE(REC,"%AUTHOR%",USERNAME)
REC=CHANGE(REC,"XXXBP",FNAME)
RETURN
*
L25000.CHECK.READ:
*
OPEN "",FNAME TO TEMPFNAME THEN
  READ REC FROM TEMPFNAME,ITEM THEN
    CHECK.READ=1
  END ELSE
    *This record is new in this file
25010 *
    VAL.RES=FALSE
    LOOP
    UNTIL VAL.RES DO
      PRINT 'This is a new record.  Continue Y/N' :
      INPUT YNRESP
      IF YNRESP = "Y" OR YNRESP = "N" THEN
        VAL.RES=TRUE
        IF YNRESP = 'Y' THEN
          READ.OK=1
          CHECK.READ = 1
        END ELSE
          READ.OK=0
        END
      END
    REPEAT
  END
END
RETURN
*
L26000.PROCESS.REVERT:
*
PRINT "You are about to undo any changes made to ":FNAME:" ":ITEM
PRINT "Is this what you want to do? YES/N:":
INPUT RESP
IF RESP # "YES" THEN 
  PRINT "No undo processed"
END ELSE
  OPEN READFNAME TO TEMPFILE THEN
    READ LOGF FROM CO.FILELOG,FNAME:"*":ITEM THEN
      DELETE CO.FILELOG,FNAME:"*":ITEM
    END
    READ LOGF FROM CO.FILE,FNAME:"*":ITEM THEN
      DELETE CO.FILE,FNAME:"*":ITEM
    END
    READ LOGF FROM TEMPFILE,ITEM THEN
      DELETE TEMPFILE,ITEM
    END
    LASTTWO = FNAME[LEN(FNAME)-1,2]
    IF LOGTO.CHECKIN = TRUE AND LASTTWO = "BP" THEN
      GOSUB L15400.PROCESS.REMOTE.COMPILE
    END ELSE
      IF LASTTWO ="BP" THEN
        GOSUB L15500.PROCESS.LOCAL.COMPILE
      END
    END
    PRINT "Complete Undo"
  END ELSE
    PRINT "Unable to proces Undo of changes"
  END
END
RETURN
*
L27000CKFNAME:
*
*
* THIS IS NOT A DEV CHECKOUT WITH CO. AS INPUT
ACCT=@WHO
READ TEMPITEM FROM VOC,FNAME THEN
  IF INDEX(TEMPITEM<2>,"/",1) THEN
    *there is a / in the second attr of this file ptr ... it is not a
    *  local file restrict access to view only
    RESTRICT.VIEW=TRUE
    *  determine if this is a checkout from a source file and a cpy
    *   to dev... for a mod or...
    IF OKNAME AND ((ACCT[1,3]="CBA" AND ACCT[5,3]='DEV') OR ACCT[1,4]='RND1' OR ACCT="CBA-REV12B") THEN
      * this acct appears to be a CBA-DEV account allow checkout
      READ TLOG FROM CO.FILELOG,FNAME:"*":ITEM THEN
        IF TLOG<A.LOG.USER> = USERNAME THEN
          READ TREC FROM CO.FILE,FNAME:"*":ITEM THEN 
            RESTRICT.VIEW=FALSE
          END
        END ELSE
          C.RESPONSE.OK=FALSE
          *   TURNED OFF FOR FURTHER TESTING TRUE
          * this is not the same user set user for view and warn
          MESG="This record is checked out by ":TLOG<A.LOG.USER>:", do you wish to View (Y/C/N)? :"
          PRINT @(0,22):CEOS:MESG:
          *
          GOSUB L10000.PROCESS.VIEW.RESPONSE
          IF RESP # 'Y' THEN STOP
          *
          C.RESPONSE.OK=FALSE
          *
        END
      END ELSE
        * most likely in a DEV account with a copy to the DEV.. file from
        *   the <module>... file
        PRINT @(0,23):CEOS:"Would you like to Copy ":FNAME:" ":ITEM:" to a Development file. (Y/N) :":
        INPUT RESP
        IF RESP[1,1]='Y' THEN 
          *  try a checkout
          RESTRICT.VIEW=FALSE
        END
      END
    END ELSE
      IF (ACCT[1,3]='CBA' AND OKNAME AND ACCT[5,3]#"REV") THEN
        * this is likely a client account
        *  check to see if the user wants to copy the item to a the local
        *  file first then check it out.
        LENFNAME=LEN(FNAME)
        BEGIN CASE
          CASE FNAME[LENFNAME-1,2]='BP'  ; FILETYPE='B'
          CASE FNAME[LENFNAME-4,5]='PROCS' ; FILETYPE='P'
          CASE FNAME[LENFNAME-6,7]='.CPYLIB' ; FILETYPE='C'
          CASE FNAME[LENFNAME-7,8]='.SCREENS' ; FILETYPE='S'
        END CASE
* CHECK TO SEE IF IT IS IN THE LOCAL FILE FIRST          
        DO.CPY=FALSE
        GOSUB L19000.SETUP.FNAME
        GOSUB L18000.CHECK.LCL.ITEM
*          
        PRINT @(0,23):CEOS:"Unable to edit the file ":FNAME:" in this account.  If this is a check out"
        PRINT "the file can be copied into the appropriate file for you.  Do you wish to do"
        PRINT "this.  (Y/N) :":
        INPUT RESP
        IF RESP[1,1] = 'Y' THEN
          *  set up the copy change FNAME to the custname and check if file
          *    is already on file if so warn the user and do nothing.  If
          *    not then copy the file and continue
          *
          DO.CPY=TRUE
          GOT.CO.PERMISSION=TRUE
          GOSUB L18000.CHECK.LCL.ITEM
        END ;* IF RESP[1,1] = 'Y..
      END ;* IF ACCT[1,3] = 'CBA'
      IF NOT(RESTRICT.VIEW) THEN
        OKNAME=FALSE
        GOSUB L16000.PROCESS.CUST.FILENAME
      END
    END ;* IF OKNAME AND ACCT ...
  END ELSE
    IF ACCT[1,7]='CBA-REV' AND NOT(ACCT="CBA-REV10A") THEN
      RESTRICT.VIEW=TRUE
    END 
    GOSUB L16000.PROCESS.CUST.FILENAME
  END ;* IF INDEX(TEMPITEM,"/....        
END ;* READ FROM VOC FNAME
*
IF NOT(RESTRICT.VIEW) THEN
  *compare orig to copy in co.file
  OFILENAME=FNAME
  GOSUB L17000.COMPARE.ITEMS
END
*
RETURN
