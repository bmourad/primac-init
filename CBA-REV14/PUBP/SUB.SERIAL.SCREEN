SUBROUTINE SUB.SERIAL.SCREEN(SER.LIST, NUM.SERS, START.ROW, NUM.TO.GET, NUM.PER.COL, PART.NUM, ALLOW.ADD, CONT.LBL, RESP)
*---------------------------------------------------------------------
* SUB.SERIAL.SCREEN provides a generic way to prompt for/display a list
* of serial numbers.
*
* INPUTS:
*
*    SER.LIST     =  Multi-valued list of serial numbers already entered
*    START.ROW    =  Starting row on screen (Used to display column hdgs)
*    NUM.TO.GET   =  Number of serials to prompt for (Zero=unlimited)
*    NUM.PER.COL  =  Number of entries allowed per column (Zero=whatever
*                    will fit between START.ROW and line 20)
*    PART.NUM     =  The part number which the serials represent. If non-
*                    null, each serial number is validated to ensure that
*                    it is a valid serial number for that part.
*    ALLOW.ADD    =  If PART.NUM non-null, can the user add serial numbers
*                    that are not found (TRUE/FALSE)
*    CONT.LBL     =  Label for 'Continue' prompt (i.e. "Print Label")
*                    If null, "Continue" is used
*
* OUTPUTS:
*
*    SER.LIST     =  Multi-valued list of serial numbers entered
*    NUM.SERS     =  Number of serial number returned
*    
*---------------------------------------------------------------------
$INCLUDE INCS GLOBAL.EQUATES
*---------------------
ERR = ''
PROMPT ''
IF (NUM.PER.COL + 0 = 0) OR (NUM.PER.COL + START.ROW > 20) THEN
  NUM.PER.COL = 20 - START.ROW + 1
END
NUM.COLS = NUM.TO.GET/NUM.PER.COL
IF NUM.COLS # INT(NUM.COLS) THEN NUM.COLS = NUM.COLS + 1
*
IF CONT.LBL = '' THEN CONT.LBL = "Continue"
*
PRINT @(04,START.ROW):
FOR C.NUM = 1 TO NUM.COLS
  PRINT "Serial Numbers....  ":
NEXT C.NUM
SER.LIST = ''
NUM.SERS = 1
R.NUM = 1
C.NUM = 1
*----
GET.SERS:
*----
LOOP
  SER.NDX = NUM.SERS
  GOSUB GET.ONE.SER
UNTIL SER.NUM = '' OR NUM.SERS = NUM.TO.GET DO
  NUM.SERS = NUM.SERS + 1
REPEAT
NUM.SERS = DCOUNT(SER.LIST,VM)
IF NUM.SERS < NUM.TO.GET THEN
  PRINT @(00,22):"Only ":NUM.SERS:" numbers were entered; Is this Correct (Y/N)?:":
  INPUT WAIT
  BEGIN CASE
    CASE WAIT # 'Y'
      NUM.SERS = DCOUNT(SER.LIST, VM)+1
      GOTO GET.SERS
    CASE WAIT = 'END'
      STOP
    CASE WAIT = 'TOP'
      RETURN
    CASE TRUE
  END CASE
END
*-----
CONFIRM.PR:
*-----
PRINT @(0,22):CLR.EOS:"Press 'RETURN' to ":CONT.LBL:" or Item Number to Change:":
INPUT WAIT
BEGIN CASE
  CASE RESP MATCHES "1N0N" AND RESP > 1 AND RESP <= NUM.SERS
    R.NUM = 0
    C.NUM = 1
    FOR I = 1 TO RESP
      R.NUM = R.NUM + 1
      IF R.NUM > NUM.PER.COL THEN C.NUM = C.NUM + 1;R.NUM = 1
    NEXT I
    SER.NDX = RESP
    GOSUB GET.ONE.SER
    GOTO CONFIRM.PR
  CASE TRUE
END CASE
RETURN
*-----
GET.ONE.SER:
*-----
PR = "Enter Serial Number"
GOSUB PROMPTER
SER.OK = TRUE
BEGIN CASE
  CASE RESP = 'END' OR RESP = 'TOP' OR RESP = ''
    SER.NUM = ''
  CASE RESP # '' AND SER.NDX # ''
    SER.NUM = RESP
    IF PART.NUM # '' THEN
      TT = OCONV(PART.NUM:"*":RESP, "TSER;X;0;0")
      IF TT = '' THEN
        IF ALLOW.ADD = FALSE THEN
          ERR = "'":RESP:"' is not a valid Serial Number for this Part"
          SER.OK = FALSE
        END ELSE
          ERR = "'":RESP:"' is not a valid Serial Number for this Part"
          PR = "Do you want to Add it to the Serial Master File (Y/N)?"
          GOSUB PROMPTER
          IF RESP[1,1] # 'Y' THEN SER.OK = FALSE
        END
      END
    END
    IF SER.OK = FALSE THEN
      GOTO GET.ONE.SER
    END ELSE
      PRINT @((C.NUM-1)*20,R.NUM+START.ROW):SER.NDX"R#2":') ':SER.NUM"L#14":
      PRINT @(15,04):NUM.SERS
      R.NUM = R.NUM + 1
      IF R.NUM > NUM.PER.COL THEN C.NUM = C.NUM + 1;R.NUM = 1
      SER.LIST<1,SER.NDX> = SER.NUM
    END
END CASE
RETURN
*-----
PROMPTER:
*-----
$INCLUDE INCS PROMPTER
