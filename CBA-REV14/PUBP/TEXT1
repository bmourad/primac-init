FIND.REPL
$INCLUDE INCS GLOBAL.EQUATES
*
*-----
GET.FNAME:
*-----
PRINT "Enter File Name       :":
INPUT FNAME
IF FNAME = '^' THEN STOP
IF FIELD(FNAME, ',', 2) # '' THEN DD = 'DATA' ELSE DD = ''
OPEN DD, FNAME TO FILEVAR ELSE
  PRINT BELL:"File not found"
  STOP
END
*-----
GET.FSTR:
*-----
PRINT "Enter Find String     :":
INPUT FSTR
IF FSTR = '^' THEN GOTO GET.FNAME
IF FSTR[1,2] = '0x' THEN
  FSTR = CHAR(FSTR[3,99])
END
LEN.FSTR = LEN(FSTR)
*-----
GET.RSTR:
*-----
PRINT "Enter Replace String  :":
INPUT RSTR
IF RSTR = '^' THEN GOTO GET.FSTR 
IF RSTR[1,2] = '0x' THEN
  RSTR = CHAR(RSTR[3,99])
END
*
SELECT FILEVAR
REC.COUNT = 0
HIT.COUNT = 0
DONE = FALSE
LOOP
  READNEXT ID ELSE DONE = TRUE
UNTIL DONE DO
  IF REM(REC.COUNT,100) = 0 THEN PRINT @(0,20):@(-3):REC.COUNT"R#7":" Records, ":HIT.COUNT"R#7":" Hits"
  REC.COUNT = REC.COUNT + 1
  REPL.FLAG = FALSE
  READ REC FROM FILEVAR, ID THEN
    LOOP
      TT = INDEX(REC, FSTR, 1)
    UNTIL TT = 0 DO
      T1 = REC[1,TT-1]
      T2 = REC[TT+LEN.FSTR,99999]
      REC = T1:RSTR:T2
      REPL.FLAG = TRUE
      HIT.COUNT = HIT.COUNT + 1
    REPEAT
    IF REPL.FLAG THEN WRITE REC ON FILEVAR, ID
  END
REPEAT
PRINT "Search Complete -- "
PRINT REC.COUNT"R#7":" Records,"
PRINT HIT.COUNT"R#7":" Occurences Replaced"
INPUT WAIT

INSTALL
$INCLUDE INCS GLOBAL.EQUATES
PROMPT ''
*
OPEN "INSTALL.LISTS" TO INSTALL.LISTS ELSE STOP
OPEN "INSTALL.LISTS,HISTORY" TO INSTALL.HISTORY ELSE STOP
START.ROW = 4
NUM.PER.COL = 15
*-----
START.LBL:
*-----
PRINT CLS:@(20,00):"-- Install Updates to Production Accounts --"
*-----
GET.LIST:
*-----
PRINT @(00,22):"Enter Install List Name or 'END':":
INPUT LIST.NAME
IF LIST.NAME = 'END' THEN STOP
READ LIST.REC FROM INSTALL.LISTS, LIST.NAME ELSE
  PRINT @(00,23):BELL:"'":LIST.NAME:"' is not a valid Install List"
  GOTO GET.LIST
END
ITEM.NDX = 1
GOSUB DISP.LIST
*-----
GET.CONT.FLAG:
*-----
PRINT @(00,22):CLR.EOL:"Enter 'INSTALL' to Proceed with Installation:":
INPUT CONT.FLAG
BEGIN CASE
  CASE CONT.FLAG = 'INSTALL'   ; GOSUB DO.INSTALL
  CASE CONT.FLAG = 'D'
     IF NEXT.ITEM.NDX # 0 THEN
       ITEM.NDX = NEXT.ITEM.NDX
       GOSUB DISP.LIST
     END ELSE
       PRINT @(00,23):BELL:"At end of list":
     END
     GOTO GET.CONT.FLAG
  CASE CONT.FLAG = 'U'
     IF START.ITEM.NDX # 1 THEN
       ITEM.NDX = START.ITEM.NDX - 45
       GOSUB DISP.LIST
     END ELSE
       PRINT @(00,23):BELL:"At start of list":
     END
     GOTO GET.CONT.FLAG
  CASE TRUE
END CASE
*
GOTO START.LBL
*-----
DISP.LIST:
*-----
PRINT @(00,02):CLR.EOS:"Installation List: ":LIST.NAME
NUM.ITEMS = DCOUNT(LIST.REC, AM)
NUM.COLS = NUM.ITEMS/NUM.PER.COL
IF NUM.COLS # INT(NUM.COLS) THEN NUM.COLS = NUM.COLS + 1
IF NUM.COLS > 3 THEN NUM.COLS = 3
PRINT @(00,START.ROW):
FOR C.NUM = 1 TO NUM.COLS
  PRINT "Install Item...........  ":
NEXT C.NUM
R.NUM = 1
C.NUM = 1
START.ITEM.NDX = ITEM.NDX
LOOP
  PRINT @((C.NUM-1)*25,R.NUM+START.ROW):ITEM.NDX"R#2":'. ':LIST.REC<ITEM.NDX>"L#19":
  R.NUM = R.NUM + 1
  IF R.NUM > NUM.PER.COL THEN C.NUM = C.NUM + 1;R.NUM = 1
UNTIL ITEM.NDX = NUM.ITEMS  OR C.NUM > 3 DO
  ITEM.NDX = ITEM.NDX + 1
REPEAT
IF ITEM.NDX < NUM.ITEMS THEN 
  PRINT @(50, 20):"       --- More ---"
  NEXT.ITEM.NDX = ITEM.NDX + 1
END
RETURN
*-----
DO.INSTALL:
*-----
 
RETURN

ITEMCOMP
$INCLUDE INCS GLOBAL.EQUATES
PRINT "Enter First File  :":
INPUT FN1
PRINT "Enter First Item  :":
INPUT IT1
PRINT "Enter Second File :":
INPUT FN2
PRINT "Enter First Item  :":
INPUT IT2
*-----
GET.FLAG:
*-----
PRINT "List (M)atches or (D)ifferences?:":
INPUT DIFF.FLAG
IF DIFF.FLAG # 'D' AND DIFF.FLAG # 'M' THEN
  PRINT BELL:"Invalid Response"
  GOTO GET.FLAG
END
IF DIFF.FLAG = 'D' THEN DIFF.FLAG = TRUE ELSE DIFF.FLAG = FALSE
OPEN FN1 TO F1 ELSE
  PRINT BELL:"Unable to Open ":FN1
  STOP
END
OPEN FN2 TO F2 ELSE
  PRINT BELL:"Unable to Open ":FN2
  STOP
END
SELECT F1
DONE = FALSE
REC.COUNT = 0
REC.COUNT = 0
HIT.LIST = ''
HIT.COUNT = 0
DONE = FALSE
LOOP
  READNEXT ID ELSE DONE = TRUE
UNTIL DONE DO
  IF REM(REC.COUNT,100) = 0 THEN PRINT @(0,20):@(-3):REC.COUNT"R#7":" Records, ":HIT.COUNT"R#7":" Hits"
  REC.COUNT = REC.COUNT + 1
  READ REC1 FROM F1, IT1 ELSE REC1 = ''
  READ REC2 FROM F2, IT2 ELSE REC2 = ''
  IF REC1 # REC2 THEN
    DIFF = TRUE
S.ATTR = 1
    IF DIFF = DIFF.FLAG THEN GOSUB FIND.DIFF.ATTRS
  END ELSE
    DIFF = FALSE
  END
  IF DIFF = DIFF.FLAG THEN
    HIT.LIST<-1> = ID
    HIT.COUNT = HIT.COUNT + 1
  END
REPEAT
PRINT "Compare Complete -- "
PRINT REC.COUNT"R#7":" Records,"
PRINT HIT.COUNT"R#7":" Mismatches"
WRITE HIT.LIST ON F1, "@@@ID@@@"
EXECUTE "QSELECT ":FN1:" @@@ID@@@"
EXECUTE "SAVE-LIST COMP@":FN1:"@":FN2
DELETE F1, "@@@ID@@@"
STOP
*----
FIND.DIFF.ATTRS:
*----
NUM.ATTRS = DCOUNT(REC1, AM)
FOR I = S.ATTR TO S.ATTR+20 UNTIL I > NUM.ATTRS
  PRINT I"R#3":" ":REC1<I>"L#35":" ! ":REC2<I>"L#35"
NEXT I
INPUT WAIT
BEGIN CASE
  CASE WAIT = 'N'
    S.ATTR = S.ATTR + 20
  CASE WAIT = 'P'
    S.ATTR =S.ATTR - 20
    IF S.ATTR < 1 THEN S.ATTR = 1
  CASE TRUE
END CASE
GOTO FIND.DIFF.ATTRS
RETURN

MOVE.AT.TO.AT
$INCLUDE INCS GLOBAL.EQUATES
PRINT "Enter First File  :":
INPUT FN1
PRINT "Enter Attribute # :":
INPUT A1
PRINT "Enter Second File :":
INPUT FN2
PRINT "Enter Attribute # :":
INPUT A2
OPEN FN1 TO F1 ELSE
  PRINT BELL:"Unable to Open ":FN1
  STOP
END
IF FN1 # FN2 THEN
  OPEN FN2 TO F2 ELSE
    PRINT BELL:"Unable to Open ":FN2
    STOP
  END
END
SELECT F1
DONE = FALSE
REC.COUNT = 0
HIT.LIST = ''
HIT.COUNT = 0
DONE = FALSE
LOOP
  READNEXT ID ELSE DONE = TRUE
UNTIL DONE DO
  IF REM(REC.COUNT,100) = 0 THEN PRINT @(0,20):@(-3):REC.COUNT"R#7":" Records, ":HIT.COUNT"R#7":" Hits"
  REC.COUNT = REC.COUNT + 1
  READ REC1 FROM F1, ID ELSE REC1 = ''
  IF FN1 # FN2 THEN
    READ REC2 FROM F2, ID ELSE REC2 = ''
    REC2<A2> = REC1<A1>
    WRITE REC2 ON F2, ID
  END ELSE
    REC1<A2> = REC1<A1>
    WRITE REC1 ON F1, ID
  END
REPEAT
PRINT "Move Complete -- "
PRINT REC.COUNT"R#7":" Records,"
STOP

PW.MAINT
$INCLUDE INCS GLOBAL.EQUATES
*
OPEN "PWS" TO PW.FILE ELSE STOP
*
*-----
10 *
*-----
PRINT @(0,22):CLR.EOL:"Enter Verb/Menu Name:":
INPUT RESP
IF RESP = '' OR RESP = 'END' OR RESP = 'TOP' THEN STOP
TT1 = OCONV(RESP, "TMD;X;1;1")
TT2 = OCONV(RESP, "TMENUS;X;0;0")
IF TT1 = 'PQ' OR TT2 # '' THEN
  PW = RESP
  GOSUB 20
END ELSE
  PRINT @(0,23):"'":RESP:"' is not a valid Verb/Menu Name":
END
GOTO 10
*-----
20 *
*-----
PRINT @(00,22):CLR.EOL:'Enter Password:':
INPUT RESP
BEGIN CASE
  CASE RESP = 'DELETE' ; GOSUB 30
  CASE RESP = '' 
    PRINT BELL:@(0,23):"Password is required":
    GOTO 20
  CASE TRUE
    RESP = OCONV(RESP, 'MX')
    READU PW.REC FROM PW.FILE, PW ELSE PW.REC = ''
    LOCATE(RESP, PW.REC, 1;P.POS) ELSE PW.REC<1,-1> = RESP
    WRITE PW.REC ON PW.FILE, PW
END CASE
RETURN
*-----
30 *
*-----
PRINT @(00,22):CLR.EOL:'Enter Password to delete:':
INPUT RESP
IF RESP # '' THEN
  READU PW.REC FROM PW.FILE, PW ELSE PW.REC = ''
  RESP = OCONV(RESP, "MX")
  LOCATE(RESP, PW.REC, 1;P.POS) THEN
    PW.REC = DELETE(PW.REC, 1, P.POS)
    WRITE PW.REC ON PW.FILE, PW
  END ELSE
    PRINT BELL:@(0,23):"Password not Found":
    GOTO 30
  END
END
RETURN

SEARCH
$INCLUDE INCS GLOBAL.EQUATES
*
*-----
GET.FNAME:
*-----
PRINT "Enter File to Search:":
INPUT FNAME
IF FNAME = '^' THEN STOP
IF FIELD(FNAME, ',', 2) # '' THEN DD = 'DATA' ELSE DD = ''
OPEN DD, FNAME TO FILEVAR ELSE
  PRINT BELL:"File not found"
  STOP
END
PRINT "Enter Search String :":
INPUT STRING
IF STRING = '^' THEN GOTO GET.FNAME
SRCH.LIST = ''
NUM.SRCH = DCOUNT(STRING, '\')
FOR I = 1 TO NUM.SRCH
  TT = FIELD(STRING,'\',I)
  IF TT[1,2] = '0x' THEN
    TT = CHAR(TT[3,99])
  END
  SRCH.LIST<-1> = TT
NEXT I
*
SELECT FILEVAR
REC.COUNT = 0
HIT.LIST = ''
HIT.COUNT = 0
DONE = FALSE
LOOP
  READNEXT ID ELSE DONE = TRUE
UNTIL DONE DO
  IF REM(REC.COUNT,100) = 0 THEN PRINT @(0,20):@(-3):REC.COUNT"R#7":" Records, ":HIT.COUNT"R#7":" Hits"
  REC.COUNT = REC.COUNT + 1
  READ REC FROM FILEVAR, ID THEN
    HIT = TRUE
    FOR I = 1 TO NUM.SRCH
      TT = INDEX(REC, SRCH.LIST<I>, 1)
      IF TT = 0 THEN HIT = FALSE
    NEXT I
    IF HIT THEN
      HIT.LIST<-1> = ID
      HIT.COUNT = HIT.COUNT + 1
    END
  END
REPEAT
PRINT "Search Complete -- "
PRINT REC.COUNT"R#7":" Records,"
PRINT HIT.COUNT"R#7":" Hits"
IF HIT.LIST # '' THEN
  WRITE HIT.LIST ON FILEVAR, "@@@ID@@@"
  EXECUTE "QSELECT ":FNAME:" @@@ID@@@"
  EXECUTE "SAVE-LIST SEARCH@":FNAME
  DELETE FILEVAR, "@@@ID@@@"
  CHAIN "GET-LIST SEARCH@":FNAME
END

SETUP.ED.LOG
$INCLUDE INCS GLOBAL.EQUATES
*----------
LOG.VERB = "PQ":AM:"HRUN BPS CHECKOUT (E":AM:"STON":AM:"A1,999":AM:"P"
*----------
OPEN "MD" TO MD ELSE STOP
VLIST = "ED":AM:"EDIT":AM:"JE":AM:"JED":AM:"JET-EDIT"
FOR I = 1 TO DCOUNT(VLIST,AM)
  READU VERB FROM MD, VLIST<I> THEN
    IF VERB<1> = 'PE' OR VERB<1> = 'P' THEN
      WRITE VERB ON MD, VLIST<I>:".."
      WRITE LOG.VERB ON MD, VLIST<I>
    END
  END ELSE
    RELEASE MD, VLIST<I>
  END
NEXT I

STUFF.VAL.TO.AT
$INCLUDE INCS GLOBAL.EQUATES
PRINT "Enter File        :":
INPUT FN
PRINT "Enter Attribute # :":
INPUT A
PRINT "Enter Stuff Value :":
INPUT SVAL
PRINT "Enter Validation  :":
INPUT VVAL
OPEN FN TO F ELSE
  PRINT BELL:"Unable to Open ":FN
  STOP
END
SELECT F
DONE = FALSE
REC.COUNT = 0
HIT.COUNT = 0
DONE = FALSE
LOOP
  READNEXT ID ELSE DONE = TRUE
UNTIL DONE DO
  IF REM(REC.COUNT,100) = 0 THEN PRINT @(0,20):@(-3):REC.COUNT"R#7":" Records, ":HIT.COUNT"R#7":" Hits"
  REC.COUNT = REC.COUNT + 1
  READ REC FROM F, ID ELSE REC = ''
  HIT = TRUE
  IF VVAL # '' AND REC<A> # VVAL THEN HIT = FALSE
  IF HIT THEN
    REC<A> = SVAL
    WRITE REC ON F, ID
    HIT.COUNT = HIT.COUNT + 1
  END
REPEAT
PRINT "Stuff Complete -- "
PRINT REC.COUNT"R#7":" Records,"
PRINT HIT.COUNT"R#7":" Updates"
STOP

SUB.SERIAL.SCREEN
SUBROUTINE SUB.SERIAL.SCREEN(SER.LIST, NUM.SERS, START.ROW, NUM.TO.GET, NUM.PER.COL, PART.NUM, ALLOW.ADD, CONT.LBL, RESP)
*---------------------------------------------------------------------
* SUB.SERIAL.SCREEN provides a generic way to prompt for/display a list
* of serial numbers.
*
* INPUTS:
*
*    SER.LIST     =  Multi-valued list of serial numbers already entered
*    START.ROW    =  Starting row on screen (Used to display column hdgs)
*    NUM.TO.GET   =  Number of serials to prompt for (Zero=unlimited)
*    NUM.PER.COL  =  Number of entries allowed per column (Zero=whatever
*                    will fit between START.ROW and line 20)
*    PART.NUM     =  The part number which the serials represent. If non-
*                    null, each serial number is validated to ensure that
*                    it is a valid serial number for that part.
*    ALLOW.ADD    =  If PART.NUM non-null, can the user add serial numbers
*                    that are not found (TRUE/FALSE)
*    CONT.LBL     =  Label for 'Continue' prompt (i.e. "Print Label")
*                    If null, "Continue" is used
*
* OUTPUTS:
*
*    SER.LIST     =  Multi-valued list of serial numbers entered
*    NUM.SERS     =  Number of serial number returned
*    
*---------------------------------------------------------------------
$INCLUDE INCS GLOBAL.EQUATES
*---------------------
ERR = ''
PROMPT ''
IF (NUM.PER.COL + 0 = 0) OR (NUM.PER.COL + START.ROW > 20) THEN
  NUM.PER.COL = 20 - START.ROW + 1
END
NUM.COLS = NUM.TO.GET/NUM.PER.COL
IF NUM.COLS # INT(NUM.COLS) THEN NUM.COLS = NUM.COLS + 1
*
IF CONT.LBL = '' THEN CONT.LBL = "Continue"
*
PRINT @(04,START.ROW):
FOR C.NUM = 1 TO NUM.COLS
  PRINT "Serial Numbers....  ":
NEXT C.NUM
SER.LIST = ''
NUM.SERS = 1
R.NUM = 1
C.NUM = 1
*----
GET.SERS:
*----
LOOP
  SER.NDX = NUM.SERS
  GOSUB GET.ONE.SER
UNTIL SER.NUM = '' OR NUM.SERS = NUM.TO.GET DO
  NUM.SERS = NUM.SERS + 1
REPEAT
NUM.SERS = DCOUNT(SER.LIST,VM)
IF NUM.SERS < NUM.TO.GET THEN
  PRINT @(00,22):"Only ":NUM.SERS:" numbers were entered; Is this Correct (Y/N)?:":
  INPUT WAIT
  BEGIN CASE
    CASE WAIT # 'Y'
      NUM.SERS = DCOUNT(SER.LIST, VM)+1
      GOTO GET.SERS
    CASE WAIT = 'END'
      STOP
    CASE WAIT = 'TOP'
      RETURN
    CASE TRUE
  END CASE
END
*-----
CONFIRM.PR:
*-----
PRINT @(0,22):CLR.EOS:"Press 'RETURN' to ":CONT.LBL:" or Item Number to Change:":
INPUT WAIT
BEGIN CASE
  CASE RESP MATCHES "1N0N" AND RESP > 1 AND RESP <= NUM.SERS
    R.NUM = 0
    C.NUM = 1
    FOR I = 1 TO RESP
      R.NUM = R.NUM + 1
      IF R.NUM > NUM.PER.COL THEN C.NUM = C.NUM + 1;R.NUM = 1
    NEXT I
    SER.NDX = RESP
    GOSUB GET.ONE.SER
    GOTO CONFIRM.PR
  CASE TRUE
END CASE
RETURN
*-----
GET.ONE.SER:
*-----
PR = "Enter Serial Number"
GOSUB PROMPTER
SER.OK = TRUE
BEGIN CASE
  CASE RESP = 'END' OR RESP = 'TOP' OR RESP = ''
    SER.NUM = ''
  CASE RESP # '' AND SER.NDX # ''
    SER.NUM = RESP
    IF PART.NUM # '' THEN
      TT = OCONV(PART.NUM:"*":RESP, "TSER;X;0;0")
      IF TT = '' THEN
        IF ALLOW.ADD = FALSE THEN
          ERR = "'":RESP:"' is not a valid Serial Number for this Part"
          SER.OK = FALSE
        END ELSE
          ERR = "'":RESP:"' is not a valid Serial Number for this Part"
          PR = "Do you want to Add it to the Serial Master File (Y/N)?"
          GOSUB PROMPTER
          IF RESP[1,1] # 'Y' THEN SER.OK = FALSE
        END
      END
    END
    IF SER.OK = FALSE THEN
      GOTO GET.ONE.SER
    END ELSE
      PRINT @((C.NUM-1)*20,R.NUM+START.ROW):SER.NDX"R#2":') ':SER.NUM"L#14":
      PRINT @(15,04):NUM.SERS
      R.NUM = R.NUM + 1
      IF R.NUM > NUM.PER.COL THEN C.NUM = C.NUM + 1;R.NUM = 1
      SER.LIST<1,SER.NDX> = SER.NUM
    END
END CASE
RETURN
*-----
PROMPTER:
*-----
$INCLUDE INCS PROMPTER

UPLOAD.CV.FILES
$INCLUDE INCS GLOBAL.EQUATES
PCCMD = CHAR(27):CHAR(8)
ENDCMD = CHAR(0)
*
PRINT "Enter File List Key":
INPUT KEY
OPEN "CV.FILES" TO CV.FILES ELSE STOP
READ PK.FILES FROM CV.FILES, "PK.FILES@":KEY ELSE STOP
READ PC.FILES FROM CV.FILES, "PC.FILES@":KEY ELSE STOP
*
NUM.FILES = DCOUNT(PK.FILES, AM)
FOR I = 1 TO NUM.FILES
*  TT = "CREATE-FILE CV.FILES,":PK.FILES<I>:" 11,1"
*  PRINT TT
*  EXECUTE TT
  PC.FN = PC.FILES<I>
  PK.FN = PK.FILES<I>
  GOSUB UPLOAD.FILE
NEXT I
STOP
*-----
UPLOAD.FILE:
*-----
TT = "KEY /P <ALT+F>E":PC.FN:" (.TXT)<TAB>":PK.FN:"<TAB>#<TAB>*"
TT = TT:"<TAB>O F44 R10<TAB><CR><ALT> N<ALT> R"
PRINT TT
PRINT PCCMD:TT:ENDCMD:
EXECUTE "PCCTRL"
RETURN

