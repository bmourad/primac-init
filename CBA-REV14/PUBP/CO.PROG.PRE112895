*
EQU VM TO CHAR(253)
EQU AM TO CHAR(254)
EQU SVM TO CHAR(252)
EQU TRUE TO 1
EQU FALSE TO 0
EQU BELL TO CHAR(7) 
EQU CEOL TO @(-4)
EQU CLR TO @(-1)
EQU CEOS TO @(-3)
*
*  def of last edit rec from CO.CONFIG record LAST.EDIT.<username>
*
EQU LE.DATE    TO 1
EQU LE.TIME    TO 2
EQU LE.FILE    TO 3
EQU LE.ITEM    TO 4
EQU LE.REAL.FNAME TO 5
*
EQU A.LOG.USER    TO 1
EQU A.LOG.DATE    TO 2
EQU A.LOG.TIME    TO 3
EQU A.LOG.T.C.NUM TO 4
EQU A.LOG.REASON  TO 5 
*
ERRMSG=''
FNAME="CO.FILE"
OPEN "",FNAME TO CO.FILE ELSE 
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="CO.WORK"
OPEN "",FNAME TO CO.WORK ELSE 
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="CO.CONFIG"
OPEN "",FNAME TO CO.CONFIG ELSE 
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="CO.FILELOG"
OPEN "",FNAME TO CO.FILELOG ELSE 
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="DEVBP"
OPEN "DEVBP" TO DEVBP ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="DEV.SCREENS"
OPEN "DEV.SCREENS" TO DEV.SCREENS ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="DEVPROCS"
OPEN "DEVPROCS" TO DEVPROCS ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
FNAME="DEV.CPYLIB"
OPEN FNAME TO DEV.CPYLIB ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
FNAME="VOC"
OPEN FNAME TO VOC ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
FNAME="CO.ARCHIVE"
OPEN FNAME TO CO.ARCHIVE ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
FNAME="CSF.TRACK"
OPEN FNAME TO CSF.TRACK ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
FNAME="TASK"
OPEN FNAME TO TASK ELSE
  IF ERRMSG='' THEN
    ERRMSG = "NO ":FNAME:" FILE"
  END ELSE
    ERRMSG = ERRMSG:" ":"NO ":FNAME:" FILE"
  END
END
*
*
*
*
USERNAME = @LOGNAME
*PRINT "DEBUG AT BEGIN YN":
*INPUT RESPO
*IF RESPO = "Y" THEN DEBUG
PORT = @TTY
CTIME=TIME()
OTIME=OCONV(CTIME,"MTHS")
CDATE=DATE()
ODATE=OCONV(CDATE,"D4/")
COMMENT.STR="*"
ITEM=''
ITEMLIST=''
IN.DEV.ACCT=FALSE
LOGTO.CHECKIN=FALSE
*
PROMPT ' '
*
IF ERRMSG # "" THEN
  PRINT @(0,23):CEOS:ERRMSG
  PRINT 'Enter "RETURN":':
  INPUT XX
  STOP
END
*
PROCREAD CMD ELSE 
  PRINT @(0,23):CEOS:'Command not run correctly use "CO".  Enter "RETURN":':
  INPUT XX
  STOP
END
NUMCMDS = DCOUNT(CMD,AM)
IF NOT(CMD<1> = "CO" OR CMD<1> = "CO." OR CMD<1> = "COT") THEN
  PRINT @(0,23):CEOS:'Command not run correctly use "CO".  Enter "RETURN":':
  INPUT XX
  STOP
END
IF NUMCMDS = 1 AND CMD<1> # 'CO.' THEN
  GOSUB L1000.DISPLAY.HELP
  STOP
END
READ BPFILE.LIST FROM CO.CONFIG,"BPFILE.LIST" ELSE
  XX="APSBP":VM:"ARSBP":VM:"CBABP":VM:"CNVBP":VM:"EP4BP":VM:"EPSBP":VM:"FASBP"
  XX=XX:VM:"GLSBP":VM:"ICSBP":VM:"JCSBP":VM:"JESBP":VM:"NDCBP":VM:"OPSBP"
  XX=XX:VM:"PMCBP":VM:"POSBP":VM:"PR4BP":VM:"PRSBP":VM:"PSSBP":VM:"QPLBP"
  XX=XX:VM:"SASBP":VM:"UTLBP"
  WRITE XX ON CO.CONFIG,"BPFILE.LIST"
  BPFILE.LIST=XX
END
FILE.LIST = BPFILE.LIST
READ PROCFILE.LIST FROM CO.CONFIG,"PROCFILE.LIST" ELSE
  XX="APSPROCS":VM:"ARSPROCS":VM:"CBAPROCS":VM:"CNVPROCS":VM:"EP4PROCS"
  XX=XX:VM:"EPSPROCS":VM:"FASPROCS":VM:"GLSPROCS":VM:"ICSPROCS":VM:"JCSPROCS"
  XX=XX:VM:"JESPROCS":VM:"NDCPROCS":VM:"OPSPROCS":VM:"PMCPROCS":VM:"POSPROCS"
  XX=XX:VM:"PR4PROCS":VM:"PRSPROCS":VM:"PSSPROCS":VM:"QPLPROCS":VM:"SASPROCS"
  XX=XX:VM:"UTLPROCS"
  WRITE XX ON CO.CONFIG,"PROCFILE.LIST"
  PROCFILE.LIST=XX
END
NUMAM = DCOUNT(PROCFILE.LIST,VM)
FOR I = 1 TO NUMAM
  LOCATE PROCFILE.LIST<1,I> IN FILE.LIST<1>,1 BY "AL" SETTING POS ELSE
    FILE.LIST = INSERT(FILE.LIST,1,POS;PROCFILE.LIST<1,I>)
  END
NEXT I
READ SCREENFILE.LIST FROM CO.CONFIG,"SCREEENFILE.LIST" ELSE
  XX="APS.SCREENS":VM:"ARS.SCREENS":VM:"CBA.SCREENS":VM:"CNV.SCREENS"
  XX=XX:VM:"EP4.SCREENS":VM:"EPS.SCREENS":VM:"FAS.SCREENS":VM:"GLS.SCREENS"
  XX=XX:VM:"ICS.SCREENS":VM:"JCS.SCREENS":VM:"JES.SCREENS":VM:"NDC.SCREENS"
  XX=XX:VM:"OPS.SCREENS":VM:"PMC.SCREENS":VM:"POS.SCREENS":VM:"PR4.SCREENS"
  XX=XX:VM:"PRS.SCREENS":VM:"PSS.SCREENS":VM:"QPL.SCREENS":VM:"SAS.SCREENS"
  XX=XX:VM:"UTL.SCREENS"
  WRITE XX ON CO.CONFIG,"SCREENFILE.LIST"
  SCREENFILE.LIST=XX
END
NUMAM = DCOUNT(SCREENFILE.LIST,VM)
FOR I = 1 TO NUMAM
  LOCATE SCREENFILE.LIST<1,I> IN FILE.LIST<1>,1 BY "AL" SETTING POS ELSE
    FILE.LIST = INSERT(FILE.LIST,1,POS;SCREENFILE.LIST<1,I>)
  END
NEXT I
READ CPYLIBFILE.LIST FROM CO.CONFIG,"CPYLIBFILE.LIST" ELSE
  XX="APS.CPYLIB":VM:"ARS.CPYLIB":VM:"CBA.CPYLIB":VM:"CNV.CPYLIB":VM:"EP4.CPYLIB"
  XX=XX:VM:"EPS.CPYLIB":VM:"FAS.CPYLIB":VM:"GLS.CPYLIB":VM:"ICS.CPYLIB":VM:"JCS.CPYLIB"
  XX=XX:VM:"JES.CPYLIB":VM:"NDC.CPYLIB":VM:"OPS.CPYLIB":VM:"PMC.CPYLIB":VM:"POS.CPYLIB"
  XX=XX:VM:"PR4.CPYLIB":VM:"PRS.CPYLIB":VM:"PSS.CPYLIB":VM:"QPL.CPYLIB":VM:"SAS.CPYLIB"
  XX=XX:VM:"UTL.CPYLIB"     
  WRITE XX ON CO.CONFIG,"CPYLIBFILE.LIST"
  CPYLIBFILE.LIST=XX
END
NUMAM = DCOUNT(CPYLIBFILE.LIST,VM)
FOR I = 1 TO NUMAM
  LOCATE CPYLIBFILE.LIST<1,I> IN FILE.LIST<1>,1 BY "AL" SETTING POS ELSE
    FILE.LIST = INSERT(FILE.LIST,1,POS;CPYLIBFILE.LIST<1,I>)
  END
NEXT I
READ DEV.ACCT.LIST FROM CO.CONFIG,"DEV.ACCT.LIST" ELSE
  DEV.ACCT.LIST="CBA-DEV10A"
  WRITE DEV.ACCT.LIST ON CO.CONFIG,"DEV.ACCT.LIST"
END
*
BAIL.NOW=0
IF CMD<NUMCMDS>[1,1] = "(" THEN
  * pick options and continue
  OPTIONS = CMD<NUMCMDS>[2,99]
  NUMOPT = DCOUNT(OPTIONS,",")
  FOR OCTR = 1 TO NUMOPT
    CURROPT=FIELD(OPTIONS,",",OCTR)
    BEGIN CASE
      CASE CURROPT = "C"
        GOSUB L3000.PROCESS.C.OPT
    END CASE
  NEXT OCTR
  NUMCMDS=NUMCMDS-1
END
IF BAIL.NOW THEN STOP
*
GOSUB L2000.GET.EDITOR
*
IF BAIL.NOW THEN STOP
*
DO.CHECKIN=FALSE
ITEMLIST=''
IF NUMCMDS >= 2 OR CMD<1> = 'CO../' THEN
  IF CMD<1> = 'CO../' THEN
    READ LAST.EDIT.REC FROM CO.CONFIG,"LAST.EDIT.":USERNAME THEN
      FNAME = LAST.EDIT.REC<LE.FILE>
      ITEM = LAST.EDIT.REC<LE.ITEM>
      IF FNAME = "" THEN GOSUB L6000.GET.FNAME
      IF FNAME # 'X' THEN 
        IF ITEM = '' THEN GOSUB L5000.GET.ITEM
      END
      ITEMLIST=ITEM
    END ELSE
      * last edit unknown 
      LAST.EDIT.REC=''
      GOSUB L6000.GET.FNAME
      ITEM=''
      IF FNAME # 'X' THEN
        GOSUB L5000.GET.ITEM
      END
      LAST.EDIT.REC<LE.REAL.FNAME>=FNAME
    END
    READFNAME=FNAME
    OFILENAME=LAST.EDIT.REC<LE.REAL.FNAME>
    *
    GOSUB L17000.COMPARE.ITEMS
    *
    PRINT "Do you wish to check this pgm in now? (YES/N<cr>) :":
    INPUT RESP
    IF RESP = 'YES' THEN
      DO.CHECKIN=TRUE
    END ELSE
      ITEMLIST=ITEM
    END
  END ELSE
    PART2 = CMD<2>
    *  the thing here is that PART2 could be an ED,AE,ED+ or fname
    IF PART2 = "ED" OR PART2 = "AE" OR PART2 = "ED+" THEN
      EDITOR.OF.CHOICE = PART2
      IF CMD<3> # "" THEN
        FNAME = CMD<3>
        ITEMLIST=''
        FOR II = 4 TO NUMCMDS
          ITEMLIST<-1>=CMD<II>
          ITEM=ITEMLIST<1>
        NEXT II
      END ELSE
        GOSUB L6000.GET.FNAME
        IF FNAME # "X" THEN
          GOSUB L5000.GET.ITEM
        END
      END
    END ELSE
      * PART 2 IS FILE NAME AND BEYOND IS ITEMLIST
      FNAME=CMD<2>
      ITEMLIST=''
      ITEM=''
      FOR II = 3 TO NUMCMDS
        ITEMLIST<-1> = CMD<II>
        ITEM=ITEMLIST<1>
      NEXT II
    END
    IF FNAME # "X" AND FNAME # "" THEN
      IF ITEMLIST = '' AND ITEM = '' THEN
        DONE = 0
        LOOP
          READNEXT ID ELSE DONE=1
        UNTIL DONE DO
          ITEMLIST<-1> = ID
          ITEM=ID
        REPEAT
      END
    END
    IF FNAME = '' OR FNAME = 'X' OR ITEM='' THEN
      * this is where we bail
      STOP
    END
    IF ITEMLIST = '' AND ITEM # "" THEN
      ITEMLIST=ITEM
    END
    * handle get last item and start edit
    OFILENAME=FNAME
  END
  GOSUB L4000.PROCESS.ITEMLIST
END
STOP
*
L1000.DISPLAY.HELP: *
*
PRINT @(0,23):
PRINT "The Check Out Utility 'CO' will check program and proc file items out"
PRINT " the syntax for CO is "
PRINT "   CO {ED,AE,ED+} <filename> {<itemname> <itemname>} {(C}"
PRINT "   where {ED,AE,ED+} is the editor if different than your config editor"
PRINT "   where <filename> - is the filename (REQUIRED)"
PRINT "   where {<itemname> <itemname>} - is the items to edit."
PRINT "     if itemname is not specified and a list is active then, items in the"
PRINT "     list will be edited, if no list is active and no item specified"
PRINT "     you will be prompted for an itemname"
PRINT "   where (C is to setup or change the perferred setup          "
PRINT
PRINT " To specify which Editor for each user enter use the '(C' option"
PRINT "  you will be prompted for editor choice."
PRINT
*PRINT "CO. will also be supported where the last item edited will be recalled"
PRINT
PRINT 'Enter "RETURN":':
INPUT XX
RETURN
*
L2000.GET.EDITOR: *
*
READ EDITOR.OF.CHOICE FROM CO.CONFIG,"EDITOR.":USERNAME ELSE
  GOSUB L3000.PROCESS.C.OPT
END
RETURN
*
L3000.PROCESS.C.OPT: *
*
BAIL.NOW=0
LOOP
  VAL.CHOICE=1
  PRINT @(0,23):CEOS:"Choose editor, 1)AE, 2)ED, 3)ED+ or 'X' to Exit :":
  INPUT CHOICE
  BEGIN CASE 
    CASE CHOICE='1'
      EDITOR.OF.CHOICE="AE"
    CASE CHOICE='2'
      EDITOR.OF.CHOICE="ED"
    CASE CHOICE='3'
      EDITOR.OF.CHOICE="ED+"
    CASE CHOICE='X'
      BAIL.NOW=1
    CASE 1
      VAL.CHOICE=0
  END CASE
UNTIL VAL.CHOICE DO
REPEAT
IF NOT(BAIL.NOW) THEN
  WRITE EDITOR.OF.CHOICE ON CO.CONFIG,"EDITOR.":USERNAME
END
*
RETURN
*
*
L4000.PROCESS.ITEMLIST: *
*
IF DO.CHECKIN THEN
  ITEM=ITEMLIST<1,1>
  GOSUB L15000.DO.CHECKIN.NOW
END ELSE
  NUM.ITEMS =DCOUNT(ITEMLIST,AM)
  FOR IPTR = 1 TO NUM.ITEMS
    ITEM=ITEMLIST<IPTR>
    GOSUB L7000.CHECK.FNAME
    VERB = EDITOR.OF.CHOICE:" ":READFNAME:" ":ITEM
*    PRINT VERB
*    INPUT WAIT
    IF READFNAME = "CO.WORK" THEN
      READ ORIG.REC FROM CO.WORK,ITEM ELSE ORIG.REC=''
      PRINT @(0,23):CEOS:"This edit session is view only.  Enter 'RETURN' :":
      INPUT RESP
    END
    IF READFNAME # "" AND ITEM # "" THEN
      UDTEXECUTE VERB
      IF READFNAME = "CO.WORK" THEN
        READ CHG.REC FROM CO.WORK,ITEM ELSE CHG.REC=''
        IF ORIG.REC # CHG.REC THEN
          *  the record has been changed in the view only editor.  let the user
          *   know and continue
          PRINT @(0,23):CEOS:"The record just edited was changed.  The changes will not"
          PRINT "be saved due to the edit session being view only.  Enter 'RETURN':":
          INPUT RESP
        END
        DELETE CO.WORK,ITEM
      END ELSE
        *  check for changes while away
        GOSUB L17000.COMPARE.ITEMS
        PRINT @(0,23):CEOS:
        PRINT "Do you wish to check this pgm in now? (YES/N<cr>) :":
        INPUT RESP
        IF RESP = 'YES' THEN
          GOSUB L15000.DO.CHECKIN.NOW
        END ELSE
          LRF = LEN(READFNAME)
          IF READFNAME[LRF-1,2] = 'BP' THEN
            PRINT @(0,23):CEOS:"Do you wish to compile this program (Y/N<cr>) :":
            INPUT RESP
            OPTIONS = "{U (D"
            IF RESP = 'Y' THEN
* REMOVE PROMPT BELOW FOR COMPILE OPTIONS IT IS IN DEV MODE JUST USE EM
*
*              PRINT 'Do you want any options (eg {U (D ...) (Y/N<cr>) :': 
*              INPUT RESP
*              IF RESP='Y' THEN
*                PRINT 'Enter Options   :':
*                INPUT OPTIONS
*              END ELSE
*                OPTIONS=''
*              END
*
              VERB = "PBASIC ":READFNAME:" ":ITEM:" ":OPTIONS
              PRINT VERB
              PERFORM VERB
              * CAPTURING JUNK
              JUNK=''
              IF JUNK # "" THEN
                NUM.LINES=DCOUNT(JUNK,AM)
                FOR II = 1 TO NUM.LINES
                  PRINT JUNK<II>
                NEXT II
              END
            END
          END
        END
      END
    END
*    PRINT "BACK FROM ":VERB
*    INPUT WAIT
  NEXT IPTR
END
RETURN
*
L5000.GET.ITEM: *
MSG="Enter Item Name "
PRINT @(0,23):CEOS:MSG:
INPUT ITEM
*
RETURN
*
L6000.GET.FNAME: *
MSG="Enter File Name "
PRINT @(0,23):CEOS:MSG
INPUT FNAME
*
RETURN
*
L7000.CHECK.FNAME: *
* this routine will determine if the file is in the to be checked out from
*  list or if normal editing can continue
*   if the fname is in the to be checkd out list then make sure pgm is
*    not already checkd out
*    if it is warn user prompt for view permission and do the view
*    if it is not ask the user if they want to check it out y - do the ck out
*      n-do the view
*
READFNAME='' ; FTYPE=''
*
*
LOGTO.CHECKIN=FALSE
IN.DEV.ACCT=FALSE
RESTRICT.VIEW=FALSE
SPECIAL.NAME=FALSE
*
*
NUM.DEV.ACCTS=DCOUNT(DEV.ACCT.LIST,AM)
ACCT=@WHO
FOR I = 1 TO NUM.DEV.ACCTS
  IF DEV.ACCT.LIST<I> = ACCT THEN
    IN.DEV.ACCT=TRUE
    LOGTO.CHECKIN=TRUE
  END
NEXT I
IF (FNAME = "DEVBP" OR FNAME="DEVPROCS" OR FNAME="DEV.SCREENS" OR FNAME="DEV.CPYLIB") AND CMD<1> # "CO." THEN
  * only allow this if the user is in a dev account
  IF IN.DEV.ACCT THEN
    PRINT "Unable to check out for ":FNAME
    STOP
  END
END
FTYPE=''
OKNAME=0
LOCATE FNAME IN FILE.LIST<1>,1 SETTING POS THEN
  OKNAME = 1
END
SKIPCHECKOUT=0
IF (FNAME = "DEVBP" OR FNAME="DEVPROCS" OR FNAME="DEV.SCREENS" OR FNAME="DEV.CPYLIB") AND CMD<1> = "CO." THEN
  OKNAME=1
  BEGIN CASE
    CASE FNAME='DEVBP'
      FTYPE='B' ; CMTSTR="*" ; READFNAME="DEVBP"
    CASE FNAME='DEVPROCS'
      FTYPE='P' ; CMTSTR="C" ; READFNAME="DEVPROCS"
    CASE FNAME="DEV.SCREENS"
      FTYPE='S' ; CMTSTR='*' ;READFNAME="DEV.SCREENS"
    CASE FNAME="DEV.CPYLIB"
      FTYPE='C' ; CMTSTR="*" ;READNAME="DEV.CPYLIB"
  END CASE
  SKIPCHECKOUT=1
END
*
*  make sure that file being worked upon is local to this account
*
IF FNAME # READFNAME THEN
  * THIS IS NOT A DEV CHECKOUT WITH CO. AS INPUT
  ACCT=@WHO
  READ TEMPITEM FROM VOC,FNAME THEN
    IF INDEX(TEMPITEM<2>,"/",1) THEN
      *there is a / in the second attr of this file ptr ... it is not a
      *  local file restrict access to view only
      RESTRICT.VIEW=TRUE
      *  determine if this is a checkout from a source file and a cpy
      *   to dev... for a mod or...
      IF OKNAME AND ACCT[1,3]="CBA" AND ACCT[5,3]='DEV' THEN
        * this acct appears to be a CBA-DEV account allow checkout
        READ TLOG FROM CO.FILELOG,FNAME:"*":ITEM THEN
          IF TLOG<A.LOG.USER> = USERNAME THEN
            READ TREC FROM CO.FILE,FNAME:"*":ITEM THEN 
              RESTRICT.VIEW=FALSE
            END
          END
        END ELSE
          * most likely in a DEV account with a copy to the DEV.. file from
          *   the <module>... file
          PRINT @(0,23):CEOS:"Would you like to Copy ":FNAME:" ":ITEM:" to a Development file. (Y/N) :":
          INPUT RESP
          IF RESP[1,1]='Y' THEN 
            *  try a checkout
            RESTRICT.VIEW=FALSE
          END
        END
      END ELSE
        IF ACCT[1,3]='CBA' AND OKNAME AND ACCT[5,3]#"REV" THEN
          * this is likely a client account
          *  check to see if the user wants to copy the item to a the local
          *  file first then check it out.
          LENFNAME=LEN(FNAME)
          BEGIN CASE
            CASE FNAME[LENFNAME-1,2]='BP'  ; FILETYPE='B'
            CASE FNAME[LENFNAME-4,5]='PROCS' ; FILETYPE='P'
            CASE FNAME[LENFNAME-6,7]='.CPYLIB' ; FILETYPE='C'
            CASE FNAME[LENFNAME-7,8]='.SCREENS' ; FILETYPE='S'
          END CASE
          PRINT @(0,23):CEOS:"Unable to edit the file ":FNAME:" in this account.  If this is a check out"
          PRINT "the file can be copied into the appropriate file for you.  Do you wish to do"
          PRINT "this.  (Y/N) :":
          INPUT RESP
          IF RESP[1,1] = 'Y' THEN
            *  set up the copy change FNAME to the custname and check if file
            *    is already on file if so warn the user and do nothing.  If
            *    not then copy the file and continue
            *
            ORIGFNAME=FNAME
            CUSTNAME=FIELD(ACCT,"-",2)
            LEN.CUST=LEN(CUSTNAME)
            READ CUST.NAMES FROM CO.CONFIG,"CUST.NAMES" THEN
              NUM.CUST=DCOUNT(CUST.NAMES,AM)
              FND.CUST=FALSE
              FOR I = 1 TO NUM.CUST WHILE NOT(FND.CUST)
                IF CUSTNAME = CUST.NAMES<I,1> THEN
                  FND.CUST=TRUE
                  TMPNAME=CUST.NAMES<I,2>
                END
              NEXT I
              IF FND.CUST THEN
                LEN.CUST=LEN(TMPNAME)
                CUSTNAME=TMPNAME
              END
            END
            *  build fname
            *
            BEGIN CASE 
              CASE FILETYPE='B'
                FNAME=CUSTNAME:"BP"
              CASE FILETYPE='C'
                FNAME=CUSTNAME:".CPYLIB"
              CASE FILETYPE='P'
                FNAME=CUSTNAME:"PROCS"
              CASE FILETYPE='S'
                FNAME=CUSTNAME:'.SCREENS'
            END CASE
            READ TREC FROM VOC,FNAME THEN
              IF NOT(INDEX(TREC<2>,"/",1)) THEN
                * this is a local file 
                OPEN FNAME TO TEMPFILENAME THEN
                  READ TITEM FROM TEMPFILENAME,ITEM THEN
                    *  this is a problem the item already exists warn the user
                    * and stop
                    PRINT @(0,23):CEOS:"The item ":ITEM:" already exists in the file ":FNAME
                    PRINT "Check it out from there."
                    STOP
                  END ELSE
                    OPEN ORIGFNAME TO ORIGTEMPFILENAME THEN
                      READ TREC FROM ORIGTEMPFILENAME,ITEM THEN
                        WRITE TREC ON TEMPFILENAME,ITEM
                        RESTRICT.VIEW=FALSE
                      END ELSE
                        PRINT @(0,23):CEOS:"The item ":ITEM:" is not on file in the file ":ORIGFNAME
                        STOP
                      END
                    END ;* OPEN ORIGFNAME....
                  END ;* READ TITEM ....
                END ;* OPEN FNAME....
              END ;* IF NOT(INDEX,"/...  
            END  ;* READ TREC FROM VOC..          
          END ;* IF RESP[1,1] = 'Y..
        END ;* IF ACCT[1,3] = 'CBA'
        IF NOT(RESTRICT.VIEW) THEN
          OKNAME=FALSE
          GOSUB L16000.PROCESS.CUST.FILENAME
        END
      END ;* IF OKNAME AND ACCT ...
    END ELSE
      IF ACCT[1,7]='CBA-REV' THEN
        RESTRICT.VIEW=TRUE
      END 
      GOSUB L16000.PROCESS.CUST.FILENAME
    END ;* IF INDEX(TEMPITEM,"/....        
  END ;* READ FROM VOC FNAME
*
  IF NOT(RESTRICT.VIEW) THEN
    *compare orig to copy in co.file
    OFILENAME=FNAME
    GOSUB L17000.COMPARE.ITEMS
  END
END ;* IF FNAME # READNAME    
*
IF OKNAME THEN
  * the fname is in the check out list
  *
  IF FTYPE = '' THEN
    FTYPE='B' ; CMTSTR="*" ; READFNAME='DEVBP'
  END
  LOCATE FNAME IN BPFILE.LIST<1>,1 SETTING POS THEN
    FTYPE='B' ; CMTSTR= "*" ; READFNAME="DEVBP"
  END ELSE    
    LOCATE FNAME IN PROCFILE.LIST<1>,1 SETTING POS THEN
      FTYPE='P' ; CMTSTR="C" ; READFNAME="DEVPROCS"
    END ELSE
      LOCATE FNAME IN SCREENFILE.LIST<1>,1 SETTING POS THEN
        FTYPE='S' ; CMTSTR='*' ;READFNAME="DEV.SCREENS"
      END ELSE
        LOCATE FNAME IN CPYLIBFILE.LIST<1>,1 SETTING POS THEN
          FTYPE='C' ; CMTSTR='*' ; READFNAME="DEV.CPYLIB"
        END
      END
    END
  END
  IF NOT(SKIPCHECKOUT) THEN
    IF RESTRICT.VIEW THEN
      * the user only gets access through the view facility
      * working on the process of read only files and useraccess restricted
      * to viewing the pgm without update capibilities.
      *
      GOSUB L11000.PROCESS.VIEW.READ
      *
    END ELSE
      *
      GOSUB L9000.PROCESS.READ
      *
    END  ;* RESTRICT VIEW 
  END ;* SKP CHK OUT
END ELSE
  GOSUB L11000.PROCESS.VIEW.READ
END
RETURN
*
*
L8000.PRINT.SDIFF: *
*
* expects TEMFILENAME to contain the original file from checkout
*         ITEM to be the item name that was checked out
XX=''
XX<1>='PQN'
XX<-1>="HSDIFF"
XX<-1>="STON"
XX<-1>="HCO.FILE<"
XX<-1>="H":TEMFILENAME:"*":ITEM:"<"
XX<-1>="H":TEMFILENAME:"<"
XX<-1>="H":ITEM:"<"
XX<-1>="HS<"
XX<-1>="P"
WRITE XX ON VOC,"TEMPVOCITEM"
UDTEXECUTE "TEMPVOCITEM"
DELETE VOC,"TEMPVOCITEM"
*
RETURN
*
*
*
L9000.PROCESS.READ: *
*
READ REC FROM CO.FILE,FNAME:"*":ITEM THEN
  *  this pgm is in the check out copy file
  * determine if this is the same user
  READ LOGREC FROM CO.FILELOG,FNAME:"*":ITEM THEN
    IF LOGREC<A.LOG.USER>=USERNAME THEN
      * this is the same user set readfname and return
*      READFNAME=LOGREC<A.LOG.FILE>
    END ELSE
      * this is not the same user set user for view and warn
      MESG="This record is checked out by ":LOGREC<A.LOG.USER>:", do you wish to View (Y/N)? :"
      PRINT @(0,23):CEOS:MESG:
      *
      GOSUB L10000.PROCESS.VIEW.RESPONSE
      *
    END
  END ELSE
    * error condition not filelog to go with co.file record
    *create again with appoligy
    PRINT "Error with Check Out utility.  The Orig version of the item Checked"
    PRINT "Out is in the file but the log of the check out is missing.  Do you"
    PRINT "wish to continue.  C-Continue this will force another checkout, or"
    PRINT "A-Abort.  (C/A) :":
    VAL.RESP=0
    LOOP
    UNTIL VAL.RESP DO
      INPUT RESP
      IF RESP='A' OR RESP='C' THEN
        VAL.RESP=TRUE
      END ELSE
      END
    REPEAT
    IF RESP='A' THEN STOP 
  END
END ELSE 
  * not checked out find out if they want to check it out and buile
  * filelog
  PRINT "Do you wish to check out this item (Y/N) :":
  VAL.RESP=0
  LOOP
  UNTIL VAL.RESP DO
    INPUT RESP
    IF RESP='Y' OR RESP='N' THEN
      VAL.RESP=TRUE
      IF RESP='N' THEN
        MESG="Do you wish to View (Y/N)? :"
        PRINT @(0,23):CEOS:MESG:
        *
        GOSUB L10000.PROCESS.VIEW.RESPONSE
        *
      END ELSE
        *
        GOSUB L13000.DO.CHECK.OUT
        *
      END
    END
  REPEAT
END
*
RETURN
*
*
L10000.PROCESS.VIEW.RESPONSE: *
*
INPUT RESP
BEGIN CASE
  CASE RESP[1,1]='Y'
    GOSUB L11000.PROCESS.VIEW.READ ; *
  CASE RESP[1,1]#'Y'
    READFNAME=''
END CASE
*
RETURN
*
*
L11000.PROCESS.VIEW.READ: *
*
READFNAME = "CO.WORK"
OPEN "",FNAME TO TEMPFNAME THEN
  READ REC FROM TEMPFNAME,ITEM ELSE REC=''
  REC=INSERT(REC,1;"TMP CK OUT ":CDATE:" ":CTIME)
  WRITE REC ON CO.WORK,ITEM
END ELSE
  * error condition the file in fname could not be opened
  PRINT @(0,23):CEOS:FNAME:" could not be opened.  Enter 'RETURN' :":
  INPUT RESP
  READFNAME=''
END
*
RETURN
*
*
L12000.CHECK.SPEC.FNAME: *
*
BEGIN CASE
  CASE LPART='BP'
    FTYPE='B' ; CMTSTR="*" ; READFNAME="DEVBP"
  CASE LPART='PROCS'
    FTYPE='P' ; CMTSTR="C" ; READFNAME="DEVPROCS"
  CASE LPART=".SCREENS"
    FTYPE='S' ; CMTSTR='*' ;READFNAME="DEV.SCREENS"
  CASE LPART=".CPYLIB"
    FTYPE='C' ; CMTSTR="*" ;READNAME="DEV.CPYLIB"
END CASE
IF FTYPE = '' THEN
  * this edit is not for <client>bp,<client>procs... but is for
  *  <client>LPART and this is not a checkout file
  PRINT "This is not a file for the CheckOut Utility."
  STOP
END
OKNAME=TRUE
RESTRICT.VIEW=FALSE
SPECIAL.NAME=TRUE
RETURN
*
*
L13000.DO.CHECK.OUT:
*
* this part will check out the pgm from the check out file location and
*  flag it as checked out so no one else can edit it.  Information needed
*  is task or csf ; number ; reason ; 
*
REASON='' ; C.OR.T = '' ; TNUMBER=''
DO.BAIL=0
VALID.RESPONSE=FALSE
LOOP
UNTIL VALID.RESPONSE DO
  IF IN.DEV.ACCT THEN
    PRINT @(0,23):CEOS:"Enter T-Task :":
    C.OR.T = 'T'
  END ELSE
    PRINT @(0,23):CEOS:"Enter C-CSF or T-Task (C/T) :":
    INPUT C.OR.T
  END
  IF C.OR.T = 'C' OR C.OR.T = 'T' THEN
    IF NOT(IN.DEV.ACCT) THEN
      VALID.RESPONSE = TRUE
    END ELSE
      IF C.OR.T = 'C' THEN
        PRINT @(0,23):BELL:"CSF is not allowed in Dev/Release accounts"
      END ELSE
        VALID.RESPONSE=TRUE
      END
    END
  END ELSE
    IF C.OR.T = '^' OR C.OR.T=CHAR(27) THEN
      DO.BAIL=1
      VALID.RESPONSE=TRUE
    END ELSE
      PRINT @(0,23):BELL:C.OR.T:" is not a Valid response try 'C' or 'T'.  Enter 'RETURN'":
      INPUT XX
      PRINT @(0,23):CEOS:
    END
  END
REPEAT
IF DO.BAIL THEN RETURN
IF C.OR.T='T' THEN IS.TASK=TRUE ELSE IS.TASK=FALSE
VALID.RESPONSE=FALSE
LOOP
UNTIL VALID.RESPONSE DO
  IF IS.TASK THEN
    PRINT @(0,23):"Enter the number associated with this Task :":
  END ELSE
    PRINT @(0,23):"Enter the number associated with this CSF :":
  END
  INPUT TNUMBER
  IF TNUMBER#"" AND NUM(TNUMBER) THEN
    IF IS.TASK THEN
      READ TTREC FROM TASK,TNUMBER THEN
        VALID.RESPONSE=TRUE
      END ELSE
        PRINT @(0,23):CEOS:BELL:TNUMBER:" is not a valid task number"
      END
    END ELSE
      READ TTREC FROM CSF.TRACK,TNUMBER THEN
        VALID.RESPONSE=TRUE
      END ELSE
        PRINT @(0,23):CEOS:BELL:TNUMBER:" is not a valid CSF number"
      END
    END
  END ELSE
    IF TNUMBER = '^' OR TNUMBER=CHAR(27) THEN
      DO.BAIL=1
      VALID.RESPONSE=TRUE
    END ELSE
      PRINT @(0,23):BELL:TNUMBER:" is not a Valid response.  Enter 'RETURN'":
      INPUT XX
      PRINT @(0,23):CEOS:
    END
  END
REPEAT
IF DO.BAIL THEN RETURN
VALID.RESPONSE=FALSE
REASON.STR=''
PRINT @(0,23):CEOS:"Enter reason,  conclude reason with 'END' on a line by itself"
LOOP
UNTIL VALID.RESPONSE DO
  PRINT ":":
  INPUT REASON
  REASON=TRIM(REASON)
  IF REASON#"" AND REASON#"^" AND REASON#CHAR(27) THEN
    IF REASON = "END" THEN
      IF REASON.STR= "" THEN
        PRINT "Need some text for a reason..."
      END ELSE
        VALID.RESPONSE=TRUE
      END
    END ELSE
      IF REASON.STR # "" THEN
        REASON.STR=REASON.STR:" ":REASON
      END ELSE
        REASON.STR=REASON
      END
    END
  END ELSE
    IF REASON = '^' OR REASON=CHAR(27) THEN
      DO.BAIL=1
      VALID.RESPONSE=TRUE
    END ELSE
      PRINT @(0,23):BELL:REASON:" is not a Valid response.  Enter 'RETURN'":
      INPUT XX
      PRINT @(0,23):CEOS:
    END
  END
REPEAT
IF DO.BAIL THEN RETURN
* at this point REASON, TNUMBER, and C.OR.T are setup
* also from above FNAME and ITEM and USERNAME are setup
* setup record in lock file, copy record to hold location and update
*  pgm with new comment and copy into dev file.
SVCMT=''
OPEN FNAME TO TEMPFNAME THEN
  READ REC FROM TEMPFNAME,ITEM THEN
    GOSUB L14000.PROCESS.CKOUT
  END ELSE
    * THERE IS NO REC BY THIS NAME
    PRINT "No item exists by this name ":ITEM:" in the file ":FNAME
    PRINT "Do you wish to check it out still (Y/N) :":
    INPUT RES
    IF RES='Y' THEN
      IF FNAME[LEN(FNAME)-1,2] = "BP" THEN
        READ REC FROM CO.CONFIG,"NEW.REC.TEMPLATE" ELSE REC=''
      END ELSE
        REC=''
      END
      GOSUB L14000.PROCESS.CKOUT
    END
  END
END ELSE
  ERR="UNABLE TO OPEN ":FNAME
  PRINT ERR
  STOP
END
RETURN        
*
L14000.PROCESS.CKOUT:
*
ADDVAL = CMTSTR:C.OR.T:TNUMBER:" ":USERNAME:" ":ODATE:" * "
TEMPSTR=ADDVAL
LEN.ADD = LEN(ADDVAL)
ORIG.REC=REC
COMMENT.SPACE = 73 - LEN.ADD
COMMENT.FILL= LEN.ADD
IF LEN(REASON.STR) < COMMENT.SPACE THEN
  ADDVAL = ADDVAL:REASON.STR
  NUMADD = 1
END ELSE
  NUM.WORD=DCOUNT(REASON.STR," ")
  NEW.COMMENT='' ; TCOMMT='' ; WCOMMT='' 
  FOR I = 1 TO NUM.WORD
    CURRWORD = FIELD(REASON.STR," ",I)
    IF TCOMMT = "" THEN
      TCOMMT = CURRWORD
    END ELSE
      TCOMMT = TCOMMT:" ":CURRWORD
    END
    IF LEN(TCOMMT) < COMMENT.SPACE THEN
      WCOMMT = TCOMMT
    END ELSE
      IF NEW.COMMENT = '' THEN
        NEW.COMMENT = WCOMMT
      END ELSE
        NEW.COMMENT<-1> = WCOMMT
      END
      WCOMMT = ''
      TCOMMT=CURRWORD
    END
  NEXT I
  IF WCOMMT # "" THEN
    IF NEW.COMMENT = '' THEN
      NEW.COMMENT = WCOMMT
    END ELSE
      NEW.COMMENT<-1> = WCOMMT
    END
  END ELSE
    IF TCOMMT # "" THEN
      IF NEW.COMMENT = "" THEN
        NEW.COMMENT = TCOMMT
      END ELSE
        NEW.COMMENT<-1>=TCOMMT
      END
    END
  END
  NUMADD = DCOUNT(NEW.COMMENT,AM)
  ADDVAL = NEW.COMMENT
END
* determine insert line
*
STPLOOP=FALSE
NUMITMLINES=DCOUNT(REC,AM)
FOUNDCOM=FALSE ; FOUNDCOPY=FALSE
HOLDPTR=2
LEN.FNAME=LEN(FNAME)
IF FNAME[LEN.FNAME-1,2] = 'BP' THEN
  FOR II = 2 TO NUMITMLINES WHILE NOT(STPLOOP)
    IF II > 150 THEN
      *  did nt find a place to insert then use line 2
      STPLOOP=TRUE
    END ELSE
      IF REC<II>[1,6]="*COPY>" THEN
        LASTWORD=TRIM(FIELD(REC<II>,">",3))
        IF INDEX(LASTWORD,"COM",1) THEN
          * this is likely a common stmt found a common mark it and continue
          HOLDPTR=II
          FOUNDCOM=TRUE
        END ELSE
          IF FOUNDCOM OR FOUNDCOPY THEN 
            * this is the first line past the common stmts and is not a common
            STPLOOP=TRUE
          END ELSE
            * this is a copy stmt not common found yet continue
          END
        END 
        FOUNDCOPY=TRUE
      END ELSE
        IF FOUNDCOM OR FOUNDCOPY THEN
          * this is the first line past a found common or cpylib
          *  and should escape here
          STPLOOP=TRUE
        END
      END
    END
  NEXT II
  PART1=FALSE
  IF FOUNDCOM OR FOUNDCOPY OR STPLOOP OR TRUE THEN
    STPLOOP=FALSE
    FOR II = 2 TO 150 WHILE NOT(STPLOOP)
      IF TRIM(REC<II>[1,7]) = "*ENDDOC" THEN
        HOLDPTR=II-1
        IF HOLDPTR < 2 THEN HOLDPTR=2
        STPLOOP=TRUE
        FOUNDCOM=TRUE
      END ELSE
        IF INDEX(REC<II>,"DESCRIPTION",1) OR PART1 THEN
          IF NOT(PART1) THEN
            PART1=TRUE
          END ELSE
            IF INDEX(REC<II>,"****************************",1) THEN
              HOLDPTR=II-1
              IF HOLDPTR < 2 THEN HOLDPTR=2
              STPLOOP=TRUE
              FOUNDCOM=TRUE
            END
          END
        END
      END
    NEXT II
  END
END
*
IF FOUNDCOM THEN
  HOLDPTR=HOLDPTR+1
END
FOR I = NUMADD TO 1 STEP (-1)
  IF I > 1 THEN
    CURRVAL = CMTSTR:SPACE(COMMENT.FILL-1):ADDVAL<I>
  END ELSE
    IF NUMADD > 1 THEN
      ADDVAL<I> = TEMPSTR:ADDVAL<I>
    END
    CURRVAL = ADDVAL<I>
  END
  REC = INSERT(REC,HOLDPTR;CURRVAL)
  IF SVCMT = '' THEN
    SVCMT=ADDVAL<I>
  END ELSE
    SVCMT=ADDVAL<I>:" ":SVCMT
  END
NEXT I
BEGIN CASE
  CASE FTYPE='B'
    WRITE REC ON DEVBP, ITEM
    READFNAME='DEVBP'
  CASE FTYPE='P'
    WRITE REC ON DEVPROCS, ITEM
    READFNAME='DEVPROCS'
  CASE FTYPE='S'
    WRITE REC ON DEV.SCREENS,ITEM
    READFNAME='DEV.SCREENS'
  CASE FTYPE='C'
    WRITE REC ON DEV.CPYLIB,ITEM
    READFNAME='DEV.CPYLIB'
END CASE
WRITE ORIG.REC ON CO.FILE,FNAME:"*":ITEM
LER=''
LER<LE.DATE>=CDATE
LER<LE.TIME>=CTIME
LER<LE.FILE>=READFNAME
LER<LE.ITEM>=ITEM
LER<LE.REAL.FNAME>=FNAME
LOGF=''
LOGF<A.LOG.USER> = USERNAME
LOGF<A.LOG.DATE> = CDATE
LOGF<A.LOG.TIME> = CTIME
LOGF<A.LOG.T.C.NUM>=C.OR.T:TNUMBER
LOGF<A.LOG.REASON>=SVCMT    
WRITE LER ON CO.CONFIG,"LAST.EDIT.":USERNAME
WRITE LOGF ON CO.FILELOG,FNAME:"*":ITEM
*
RETURN
*
L15000.DO.CHECKIN.NOW: *
*
CTIME=TIME()
OTIME=OCONV(CTIME,"MTHS")
CDATE=DATE()
ODATE=OCONV(CDATE,"D4/")
OPEN READFNAME TO TEMPFILE THEN
  READ REC FROM TEMPFILE,ITEM THEN
    OPEN FNAME TO TEMP2FILE THEN
      WRITE REC ON TEMP2FILE,ITEM
      READ LOGF FROM CO.FILELOG,FNAME:"*":ITEM ELSE LOGF="UNK"
      WRITE LOGF ON CO.FILELOG,FNAME:"*":ITEM:"*":CDATE:"*":CTIME
      DELETE CO.FILELOG,FNAME:"*":ITEM
      DELETE CO.CONFIG,"LAST.EDIT.":USERNAME
      DELETE TEMPFILE,ITEM
      READ TTREC FROM CO.FILE,FNAME:"*":ITEM THEN
        WRITE TTREC ON CO.ARCHIVE,FNAME:"*":ITEM:"*":ODATE:"*":OTIME
      END
      DELETE CO.FILE,FNAME:"*":ITEM
      LASTTWO = FNAME[LEN(FNAME)-1,2]
      IF LOGTO.CHECKIN = TRUE AND LASTTWO = "BP" THEN
        GOSUB L15400.PROCESS.REMOTE.COMPILE
      END ELSE
        GOSUB L15500.PROCESS.LOCAL.COMPILE
      END
    END
  END
END
RETURN
*
L15400.PROCESS.REMOTE.COMPILE: *
*
READ TMD FROM VOC,FNAME THEN
  PATHDATA = TMD<2>
  NUM.SEPS=DCOUNT(PATHDATA,"/")
  NUM.SEPS=NUM.SEPS-1
  NPATHDATA=''
  FOR PTS = 1 TO NUM.SEPS
    IF PTS=1 THEN
      NPATHDATA=FIELD(PATHDATA,"/",1)
    END ELSE
      NPATHDATA=NPATHDATA:"/":FIELD(PATHDATA,"/",PTS)
    END
  NEXT PTS
* THIS IS A DEBUG LOCATION
*PRINT 'DO DEBUG YN':
*INPUT RESPO
*IF RESPO='Y' THEN DEBUG
  VERB = "LOGTO ":NPATHDATA
  MDREC="PQN"
  MDREC<-1>="X"
  CURR.LOC = @PATH
  TEMPQPTR='F'
  TEMPQPTR<-1>=NPATHDATA:"/VOC"
  TEMPQPTR<-1>=NPATHDATA:"/D_VOC"
  WRITE TEMPQPTR ON VOC,"CHKIN.PTR"
  OPEN "CHKIN.PTR" TO REMOTE.VOC THEN
    READ REMOTE.LOGIN FROM REMOTE.VOC,"LOGIN" THEN
      WRITE MDREC ON REMOTE.VOC,"LOGIN"
      PRINT "Logto ":NPATHDATA:" for PBASIC"
      UDTEXECUTE VERB CAPTURING JUNK
      VERB = "PBASIC ":FNAME:" ":ITEM
      PRINT "Performing PBASIC"
      UDTEXECUTE VERB CAPTURING JUNK
      PRINT JUNK
      PRINT "Logging back"
      VERB = "LOGTO ":CURR.LOC
      UDTEXECUTE VERB CAPTURING JUNK
      WRITE REMOTE.LOGIN ON REMOTE.VOC,"LOGIN"
      DELETE VOC,"CHKIN.PTR"
      OPEN "SAVEDLISTS" TO SAVEDLISTS THEN
        WRITE ITEM ON SAVEDLISTS,"CHKIN.ITEM000"
        TPROC="PQN"
        TPROC<-1>="HCLEAR.LOCAL.PTR"
        TPROC<-1>="STON"
        TPROC<-1>="HCHKIN.ITEM<"
        TPROC<-1>="P"
        PRINT "Running CLEAR.LOCAL.PTR program to clean up MDs"
        WRITE TPROC ON VOC, "CHKIN.PQ"
        UDTEXECUTE "CHKIN.PQ" CAPTURING JUNK
        DELETE VOC,"CHKIN.PQ"
      END
    END
  END
END
*
RETURN
*
L15500.PROCESS.LOCAL.COMPILE: *
*
VERB = "PBASIC ":FNAME:" ":ITEM
UDTEXECUTE VERB CAPTURING JUNK
PRINT JUNK
*
RETURN
*
L16000.PROCESS.CUST.FILENAME: *
*
IF NOT(OKNAME) THEN
  * check here for customer name files
  RESTRICT.VIEW=TRUE
  IF INDEX(ACCT,"-",1) AND FIELD(ACCT,"-",1)="CBA" THEN
    * the customername is here get it
    CUSTNAME=FIELD(ACCT,"-",2)
    LEN.CUST=LEN(CUSTNAME)
    IF FNAME[1,LEN.CUST] = CUSTNAME THEN
      * check last part to see if it is bp,proc,screen,cpylib
      LPART=FNAME[LEN.CUST+1,99]
      GOSUB L12000.CHECK.SPEC.FNAME
    END ELSE
      * this is a checkout attemp and the custname does not equal the
      *  CBA-<cust> name of the account.   See if it is in the Cust
      *  table 
      READ CUST.NAMES FROM CO.CONFIG,"CUST.NAMES" THEN
        NUM.CUST=DCOUNT(CUST.NAMES,AM)
        FND.CUST=FALSE
        FOR I = 1 TO NUM.CUST WHILE NOT(FND.CUST)
          IF CUSTNAME = CUST.NAMES<I,1> THEN
            FND.CUST=TRUE
            TMPNAME=CUST.NAMES<I,2>
          END
        NEXT I
        IF FND.CUST THEN
          LENTMP=LEN(TMPNAME)
          LPART=FNAME[LENTMP+1,99]
          GOSUB L12000.CHECK.SPEC.FNAME
        END
      END ELSE
        * unable to read item from co.config CUST.NAMES 
      END
    END
  END ELSE    
    * this is not a CBA account and not a l
    PRINT "Only use the Check Out utility in CBA accounts."
    STOP
  END
END ELSE
  IF INDEX(ACCT,"-",1) AND FIELD(ACCT,"-",1)="CBA" THEN
    * this is a CBA account ok to check out here
  END ELSE
    PRINT "Only use the Check Out utility in CBA accounts."
    STOP
  END
END ;* IF OKNAME   this is a file in the filelist      
*
RETURN
*
*
L17000.COMPARE.ITEMS:
*
READ TEMP1 FROM CO.FILE,OFILENAME:"*":ITEM THEN
  OPEN OFILENAME TO TEMPFNAME THEN
    READ TEMP2 FROM TEMPFNAME, ITEM THEN
      IF LEN(TEMP1) = LEN(TEMP2) THEN
        * these items are the same number of bytes
      END ELSE
        VALRES=FALSE
        LOOP 
        WHILE NOT(VALRES) DO
          PRINT "The original record from ":FNAME:" has changed"
          PRINT "  since it was checked out.  Manually determine difference."
          PRINT "  X-Exit , I-Ignore, S-Sdiff:":
          INPUT RESP
          IF RESP = 'X' THEN VALRES=1
          IF RESP = 'I' THEN VALRES=1
          IF RESP = 'S' THEN
            TEMFILENAME=OFILENAME
            GOSUB L8000.PRINT.SDIFF
            VALRES=1
          END
        REPEAT
        IF RESP='X' THEN STOP
      END
    END ELSE
      * readfail on original record
    END
  END ELSE
    * open fail on file to check out from
  END
END ELSE
  * read fail of checked out copy
END
*
RETURN
