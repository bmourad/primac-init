SUBROUTINE ROC.MAIN(ROC.CMD, OBJNAME, ATTR, VALS, OPTIONS, ERR)
*
** SBClient Host 3GL API
** Copyright (C) Ardent Software Inc. 1998
** Copyright (C) UniData, Inc. 1996, 1997
** Copyright (C) System Builder Corporation. 1995
**
**      This software is the proprietary property and contains
**      trade secrets of Ardent Software, Inc. Any unauthorized use,
**      disclosure or duplication is strictly prohibited.
**      All rights reserved.
*
*
* Description : Main Interface For 3GL Library
*
 INCLUDE TUBP USER.INCLUDE.H
 INCLUDE TUBP TU.API.H
 INCLUDE TUBP SPECIAL.H
 INCLUDE TUBP ROC.MAIN.H
 INCLUDE TUBP OS.DELAY.H
 INCLUDE TUBP TU.ERRORCODES.H
*
DEBUGMODE = FALSE; ZZSTR = ''
IF INDEX(OPTIONS, 'D', 1) THEN DEBUGMODE = TRUE
*
OPEN '','TUSTATE' TO TUSTATE ELSE
ERR = FTE.TUSTATE.OPEN.ERROR
RETURN
END
OPEN '','TUCONFIG' TO F.TUCONFIG ELSE
ERR = FTE.TUCONFIG.OPEN.ERROR
RETURN
END
*
READV MAX.CMD.LEN FROM F.TUCONFIG, 'FT.TRIGGER', 1 ELSE MAX.CMD.LEN = 0
IF MAX.CMD.LEN < 512 OR NOT(NUM(MAX.CMD.LEN)) THEN
MAX.CMD.LEN = 512
END
READ PAD.PACKETS FROM TUSTATE, 'PAD*':ACCTNAME:'*':PORTNO ELSE PAD.PACKETS = 0
IF PAD.PACKETS # "" THEN
PAD.PACKETS = PAD.PACKETS<1> + 0
GUISEQS<GUI.END> = GUISEQS<GUI.END>:ESC.CHAR:"_PAD":STR(CHAR(1), PAD.PACKETS):TU.TAIL
END
*
PROMPT NUL
*
DATA.PTR = 0; SAVE.DATA = NUL; ERR = 0; SERVING = FALSE
*
*
* Save 'stacked' data if we will be 'waiting for response'
*
LOOP
STACK = SYSTEM(10)
!@!STACK = 0 ;!*ULT*!
WHILE STACK DO
INPUT STUFF:
DATA.PTR = DATA.PTR+1
SAVE.DATA<DATA.PTR> = STUFF
REPEAT
*
* Issue ROC command and wait for response.
*
*
* Build MESSAGE type String(s) to Transmit via Base Transport class
*
BEGIN CASE
CASE ROC.CMD = ROC.SET.ATTRIB; * Set Attribute(s) in Remote Object
CMD.LINE = ROC.FS:OBJNAME
CMD.LINE = CMD.LINE:ROC.FS:ATTR
CMD.LINE = CMD.LINE:ROC.FS:VALS
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.SETATTRIB>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.SET.ATTRIB ....."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.GET.ATTRIB; * Get Attribute(s) from Remote Object
CMD.LINE = ROC.FS:OBJNAME:ROC.FS:ATTR
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.GETATTRIB>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.GET.ATTRIB ....."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.INPUT; * Get Input from Remote Object
CMD.LINE = ROC.FS:OBJNAME:ROC.FS:ATTR
CMD.LINE = CMD.LINE:ROC.FS:VALS
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<GUI.INPUT>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.INPUT ....."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
IF NOT(RVAL.ERR) THEN; * True if 'set attribute' call was ok!
GOSUB 1100; * go wait for 'real' response!
END
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.SERVER.INPUT; * Get Input from Remote Object
CMD.LINE = ROC.FS:OBJNAME:ROC.FS:ATTR
CMD.LINE = CMD.LINE:ROC.FS:VALS
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<GUI.INPUT>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.SERVER.INPUT ....."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
GOSUB 1100; * go wait for 'real' response!
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.GET.EVENT
CMD.LINE = ROC.FS:"this":ROC.FS:"rpc_server"
CMD.LINE = CMD.LINE:ROC.FS:1
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.SETATTRIB>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.GET.EVENT ....."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
IF NOT(RVAL.ERR) THEN
GOSUB 1100; * Get Next Event
IF NOT(RVAL.ERR) THEN
VALS = RVAL
ERR = FALSE
RESPONSE = FALSE
GOSUB 500
END ELSE ERR = TRUE; VALS = NUL
END ELSE ERR = TRUE; VALS = NUL
CASE ROC.CMD = ROC.SERVE; * Get Input from Remote Object Server
MD.FILE = 'VOC'; !*PI/O,PR1ME,UDT,UDTVMS,UP,UV*!
!@!MD.FILE = 'MD'; !*ADDS,ALTOS,AP,GA,MRX,PICK,SEQ,ULT*!
OPEN MD.FILE TO MDFL ELSE
MD.FILE = 'MD'
OPEN '',MD.FILE TO MDFL ELSE RETURN
END
CALL ROC.SET("this", "rpc_server", 1, ERR)
CMD.LINE = ROC.FS:OBJNAME:ROC.FS:ATTR
CMD.LINE = CMD.LINE:ROC.FS:VALS
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.SETATTRIB>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.SERVE ....."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
IF NOT(RVAL.ERR) THEN; * True if 'set attribute' call was ok!
SERVING = TRUE
CMD.LINE = NUL
FUNC = NUL
LOOP WHILE SERVING DO
GOSUB 1100
IF NOT(RVAL.ERR) THEN
ANS = RVAL
FUNC = OCONV(ANS<1>, "MCU")
IF FUNC NE NUL AND FUNC = OCONV(FUNC, "MCP") THEN
ARRAY = DELETE(ANS, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ANS<1>; ARRAY = ANS; !*MRX*!
VALUE = NUL
ERROR = FALSE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Function ":OCONV(FUNC, "MCP"); GOSUB 3000
END
BEGIN CASE
CASE FUNC = "OFF" OR FUNC = "END"
SERVING = FALSE
RVAL.VALS = ARRAY
RESPONSE = TRUE; GOSUB 500
CASE FUNC = "CALLBACK" AND ARRAY<1> = "EXIT"
SERVING = FALSE
RVAL.VALS = ARRAY<2>
RESPONSE = FALSE; GOSUB 500
CASE FUNC = "CALLBACK"
FUNC = ARRAY<1>
 INCLUDE TUBP CHECK.IN.MD.H
*
IF PRESENT THEN
ARRAY = DELETE(ARRAY, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ARRAY<1> ; !*MRX*!
PARAMS = ARRAY<1>
EVENTSTR = DELETE(ARRAY, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ARRAY<1>; EVENTSTR = ARRAY; !*MRX*!
EXITSTRING = NUL
CALL @FUNC(EVENTSTR, PARAMS, EXITSTRING)
IF EXITSTRING NE NUL THEN
RVAL.VALS = EXITSTRING
SERVING = FALSE
END
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "No such Function ":FUNC; GOSUB 3000
END
RESPONSE = FALSE; GOSUB 500
END ELSE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "No such Function ":FUNC; GOSUB 3000
END
ERROR = TRUE
VALUE = "Invalid Function Call ":FUNC
END
CASE TRUE
FUNC = "RPC.":FUNC
BEGIN CASE
CASE FUNC = "RPC.READ"; GOSUB 501
CASE FUNC = "RPC.READU"; GOSUB 502
CASE FUNC = "RPC.WRITE"; GOSUB 503
CASE FUNC = "RPC.WRITEU"; GOSUB 504
CASE FUNC = "RPC.RELEASE"; GOSUB 505
CASE FUNC = "RPC.DELETE"; GOSUB 506
CASE TRUE
 INCLUDE TUBP CHECK.IN.MD.H
*
IF PRESENT THEN
VALUE = ""
CALL @FUNC(ARRAY, VALUE, ERROR)
IF ERROR THEN CALL TU.RESOLVE.STATUS(ERROR, VALUE)
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Function call ok;  ":VALUE; GOSUB 3000
END
END ELSE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "No Such Function ...."; GOSUB 3000
END
ERROR = TRUE
VALUE = "Invalid Function Call ":FUNC
END
END CASE
ABORTFLAG = TRUE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Checking for user aborts ...."; GOSUB 3000
END
CALL ROC.MAIN(ROC.SET.ATTRIB, 'this', 'rpc_abort', ABORTFLAG, NUL, ERR)
IF NOT(ERR) THEN
IF NOT(ABORTFLAG) THEN
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "None Detected, Responding ...."; GOSUB 3000
END
RESPONSE = ERROR:AM:VALUE; GOSUB 500
END ELSE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Detected, Not Responding ...."; GOSUB 3000
END
END
END ELSE
RVAL.VALS ="Server Failed To Respond"
SERVING = FALSE
RVAL.ERR = TRUE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Cannot Access Server ...."; GOSUB 3000
END
END
CASE NUL
END CASE
END
END ELSE
SERVING = FALSE
RVAL.ERR = FALSE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Server Failue ...."; GOSUB 3000
END
END
REPEAT
IF FUNC = "OFF" THEN
PRINT
PRINT 'Logging Off'
CHAIN "OFF"
END
END
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.CREATE; * Create Object
CMD.LINE = ROC.FS:OBJNAME:ROC.FS:ATTR
CMD.LINE = CMD.LINE:ROC.FS:VALS
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.CREATE>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.CREATE ...."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.DESTROY; * Destroy Object
CMD.LINE = ROC.FS:OBJNAME
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.DESTROY>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.DESTROY ...."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
ERR = RVAL.ERR
CASE ROC.CMD = ROC.EVENT; * Wait for Event
CMD.LINE = ROC.FS:OBJNAME
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.EVENT>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.EVENT ...."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.GET.HANDLE; * raw get handle function
CMD.LINE = ROC.FS:OBJNAME
CMD.LINE = LEN(CMD.LINE):CMD.LINE
CMD.LINE = GUISEQS<OBJ.GETHANDLE>:CMD.LINE
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.GET.HANDLE ...."; GOSUB 3000
END
GOSUB 1000; * Issue RPC via Base transport Class
VALS = RVAL.VALS
ERR = RVAL.ERR
CASE ROC.CMD = ROC.POP
CMD.LINE = GUISEQS<GUI.TOKEN.POP>
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.POP ...."; GOSUB 3000
END
CRT CMD.LINE:GUISEQS<GUI.END>:
ERR = FALSE
CASE ROC.CMD = ROC.INIT; * Initialise Remote Object Call Server
CMD.LINE = GUISEQS<GUI.TOKEN.SET>:TOKENS<1, ASCII.TOKEN>:TOKENS<1,ROC.LDN>
CMD.LINE = CMD.LINE:SEMI:2048; !*-MRX*!
!@!CMD.LINE = CMD.LINE:SEMI:1024 ;!*MRX*!
IF DEBUGMODE THEN
D.DIR = ""; STR.LOG = ""; GOSUB 3000
D.DIR = "Z"; STR.LOG = "ROC.INIT ...."; GOSUB 3000
END
GOSUB 1000; * Issue RPC to Base transport class
OBJNAME=RVAL.OBJNAME
VALS = RVAL.VALS
ERR = RVAL.ERR
END CASE
*
* Restore previously 'stacked' data
*
IF DATA.PTR THEN
FOR I = 1 TO DATA.PTR
DATA SAVE.DATA<I>
NEXT I
END
RETURN
*
500 * RPC Response Method
*
CALL ROC.MAIN(ROC.SET.ATTRIB, 'this', 'rpc_respond', RESPONSE, NUL, ERR)
IF ERR THEN
RVAL.VALS = "Server Failed To Respond"
SERVING = FALSE
RVAL.ERR = TRUE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Server failed to respond ...."; GOSUB 3000
END
END ELSE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Server responding ...."; GOSUB 3000
END
SERVERVAL = SERVING
CALL ROC.MAIN(ROC.SET.ATTRIB, 'this', 'rpc_available', SERVERVAL, NUL, ERR)
END
RETURN
*
501 * RPC.READ
*
* Description : Stored Procedure To Read An Item From File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
READ ITEM FROM FN, ITEMNAME ELSE
ERROR = 1
VALUE = ITEMNAME:' Not In File ':FILENAME
RETURN
END
VALS = ARRAY<3>
IF VALS = '' THEN
VALUE = ITEM
RETURN
END
VALUE = ''
D=DCOUNT(VALS, ',')
FOR A=1 TO D
ATT = FIELD(VALS, ',', A)
IF NOT(NUM(ATT)) THEN ERROR = 1; VALUE = 'Illegal Attribute Read Request - ':ATT; RETURN
IF ATT <1 OR ATT NE INT(ATT) THEN ERROR=1; VALUE = 'Illegal Attribute Read Request - ':ATT; RETURN
VALUE<-1> = ITEM<ATT>
NEXT A
RETURN
*
502 * RPC.READU
*
* Description : Stored Procedure To Read An Item From File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
READU ITEM FROM FN, ITEMNAME ELSE
ERROR = 1
VALUE = ITEMNAME:' Not In File ':FILENAME
RETURN
END
VALS = ARRAY<3>
IF VALS = '' THEN
VALUE = ITEM
RETURN
END
VALUE = ''
D=DCOUNT(VALS, ',')
FOR A=1 TO D
ATT = FIELD(VALS, ',', A)
IF NOT(NUM(ATT)) THEN ERROR = 1; VALUE = 'Illegal Attribute Read Request - ':ATT; RETURN
IF ATT <1 OR ATT NE INT(ATT) THEN ERROR=1; VALUE = 'Illegal Attribute Read Request - ':ATT; RETURN
VALUE<-1> = ITEM<ATT>
NEXT A
RETURN
*
503 * RPC.WRITE
*
* Description : Stored Procedure To Write An Item To File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
IF ITEMNAME = '' THEN VALUE = 'NUL Item Name'; ERROR=1; RETURN
BINARY = ARRAY<3>
ITEM = ARRAY
FOR ILOOP = 1 TO 3
ITEM = DELETE(ITEM, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ITEM<1> ; !*MRX*!
NEXT ILOOP
WRITE ITEM ON FN, ITEMNAME
RETURN
*
504 * RPC.WRITEU
*
* Description : Stored Procedure To Write An Item To File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
IF ITEMNAME = '' THEN VALUE = 'NUL Item Name'; ERROR=1; RETURN
BINARY = ARRAY<3>
ITEM = ARRAY
FOR ILOOP = 1 TO 3
ITEM = DELETE(ITEM, 1); !*UV,UDT,UDTVMS,PICK,AP,SEQ,ULT,ADDS,GA,ALTOS,PI/O,PR1ME,UP*!
!@!DEL ITEM<1> ; !*MRX*!
NEXT ILOOP
WRITEU ITEM ON FN, ITEMNAME
RETURN
*
505 * RPC.RELEASE
*
* Description : Stored Procedure To Write An Item To File (Can Use AMC List)
*
ERROR = 0
VALUE = ''
FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
ITEMNAME = ARRAY<2>
IF ITEMNAME = '' THEN VALUE = 'NUL Item Name'; ERROR=1; RETURN
RELEASE FN, ITEMNAME
RETURN
*
506 * RPC.DELETE
*
* Description : Stored Procedure To Delete An Item from a File (Can use AMC list of Ids)
*
ERROR = 0; VALUE = ''; FILENAME = ARRAY<1>
OPEN FILENAME TO FN ELSE
VALUE = 'Illegal File ':FILENAME
ERROR = 1
RETURN
END
IDLIST = ARRAY<2>
NUM.IDS = COUNT(IDLIST, VM) + (IDLIST # "")
IF NOT(NUM.IDS) THEN
ERROR = 1
VALUE = "No Items in List"
RETURN
END
FOR I = 1 TO NUM.IDS
DELETE FN, IDLIST<I>
NEXT I
RETURN
*
*********************************************************
* Perform Remote Proceedure Call
*********************************************************
1000 *
IF LEN(CMD.LINE) > MAX.CMD.LEN THEN
* Use file transfer module for robust transfer
OPTIONS = 'BHM'
IF DEBUGMODE THEN
OPTIONS = OPTIONS:"D"
D.DIR = "Z"; STR.LOG = "Using FT to send command."; GOSUB 3000
D.DIR = "I"; STR.LOG = CMD.LINE; GOSUB 3000
END
DESCRIPTION = NUL; ERROR = FALSE
CALL TU.DOWNLOAD(CMD.LINE, '', OPTIONS, DESCRIPTION, ERROR)
*-* Temporary fix for FTP error handling.
IF ERROR THEN
RVAL.ERR = TRUE
RVAL.VALS = NUL
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "File transfer failure ...."; GOSUB 3000
END
RETURN
END
END ELSE
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Using telnet to send command."; GOSUB 3000
D.DIR = "I"; STR.LOG = CMD.LINE; GOSUB 3000
END
STRING = CMD.LINE
OLD = ROC.US; NEW = TOKENS<1, ASCII.TOKEN>:"0"; GOSUB 2000
OLD = ROC.FS; NEW = TOKENS<1, ASCII.TOKEN>:"1"; GOSUB 2000
OLD = SVM; NEW = TOKENS<1, ASCII.TOKEN>:"2"; GOSUB 2000
OLD = VM; NEW = TOKENS<1, ASCII.TOKEN>:"3"; GOSUB 2000
OLD = AM; NEW = TOKENS<1, ASCII.TOKEN>:"4"; GOSUB 2000
OLD = CR:LF; NEW = TOKENS<1, ASCII.TOKEN>:"6"; GOSUB 2000
OLD = CR; NEW = TOKENS<1, ASCII.TOKEN>:"5"; GOSUB 2000
CMD.LINE = STRING
CRT CMD.LINE:GUISEQS<GUI.END>:
END
IF ROC.CMD = ROC.SERVER.INPUT THEN RETURN ; * No ACK in INPUT mode
*
* Wait for response to command!
*
1100 *
DONE = 0
RETRIES = 0
*
 INCLUDE TUBP ECHO.OFF.H
*
LOOP
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Waiting for response ...."; GOSUB 3000
END
*
 INCLUDE TUBP INPUT.CHAR
*
GUIFOUND = 0
IF BYTE = 8 THEN
CRT GUISEQS<GUI.LEADIN>:'a':GUISEQS<GUI.END>:
IF DEBUGMODE THEN
D.DIR = "O"; STR.LOG = "Sent ACK ...."; GOSUB 3000
END
END
*
IF BYTE = 2 OR BYTE = 24 THEN; * Ctrl B or Ctrl X Detected
IF BYTE = 24 THEN SLEEP 1
FIRST.CH = CH
 INCLUDE TUBP INPUT.MORE
*
IF MORE THEN
 INCLUDE TUBP INPUT.CHAR
*
IF BYTE = 2 THEN GUIFOUND = 1
IF BYTE = 24 THEN
RVAL.ERR = TRUE
RVAL.VALS = NUL
GO 1190
END
END
IF GUIFOUND THEN; * GUI lead-in sequence found!
INPUT RVAL:; !*-GA*!
!@!GET RVAL FROM PORTNO UNTIL CR ; !*GA*!
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Received response ...."; GOSUB 3000
D.DIR = "I"; STR.LOG = RVAL; GOSUB 3000
END
BEGIN CASE
CASE RVAL[1, 1] = NAK AND RVAL[2,1] = 'U'
CRT GUISEQS<GUI.LEADIN>:'a':GUISEQS<GUI.END>:
IF DEBUGMODE THEN
D.DIR = "O"; STR.LOG = "Sent ACK ...."; GOSUB 3000
END
GOSUB 1200; * Upload Via Data Transfer
IF ERROR THEN
IF SERVING THEN
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "FT failure in Service more Terminating ...."; GOSUB 3000
END
RVAL = NUL
RVAL.ERR = ERROR
GO 1190
END ELSE
RVAL = NUL
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Retrying packet ...."; GOSUB 3000
D.DIR = "O"; STR.LOG = CMD.LINE:GUISEQS<GUI.END>; GOSUB 3000
END
CRT CMD.LINE:GUISEQS<GUI.END>:
RETRIES = RETRIES + 1
IF RETRIES > 10 THEN
RVAL = NUL
RVAL.ERR = FTE.RETRY.LIMIT.EXCEEDED
GO 1190
END
END
END ELSE
RVAL = ITEMID
GOSUB 2100
DONE = TRUE
END
CASE RVAL[1, 1] = NAK
* Error !!! Retry...
IF DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "Error, retrying packet ...."; GOSUB 3000
END
CRT CMD.LINE:GUISEQS<GUI.END>:
RETRIES = RETRIES + 1
IF RETRIES > 10 THEN
RVAL = NUL
RVAL.ERR = FTE.RETRY.LIMIT.EXCEEDED
GO 1190
END
CASE 1
CRT GUISEQS<GUI.LEADIN>:'a':GUISEQS<GUI.END>:
IF DEBUGMODE THEN
D.DIR = "O"; STR.LOG = "Sent ACK ...."; GOSUB 3000
END
GOSUB 2100
DONE = TRUE
END CASE
END
END
UNTIL DONE DO REPEAT
1190 *
 INCLUDE TUBP ECHO.ON.H
*
RETURN
*
*-* Receive Packet via FT
*
1200 *
PCFILENAME = NUL; * Object will be fed the data
OPEN 'TUSTATE' TO F.DESTFILE ELSE; * Dummy file variable
CRT "No TUSTATE file !!"; STOP
END
ITEMID = NUL; * We'll receive our data here
OPTIONS = RVAL[3, LEN(RVAL)]
DESCRIPTION = NUL
ERROR = 0
IF DEBUGMODE THEN
OPTIONS = OPTIONS:"D"
D.DIR = "Z"; STR.LOG = "Receiving response via FT ...."; GOSUB 3000
END
CALL TU.UPLOAD(PCFILENAME, F.DESTFILE, ITEMID, OPTIONS, DESCRIPTION, ERROR)
IF ERROR AND DEBUGMODE THEN
D.DIR = "Z"; STR.LOG = "File transfer failure ...."; GOSUB 3000
END
RETURN
*
*-* Replace delimiters with substitute delimiters.
*
2000 *
 INCLUDE TUBP SWAP.STRINGS.H
*
RETURN
*
*-* Do receive Token translations
*
2100 *
STRING = RVAL
OLD = TOKENS<1, ASCII.TOKEN>:"0"; NEW = ROC.US; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"1"; NEW = ROC.FS; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"2"; NEW = SVM; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"3"; NEW = VM; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"4"; NEW = AM; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"6"; NEW = CR:LF; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"5"; NEW = CR; GOSUB 2000
RVAL = STRING
RVAL.OBJNAME = FIELD(RVAL, ROC.FS, 1)
RVAL.ATTRS = FIELD(RVAL, ROC.FS, 2)
RVAL.VALS = FIELD(RVAL, ROC.FS, 3)
RVAL.ERR = FIELD(RVAL, ROC.FS, 4)
RETURN
*
*-* DEBUG LOG UPDATE
*
3000*
IF INDEX(STR.LOG, ESC.CHAR:"_PAD", 1) THEN
STR.LOG = FIELD(STR.LOG, ESC.CHAR:"_PAD", 1)
END
READ LOG FROM TUSTATE, "ROC.LOG.":PORTNO ELSE LOG = ""
BEGIN CASE
CASE D.DIR = "I"
STR.LOG = "I<-":STR.LOG
CASE D.DIR = "O"
STR.LOG = "O->":STR.LOG
CASE D.DIR = "R"
STR.LOG = "R=>":STR.LOG
CASE D.DIR = "Z"
STR.LOG = "Z=>":STR.LOG
CASE TRUE
STR.LOG = ""
END CASE
*
OLD = AM; NEW = "."
STRING = STR.LOG
GOSUB 2000
STR.LOG = STRING
STR.LOG = OCONV(STR.LOG, "MCP")
*
IF STR.LOG # NUL THEN
LOG<-1> = OCONV(TIME(), 'MTS'):" ":STR.LOG
END ELSE
LOG<-1> = "     "
END
WRITE LOG ON TUSTATE, "ROC.LOG.":PORTNO
RETURN
*
*********************************************************
*    THE END
*********************************************************
END
