SUBROUTINE RPC.TU.PC.UPLOAD(ATTR, VALS, STATUS)
*
** SBClient Host 3GL API
** Copyright (C) Ardent Software Inc. 1998
** Copyright (C) UniData, Inc. 1996, 1997
** Copyright (C) System Builder Corporation. 1995
**
**      This software is the proprietary property and contains
**      trade secrets of Ardent Software, Inc. Any unauthorized use,
**      disclosure or duplication is strictly prohibited.
**      All rights reserved.
*
*
*-*   Description : PC to Host Upload
*
!@!CASING ON; !*AP*!
*
 INCLUDE TUBP ROC.H
 INCLUDE TUBP HEADER.H
 INCLUDE TUBP SPECIAL.H
 INCLUDE TUBP TRANSFER.OPTIONS.H
 INCLUDE TUBP TU.ERRORCODES.H
 INCLUDE TUBP TU.API.H
 INCLUDE TUBP CASE.INVERT.OFF.H
 INCLUDE TUBP USER.INCLUDE.H
*
EQU NULL TO ""
*
DEBUGFLAG = FALSE; RECNO = 0; TRCD = 0
OPEN '','TUCONFIG' TO F.CONFIG ELSE
STATUS = FTE.TUCONFIG.OPEN.ERROR
RETURN
END
READV BLK.SIZE FROM F.CONFIG, 'CACHE.SIZE', 1 ELSE BLK.SIZE = 0
IF BLK.SIZE < 2048 OR NOT(NUM(BLK.SIZE)) THEN
!@!BLK.SIZE = 8192 ; !*ADDS,ALTOS,GA,PICK*!
BLK.SIZE = 16384; !*AP,MRX,PI/O,SEQ,UDT,UDTVMS,ULT,UP,UV*!
END
*
GOSUB 100; * Initialise
IF STATUS THEN RETURN
GOSUB 200; * Check ID construction Method
GOSUB 300; * Upload Data
IF STATUS THEN RETURN
GOSUB 9900; * Header information
IF STATUS THEN RETURN
GOSUB 400; * Read Block Data
IF RECNO # "" AND RECNO THEN
IF RECNO # WREC.CNT THEN STATUS = FTE.INVALID.TRANSFER.FILE
END
RETURN
*
*-* Initialise
*
100 *
OPERATORS = ';LT;GT;=<=;=>=;WITH;BY;'
ID.FOUND = FALSE; MDELIM = '.'; * Mask Delimiter
DICT.ID = ''; VALS =''
APPLICATION = 'UPLOAD'; HEADER = ''
WREC.CNT=0; STATUS = NUL; FIRST.TIME = TRUE; DELETE.HEADER = FALSE
IF ATTR = '' THEN RETURN
*
HOSTFILENAME = ATTR<2>
PCFILENAME = ATTR<3>
FIELDLIST = ATTR<6>
DICTIONARY = ATTR<7>
IDLIST = ATTR<5>
OPTIONS = ATTR<9>
SEPARATORS = ATTR<10>; * (N/A)
DESCRIPTION = ATTR<24>; * Client Handle
RECORDTYPE = ATTR<11>
CONVTYPE = ICONV(ATTR<22>,'MCL')
HCLIENT = ATTR<24>
INTERFILE = ATTR<17>:'\':ATTR<18>; * Intermediate file name
RECORD.TYPE = ATTR<99>
*
OVERWRITE = INDEX(OPTIONS,OVERWRITEOPT,1)
HEXOPTION = (CONVTYPE = 'hex')
BINOPTION = (CONVTYPE = 'bin')
TRANSOPT = INDEX(OPTIONS,TRANSLATEOPT, 1)
DEBUGMODE = INDEX(OPTIONS, DEBUGOPT, 1); * DEBUG diag mode
NOCONVERSION = (INDEX('bin;hex;ascii', CONVTYPE, 1) > 0)
FIELDLIST = TRIM(FIELDLIST)
*
IF DICTIONARY = '' THEN DICTIONARY = HOSTFILENAME
*
*-* Check for SQLator file
*
SQLATOR.FILE = FALSE
OPEN '','VOC' TO F.VOC ELSE STATUS = FTE.MD.OPEN.ERROR; RETURN; !*UDT*!
READ DFILE FROM F.VOC, HOSTFILENAME ELSE DFILE = ""; !*UDT*!
IF DFILE<1> = "FX" THEN SQLATOR.FILE = TRUE; !*UDT*!
SQLATOR.SERVER = DFILE<10>; !*UDT*!
*
IDLIST = TRIM(IDLIST)
GETLIST.USED = FALSE
BEGIN CASE
CASE IDLIST[1,8] = 'GET-LIST'
GETLIST.USED = TRUE
IF SQLATOR.FILE THEN
UDTEXECUTE IDLIST:" ONSERVER":SQLATOR.SERVER CAPTURING RUBBISH; !*UDT*!
END ELSE
EXECUTE IDLIST CAPTURING RUBBISH; !*-MRX*!
END
!@!PERFORM IDLIST RTNLIST CAPTURING RUBBISH; !*MRX*!
CASE IDLIST # '' AND INDEX(OPERATORS,";":FIELD(IDLIST,' ',1):";",1)
*-*      Selection Criterion Used - Illegal
STATUS = FTE.INVALID.OPTION
CASE IDLIST = '' AND FIELDLIST = ''
STATUS = FTE.INVALID.OPTION
CASE 1
IF IDLIST # '' THEN
CALL TU.CONVERT('"', '', IDLIST)
CALL TU.CHANGE(' ', AM, IDLIST)
END
END CASE
*
*-* Open the Hostfile
*
OPEN '',HOSTFILENAME TO HOSTFILE ELSE
STATUS = FTE.FILE.OPEN.ERROR
RETURN
END
*
*-* Check for correlatives
*
HEADER = ""; STATUS = 0
CALL TU.BUILD.HEADER(DICTIONARY, FIELDLIST, HEADER, "UPLOAD", STATUS)
IF STATUS THEN RETURN
NO.FIELDS = COUNT(HEADER<HED.DICTNAME>, VM) + 1
FOR I = 1 TO NO.FIELDS
IF HEADER<HED.POSITION, I> < 0 AND HEADER<HED.POSITION, I> # "" THEN STATUS = FTE.CORRELATIVE.USED; RETURN
NEXT I
RETURN
*
*-* Check ID construction Method
*
200 *
IDCOUNT = 0
MASK.USED = FALSE
IDLIST.USED = FALSE
DICTID.USED = FALSE
IDCNT = DCOUNT(IDLIST, AM)
*
BEGIN CASE
CASE GETLIST.USED = TRUE
CASE IDCNT = 1
*-* single id or mask used
BACK = FIELD(IDLIST,MDELIM,2)
BEGIN CASE
CASE IDLIST = STR('#', LEN(IDLIST))
MASK.USED = TRUE
MASK.KEY = ""; MDELIM = ""
MASK = "R#":LEN(IDLIST)
IF DEBUGMODE THEN CRT 'Mask key Used'
CASE BACK # ""
IF NUM(BACK) OR BACK = STR('#', LEN(BACK)) THEN
MASK.USED = TRUE
MASK.KEY = FIELD(IDLIST,MDELIM,1)
IF NUM(BACK) THEN
MASKLEN = BACK
END ELSE MASKLEN = LEN(BACK)
MASK = "R%":MASKLEN
IF DEBUGMODE THEN CRT 'Mask key Used'
END ELSE
IDLIST.USED = TRUE
END
END CASE
*
CASE IDCNT > 1
*-* id list used
IDLIST.USED = TRUE
CASE 1
*-* id from data
DICTID.USED = TRUE
END CASE
RETURN
*
*-* Upload Data
*
300 *
IF NOCONVERSION THEN
*-*    No Conversion Required
CALL TU.CONVERT('XVB','',OPTIONS)
BEGIN CASE
CASE HEXOPTION; OPTIONS = OPTIONS:HEXOPT:BINOPT
CASE BINOPTION; OPTIONS = OPTIONS:BINOPT
CASE 1; OPTIONS = OPTIONS:ASCIIOPT
END CASE
END ELSE
*-*    Conversion Required
PCFILENAME = INTERFILE
IF NOT(INDEX(OPTIONS,BINOPT,1)) THEN OPTIONS = OPTIONS:BINOPT
DATA.IN = ''
END
*
IF HCLIENT # 'HOST' THEN
ERR = 0; DATTR = "prog_status"; DVALS = "Transmitting Data ..."
CALL ROC.SET(HCLIENT, DATTR, DVALS, ERR)
END
DESCRIPTION = PCFILENAME
*
*-* Now upload file in packets
*
FT.ID = 'SBZ.TMP.UL':PORTNO
IF DEBUGFLAG THEN CRT "Uploading data from ":PCFILENAME:" ."
TXDATA = ""; RTN.STR = ""; PROMPT ""
CALL TU.SBZ(TXDATA, PCFILENAME, HOSTFILE, BLK.SIZE, FT.ID, OPTIONS, RTN.STR, DESCRIPTION, STATUS)
OPEN '',HOSTFILENAME TO HOSTFILE ELSE
STATUS = FTE.FILE.OPEN.ERROR
RETURN
END
IF DEBUGFLAG THEN
CRT "Upload complete."
CRT "Status:- ":STATUS
CRT "Rtn.Str:- ":RTN.STR
END
IF STATUS = FTE.USING.CACHE OR STATUS = FTE.USING.FTP OR NOT(STATUS) THEN
IF STATUS = FTE.USING.FTP THEN FTP.MODE = TRUE ELSE FTP.MODE = FALSE
IF RTN.STR = "" THEN STATUS = FTE.UNKNOWN.ERROR; RETURN
STATUS = FALSE
END
RETURN
*
*-* Read Block Data
*
400 *
IF DEBUGFLAG THEN CRT "Processing packets."
LEFT.OVER = NULL; RECORD.ID = 0; OK = TRUE
*
IF FTP.MODE THEN
*
*-* Process FTP records, OS block reads
*
NOCONVERT ON ; !*UDT*!
OSOPEN RTN.STR READONLY TO F.TMP ELSE STATUS = FTE.HOSTFILE.OPEN.ERROR ; RETURN ; !*UDT*!
!@!OPENSEQ RTN.STR TO F.TMP ELSE STATUS = FTE.HOSTFILE.OPEN.ERROR ; RETURN ; !*UV,UP*!
!@!F.TMP = %OPEN(RTN.STR, 2); !*AP*!
!@!IF F.TMP < 0 THEN STATUS = FTE.HOSTFILE.OPEN.ERROR; RETURN; !*AP*!
!@!CHAR BUFFER[BLK.SIZE]; !*AP*!
BYTE.COUNT = 0 ; !*UDT*!
LOOP WHILE OK DO
OSBREAD DATA.IN FROM F.TMP AT BYTE.COUNT LENGTH BLK.SIZE ; !*UDT*!
IF DATA.IN = NULL THEN OK = FALSE ; !*UDT*!
BYTE.COUNT = BYTE.COUNT + BLK.SIZE ; !*UDT*!
!@!READBLK DATA.IN FROM F.TMP, BLK.SIZE ELSE OK = FALSE ; !*UV,UP*!
!@!I = %READ(F.TMP, BUFFER, BLK.SIZE); !*AP*!
!@!BEGIN CASE; !*AP*!
!@!CASE I < 0; !*AP*!
!@!STATUS = FTE.HOSTFILE.OPEN.ERROR; !*AP*!
!@!OK = FALSE; !*AP*!
!@!CASE I < BLK.SIZE; !*AP*!
!@!OK = FALSE; !*AP*!
!@!DATA.IN = BUFFER[1,I]; !*AP*!
!@!CASE 1; !*AP*!
!@!DATA.IN = BUFFER; !*AP*!
!@!END CASE; !*AP*!
IF DATA.IN # NULL THEN
DATA.IN = LEFT.OVER:DATA.IN; LEFT.OVER = NULL
GOSUB 500; *-* Process each block of data
END
REPEAT
!@!%CLOSE(F.TMP); %UNLINK(RTN.STR); !*AP*!
NOCONVERT OFF ; OSCLOSE F.TMP ; OSDELETE RTN.STR ; !*UDT*!
!@!CLOSESEQ F.TMP ; !*UV,UP*!
!@!CALL UV.DELETE.OSFILE(RTN.STR, STATUS) ; !*UV,UP*!
END ELSE
*
*-* Process SBZ Cache records
*
BLKCNT = COUNT(RTN.STR<1>,VM) + (RTN.STR<1> # NULL)
BLKNO = 1
LOOP UNTIL BLKNO > BLKCNT OR STATUS DO
READ DATA.IN FROM HOSTFILE,RTN.STR<1,BLKNO> THEN
DATA.IN = LEFT.OVER:DATA.IN; LEFT.OVER = NULL
GOSUB 500; *-* Process each block of data
END
DELETE HOSTFILE,RTN.STR<1,BLKNO>
BLKNO = BLKNO + 1
REPEAT
END
IF LEFT.OVER # NULL THEN
ITEM = LEFT.OVER
GOSUB 900
END
RETURN
*
*-* Process each block of data
*
500 *
IF NOT(DELETE.HEADER) THEN
*-* First AM contains internal stuff
IF DATA.IN<1,1> = "SBFTP.XSB" THEN
RECNO = DATA.IN<1,15>
DATA.IN<1> = ""
RCD = 1
END ELSE RCD = 0
IF HCLIENT # 'HOST' AND RECNO THEN
ERR = 0; DATTR = "prog_status"; DVALS = "Writing Database Records ... 0%"
CALL ROC.SET(HCLIENT, DATTR, DVALS, ERR)
OLD.PER = 10
END
DELETE.HEADER = TRUE
END ELSE RCD = 0
AMC = COUNT(DATA.IN, AM)
ID.COUNT = IDCNT
BEGIN CASE
CASE NOT(MASK.USED) AND ID.COUNT = 1
*-* Write data into single item
ID = IDLIST; RECNO = ""
GOSUB 520
CASE TRUE
*-* Normal RPC data processing
GOSUB 580
END CASE
RETURN
*
*-* Write data into single item
*
520 *
IF DATA.IN<1> = "" THEN
DATA.IN = DELETE(DATA.IN, 1); !*-MRX*!
!@!DEL DATA.IN<1> ; !*MRX*!
END
BEGIN CASE
CASE OVERWRITE AND FIRST.TIME
IF SQLATOR.FILE THEN
CALL START.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.START.TRANS; RETURN
WRITE DATA.IN ON HOSTFILE,ID
CALL COMMIT.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.COMMIT.TRANS; RETURN
END ELSE
WRITE DATA.IN ON HOSTFILE,ID
END
FIRST.TIME = FALSE
CASE OVERWRITE AND NOT(FIRST.TIME)
READ RECORD FROM HOSTFILE,ID THEN
RECORD = RECORD:DATA.IN
IF SQLATOR.FILE THEN
CALL START.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.START.TRANS; RETURN
WRITE RECORD ON HOSTFILE,ID
CALL COMMIT.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.COMMIT.TRANS; RETURN
END ELSE
WRITE RECORD ON HOSTFILE,ID
END
END
CASE NOT(OVERWRITE) AND FIRST.TIME
READ TEST FROM HOSTFILE,ID THEN
STATUS = FTE.ITEM.EXISTS.ERROR
END ELSE
IF SQLATOR.FILE THEN
CALL START.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.START.TRANS; RETURN
WRITE DATA.IN ON HOSTFILE,ID
CALL COMMIT.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.COMMIT.TRANS; RETURN
END ELSE
WRITE DATA.IN ON HOSTFILE,ID
END
FIRST.TIME = FALSE
END
CASE NOT(OVERWRITE) AND NOT(FIRST.TIME)
READ RECORD FROM HOSTFILE,PCFILENAME THEN
RECORD = RECORD:DATA.IN
IF SQLATOR.FILE THEN
CALL START.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.START.TRANS; RETURN
WRITE RECORD ON HOSTFILE,PCFILENAME
CALL COMMIT.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.COMMIT.TRANS; RETURN
END ELSE
WRITE RECORD ON HOSTFILE,PCFILENAME
END
END
END CASE
RETURN
*
*-* Normal RPC data processing
*
580 *
BEGIN CASE
CASE GETLIST.USED
*-* id's from get list
REC.CNT = 999999999
CASE IDLIST.USED
*-* id list
REC.CNT = ID.COUNT
CASE 1
*-* id from data
REC.CNT = AMC
END CASE
*
EOF = FALSE
LOOP
RCD = RCD + 1
IF RCD > REC.CNT THEN EOF = TRUE
IF HCLIENT # 'HOST' AND RECNO THEN
DONE.PER = (TRCD/RECNO)*100
DONE.PER = FIELD(DONE.PER, ".", 1)
IF DONE.PER > 100 THEN DONE.PER = 100
IF DONE.PER >= OLD.PER THEN
OLD.PER = OLD.PER + 10
DVALS = "Writting Database Records ... ":DONE.PER:"%"
CALL ROC.SET(HCLIENT, DATTR, DVALS, ERR)
END
END
UNTIL EOF DO
TRCD = TRCD + 1
IF DEBUGFLAG THEN CRT "Processing record ":RCD
ITEM = DATA.IN<RCD>
GOSUB 900
DATA.IN<RCD> = ""
REPEAT
LEFT.OVER = DATA.IN<RCD>
RETURN
*
*-* Build and Write record
*
900 *
NEW.ITEM = ''
DICT.ID = ''
*-* If no fields then convert VMs to AMs
IF FIELDCOUNT = 0 THEN
NEW.ITEM = ITEM
CALL TU.CONVERT(VM, AM, NEW.ITEM)
CALL TU.CONVERT(SVM, VM, NEW.ITEM)
CALL TU.CONVERT("~", SVM, NEW.ITEM)
END ELSE
FOR FIELDNO = 1 TO FIELDCOUNT
CONV = HEADER<HED.OCONV, FIELDNO>
FIELDPOS = FLIST<1,FIELDNO>
IF CONV = '' THEN
FLD = ITEM<1,FIELDNO>
END ELSE FLD = ICONV(ITEM<1,FIELDNO>, CONV)
IF FIELDPOS = 0 THEN
DICT.ID = TRIM(FLD)
END ELSE NEW.ITEM<FIELDPOS> = FLD
NEXT FIELDNO
END
*
IF DICT.ID = '' AND DICTID.USED THEN
DICT.ID = NEW.ITEM<1>
NEW.ITEM = DELETE(NEW.ITEM, 1); !*-MRX*!
!@!DEL NEW.ITEM<1>; !*MRX*!
END
*-* Get the next appropriate ID
BEGIN CASE
*-*  id from active select list
CASE GETLIST.USED
READNEXT ID ELSE
EOF = TRUE
REC.CNT = WREC.CNT
RETURN
END
CASE MASK.USED
*-* id from mask, or sequential id used
IDCOUNT = IDCOUNT+1
ID.COUNT = IDCOUNT MASK
ID = MASK.KEY:MDELIM:ID.COUNT
CASE IDLIST#''
*-* id from idlist
ID = TRIM(IDLIST<RCD>)
CASE 1
*-* id from data
ID = DICT.ID
END CASE
IF ID = '' THEN
STATUS = FTE.INVALID.ID
END
IF ID = '' THEN STATUS = FTE.INVALID.ID
IF DEBUGFLAG THEN
RESP = ""
CRT "Writing record: ":NEW.ITEM
CRT "From data ":ITEM
CRT "Goto debugger? ":; !*-PI/O*!
INPUT RESP; !*-PI/O*!
RESP = OCONV(RESP, "MCU"); !*-PI/O*!
IF RESP = "D" THEN DEBUG; !*-PI/O*!
END
ID = TRIM(ID)
IF OVERWRITE THEN
IF SQLATOR.FILE THEN
CALL START.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.START.TRANS; RETURN
WRITE NEW.ITEM ON HOSTFILE,ID
CALL COMMIT.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.COMMIT.TRANS; RETURN
END ELSE
WRITE NEW.ITEM ON HOSTFILE,ID
END
WREC.CNT = WREC.CNT + 1
END ELSE
READ TEST FROM HOSTFILE,ID THEN
STATUS = FTE.ITEM.EXISTS.ERROR
END ELSE
IF SQLATOR.FILE THEN
CALL START.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.START.TRANS; RETURN
WRITE NEW.ITEM ON HOSTFILE,ID
CALL COMMIT.REMOTE.TRANSACTION(SQLATOR.SERVER, ERROR)
IF NOT(ERROR) THEN STATUS = SQL.COMMIT.TRANS; RETURN
END ELSE
WRITE NEW.ITEM ON HOSTFILE,ID
END
WREC.CNT = WREC.CNT + 1
END
END
RETURN
*
*-* Header information
*
9900 *
IF DEBUGMODE THEN CRT 'Calling TU.BUILD.HEADER'
CALL TU.BUILD.HEADER(DICTIONARY, FIELDLIST, HEADER, APPLICATION, STATUS)
IF STATUS THEN RETURN
*
FLIST = HEADER<HED.POSITION>
FIELDCOUNT = COUNT(FLIST, VM) + (FLIST # '')
FOR FLD = 1 TO FIELDCOUNT
IF FLIST<1,FLD> < 0 THEN
STATUS = FTE.INVALID.DICT.ITEM; * correlative (WAS 9)
RETURN
END
IF FLIST<1,FLD> = 0 THEN ID.FOUND = TRUE
NEXT FLD
RETURN
*
*-* The End
*
END
*
