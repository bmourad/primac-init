SUBROUTINE TU.SQL.MAKEDICT(DBHANDLE,DBTABLENAME,DICTFILE,RTN.STATUS)
*
**** SUBROUTINE FOR SQL INTERFACE  (cloned from UT.SQL)
*
** SBClient Host 3GL API
** Copyright (C) Ardent Software Inc. 1998
** Copyright (C) UniData, Inc. 1996, 1997
** Copyright (C) System Builder Corporation. 1995
**
**      This software is the proprietary property and contains
**      trade secrets of Ardent Software, Inc. Any unauthorized use,
**      disclosure or duplication is strictly prohibited.
**      All rights reserved.
*
******************************************************************
* This routine creates host data base dictionary items from an SQL schema
* Passed:   DBHANDLE    -  data base handle
*           DBTABLENAME -  name of SQL table to generate dictionary items from
*           DICTFILE    -  name of host dictionary to contain generated items
* Returned: RTN.STATUS  -  operation status
******************************************************************
*
 INCLUDE TUBP USER.INCLUDE.H
 INCLUDE TUBP TU.API.H
 INCLUDE TUBP SPECIAL.H
 INCLUDE TUBP ROC.MAIN.H
*
PROMPT NUL
*
EQU MODE TO 9; * Make Dict
DICT.TYPES = 'CHAR':AM:'NUMBER':AM:'DATE'
*
LAST.ACTION = 4
RTN.STATUS = 0
*
ACTION = 1
 INCLUDE TUBP ECHO.OFF.H
LOOP
ON ACTION GOSUB 100, 200, 300, 900
WHILE ACTION AND NOT(RTN.STATUS) DO
ACTION = ACTION + 1
REPEAT
 INCLUDE TUBP ECHO.ON.H
RETURN
*
100 *
*
*     PARAMETER = DBHANDLE:SEMI:'SELECT * FROM ':DBTABLENAME
PARAMETER = DBHANDLE:SEMI:DBTABLENAME
CRT SQL.LEAD.SEQ:MODE:SEMI:PARAMETER:TU.TAIL:
INPUT RTN.STATUS:
INPUT OK:; * dummy input
IF RTN.STATUS THEN
EMSG = 'SELECT ERROR'
GOSUB 999; * display error
END
RETURN
*
200 *
*
BUFFER = NUL
LOOP
INPUT RTN.FLAG:
INPUT VALUE: ;!*-GA*!
!@!GET VALUE FROM PORTNO UNTIL CR ; !*GA*!
UNTIL RTN.FLAG DO
BUFFER<-1> = VALUE
REPEAT
IF BUFFER = NUL THEN
EMSG = 'NO ITEMS SELECTED FROM TABLE ':DBTABLENAME
GOSUB 999; * display error
END ELSE
STRING = BUFFER
OLD = TOKENS<1, ASCII.TOKEN>:"0"; NEW = CHAR(250); GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"1"; NEW = CHAR(251); GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"2"; NEW = SVM; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"3"; NEW = VM; GOSUB 2000
OLD = TOKENS<1, ASCII.TOKEN>:"4"; NEW = AM; GOSUB 2000
BUFFER = STRING
END
RETURN
*
300 *
*
OPEN 'MD' TO F.MD THEN
READ VOC.REC FROM F.MD, 'VOC' THEN
DTYPE = (VOC.REC<1> # 'Q')
END ELSE
DTYPE = 0
END
END ELSE
OPEN 'VOC' TO F.MD THEN
DTYPE = 1
END ELSE
EMSG = 'CANNOT OPEN MASTER DICTIONARY OR "VOC"'
GOSUB 999; * display error
END
END
OPEN 'DICT',DICTFILE TO F.DICT ELSE
EMSG = 'CANNOT OPEN DICTIONARY OF ':DICTFILE
GOSUB 999; * display error
END
RETURN
*
900 *
*
NO.FIELDS = DCOUNT(BUFFER,AM)
FOR I = 1 TO NO.FIELDS
KEY.NAME = BUFFER<I,1>
KEY = TRIM(OCONV(KEY.NAME,'MCU'))
REPHEAD = KEY
CALL TU.CHANGE(SPC,DOT,KEY)
CALL TU.CHANGE('_',SPC,REPHEAD)
REPHEAD = OCONV(REPHEAD,'MCT')
TYPE = BUFFER<I,2>
IF NOT(NUM(TYPE)) THEN
LOCATE(TYPE,DICT.TYPES ; POS) THEN
TYPE = POS-1
END ELSE TYPE = 0
END
BEGIN CASE
CASE TYPE = 0
JUST = 'L'
CONV = NUL
LENG = BUFFER<I,3>
CASE TYPE = 1
JUST = 'R'
DEC.PTS = BUFFER<I,5>
IF DEC.PTS > 0 THEN CONV = 'MR':DEC.PTS:DEC.PTS ELSE CONV = NUL
LENG = BUFFER<I,3>
CASE TYPE = 2
JUST = 'L'; * ??
CONV = 'D4/'
LENG = 9
CASE TYPE = 3
JUST = 'R'
CONV = 'MR22'
LENG = BUFFER<I,3>
CASE 1
JUST = 'L'
CONV = NUL
LENG = BUFFER<I,3>
END CASE
BEGIN CASE
CASE LENG > 80; LENG = 80
CASE LENG < 0; LENG = 20; * negative --> pointer to overflow text
END CASE
GOSUB 450
NEXT I
ACTION = 0
RETURN
*
450 *
*
IF DTYPE THEN; * not pick
RECORD = 'D'
RECORD<3> = CONV
RECORD<4> = REPHEAD
RECORD<5> = LENG:JUST; * Length then Justification
RECORD<6> = 'S'
END ELSE
RECORD = 'A'
RECORD<3> = REPHEAD
RECORD<7> = CONV
RECORD<9> = JUST
RECORD<10> = LENG
END
RECORD<2> = I - 1
WRITE RECORD ON F.DICT,KEY
RETURN
*
999 *
*
CRT BEL:EMSG:' ':
INPUT OK,1
RTN.STATUS = 1
RETURN
*
2000 *
*
 INCLUDE TUBP SWAP.STRINGS.H
RETURN
*
***********************************************************
* The End
***********************************************************
END
