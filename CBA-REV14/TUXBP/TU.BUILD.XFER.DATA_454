SUBROUTINE TU.BUILD.XFER.DATA_454(FILES, FIELDLIST, SELECTION, FLAGS, STATUS)
*
*
** SBClient Host 3GL API
** Copyright (C) Ardent Software Inc. 1998
** Copyright (C) UniData, Inc. 1996, 1997
** Copyright (C) System Builder Corporation. 1995
**
**      This software is the proprietary property and contains
**      trade secrets of Ardent Software, Inc. Any unauthorized use,
**      disclosure or duplication is strictly prohibited.
**      All rights reserved.
*
*
***************************************************************************
*-* TU.BUILD.XFER.DATA(Pickfilename, Fieldlist, Selection, Status)
*-*
*-*  This subroutine selects and formats pick items in preparation for
*-* download to PC. The data is written into a file called TUXFER.DATA.xx, where
*-* xx is the port number of the user.
*-*
*-* [P] Pickfilename The name of the pick file to be downloaded.
*-*
*-* [P] Fieldlist List of dictionary definitions of fields to be
*-* downloaded.
*-*
*-* [P] Selection Selection criteria to locate items to be downloaded.
*-*
*-* [R] Status This is an indication of the success or failure of the
*-* subroutine. A successful call will return with zero
*-* Status and failure will return with a non-zero value.
***************************************************************************
*
 INCLUDE TUBP USER.INCLUDE.H
 INCLUDE TUBP SPECIAL.H
 INCLUDE TUBP TU.API.H
 INCLUDE TUBP HEADER.H
 INCLUDE TUBP TU.ERRORCODES.H
 INCLUDE TUBP STACK.ON.H
*
EQU EMPTY TO '!@#$%EMPTY%$#@!'
EQU FINAL TO '!@#$%FINAL%$#@!'
EQU NO.BREAK TO '!@#$%NO.BREAK%$#@!'
EQU MAX.GUI.ITEMS TO 10000; * max number of GUI items to be output
EQU TRUE TO 1
EQU FALSE TO 0
EQU NULL TO ''
*
DEBUGFLAG = FALSE
OPEN '','TUCONFIG' TO F.TUCONFIG ELSE
STATUS = FTE.TUCONFIG.OPEN.ERROR
RETURN
END
READV BLK.SIZE FROM F.TUCONFIG, 'BLOCK.SIZE', 1 ELSE BLK.SIZE = 0
IF BLK.SIZE < 2048 OR NOT(NUM(BLK.SIZE)) THEN
BLK.SIZE = 4096
END
*
GOSUB 100; * Initialise
IF STATUS THEN GOTO 9999
GOSUB 200; * Parse selection and field list
GOSUB 300; * Setup Xfer File
IF STATUS THEN GOTO 9999
CALL TU.BUILD.HEADER_454(DICTIONARY, OUTPUT.CRITERIA, HEADER, APPLICATION, STATUS)
IF STATUS THEN GOTO 9999
GOSUB 400; * Search for Break or Total modifier
GOSUB 500; * Parse field list for Correlatives
IF CORRELATIVE THEN
IF SQLATOR.FILE THEN
STATUS = SQL.OPTION.NOT.SUPPORTED
GOTO 9999
END
GOSUB 600; * Build data with REFORMAT
END ELSE
GOSUB 700; * Build data
END
*
*-* Exit
*
9999 *
IF NOT(STACK.ON) THEN EXECUTE 'UDT.OPTIONS 11 OFF' CAPTURING OUTPUT ; !*UDT,UDTVMS*!
RETURN
*
*-* Initialise
*
100 *
*-* Support for USING DICT xx
IF DEBUGFLAG THEN CRT "Initialising Build Xfer Data"
ITEM = NULL; HEADER = NULL; CORRELATIVE = FALSE; XFER.SIZE = 0
FIRST.WRITE = TRUE
HOSTFILENAME = FILES<1>
DICTIONARY = FILES<2>
IF DICTIONARY = '' THEN
DICTIONARY = HOSTFILENAME
USINGDICT = 0
END ELSE
USINGDICT = 1
END
*
APPLICATION = FLAGS<1,1>; OPTIONS = FLAGS<1,2>
FORMAT.DATA = INDEX(OPTIONS,'F',1)
COLUMN.HEADER = INDEX(OPTIONS,'H',1)
INSERT.BLANK = INDEX(OPTIONS,'I',1)
IF STATUS < 0 THEN QBH = ABS(STATUS) ELSE QBH = 0
STATUS = 0
USINGMENTOR = 0; !*-ADDS*!
!@!USINGMENTOR = 1; !*ADDS*!
*
OPEN '','TUSTATE' TO TUSTATE ELSE STATUS = FTE.TUSTATE.OPEN.ERROR; RETURN
IF TU.TRACE THEN
WRITEV ('BUILD.XFER.DATA':VM:HOSTFILENAME:VM:FIELDLIST:VM:SELECTION:VM:APPLICATION) ON TUSTATE,('TRACE.':PORTNO),-1
END
*-*
ID.SUPP = ' ID-SUPP'
MD.FILE = 'VOC'; !*PI/O,PR1ME,UDT,UDTVMS,UP,UV*!
!@!MD.FILE = 'MD'; !*ADDS,ALTOS,AP,GA,MRX,PICK,SEQ,ULT*!
OPEN '',MD.FILE TO MD ELSE
MD.FILE = 'MD'
OPEN '',MD.FILE TO MD ELSE
STATUS = FTE.MD.OPEN.ERROR
RETURN
END
END
READ REFORMAT FROM MD,'REFORMAT' THEN
IF REFORMAT<1> = 'PA' AND REFORMAT<4> = '12C' THEN ID.SUPP = ''
END
*
OPEN 'DICT',HOSTFILENAME TO DICTHOSTFILE ELSE
WRITE (FTE.HOSTFILE.OPEN.ERROR:AM:'DICT ':HOSTFILENAME) ON TUSTATE,'ERROR.':PORTNO
STATUS = FTE.HOSTFILE.OPEN.ERROR
END
*-* Dict support
IF USINGDICT THEN
OPEN 'DICT',DICTIONARY TO USINGDICTFL ELSE
STATUS = FTE.HOSTFILE.OPEN.ERROR
END
END
*
*-* Check for save list file
*
!@!OPEN '','POINTER-FILE' TO F.TMP ELSE STATUS = FTE.POINTER.FILE; RETURN; !*-UV,-UDT,-UDTVMS*!
!@!OPEN '','&SAVEDLISTS&' TO F.TMP ELSE STATUS = FTE.POINTER.FILE; RETURN; !*UV*!
OPEN '','SAVEDLISTS' TO F.TMP ELSE STATUS = FTE.POINTER.FILE; RETURN; !*UDT,UDTVMS*!
*
*-* Check for SQLator file
*
SQLATOR.FILE = FALSE
READ DFILE FROM MD, HOSTFILENAME ELSE DFILE = ""; !*UDT*!
IF DFILE<1> = "FX" THEN SQLATOR.FILE = TRUE; !*UDT*!
SQLATOR.SERVER = DFILE<10>; !*UDT*!
RETURN
*
*-* Parse selection and field list
*
200 *
*-* Check dictionary for selection, if first word not WITH then add connective
*-* Missing connective will cause SELECET problems, whereas SORT/LIST may cope
IF DEBUGFLAG THEN CRT "Parseing selection criteria and field list"
IF SELECTION # '' THEN
FIRST.WORD = FIELD(SELECTION,' ',1)
READ TEST FROM DICTHOSTFILE, FIRST.WORD THEN
SELECTION = 'WITH ':SELECTION
END
IF SELECTION = "*" THEN SELECTION = ""
END
SELECT.CRITERIA = ' ':SELECTION:' '
OUTPUT.CRITERIA = ' ':FIELDLIST:' '
SORT = ''
*-* Determine if we need to sort the output
BEGIN CASE
CASE INDEX(SELECT.CRITERIA, ' BY ', 1); SORT = 'S'
CASE INDEX(SELECT.CRITERIA, ' BY-DSND ', 1); SORT = 'S'
CASE INDEX(SELECT.CRITERIA, ' BY.DSND ', 1); SORT = 'S'
CASE INDEX(SELECT.CRITERIA, ' BY-EXP ', 1); SORT = 'S'; CORRELATIVE = TRUE
CASE INDEX(SELECT.CRITERIA, ' BY.EXP ', 1); SORT = 'S'; CORRELATIVE = TRUE
CASE INDEX(SELECT.CRITERIA, ' BY-EXP-DSND ', 1); SORT = 'S'; CORRELATIVE = TRUE
CASE INDEX(SELECT.CRITERIA, ' BY.EXP.DSND ', 1); SORT = 'S'; CORRELATIVE = TRUE
END CASE
*-* Strip Detail Suppress from OUTPUT.CRITERIA
DET.SUPP = INDEX(OUTPUT.CRITERIA, ' DET-SUPP ', 1)
IF DET.SUPP THEN
OUTPUT.CRITERIA = OUTPUT.CRITERIA[1, DET.SUPP]:OUTPUT.CRITERIA[DET.SUPP + 10, LEN(OUTPUT.CRITERIA)]
END ELSE
DET.SUPP = INDEX(OUTPUT.CRITERIA, ' DET.SUP ', 1)
IF DET.SUPP THEN
OUTPUT.CRITERIA = OUTPUT.CRITERIA[1, DET.SUPP]:OUTPUT.CRITERIA[DET.SUPP + 9, LEN(OUTPUT.CRITERIA)]
END
END
*-* Strip Total Suppress from OUTPUT.CRITERIA
TOTAL.SUPP = INDEX(OUTPUT.CRITERIA, ' TOTAL-SUPP ', 1)
IF TOTAL.SUPP THEN
OUTPUT.CRITERIA = OUTPUT.CRITERIA[1, TOTAL.SUPP]:OUTPUT.CRITERIA[TOTAL.SUPP + 12, LEN(OUTPUT.CRITERIA)]
END ELSE
TOTAL.SUPP = INDEX(OUTPUT.CRITERIA, ' TOTAL.SUP ', 1)
IF TOTAL.SUPP THEN
OUTPUT.CRITERIA = OUTPUT.CRITERIA[1, TOTAL.SUPP]:OUTPUT.CRITERIA[TOTAL.SUPP + 11, LEN(OUTPUT.CRITERIA)]
END
END
*-* Strip Header Suppress from OUTPUT.CRITERIA
HDR.SUPP = INDEX(OUTPUT.CRITERIA, ' HDR-SUPP ', 1)
IF HDR.SUPP THEN
OUTPUT.CRITERIA = OUTPUT.CRITERIA[1, HDR.SUPP]:OUTPUT.CRITERIA[HDR.SUPP + 10, LEN(OUTPUT.CRITERIA)]
END ELSE
HDR.SUPP = INDEX(OUTPUT.CRITERIA, ' HDR.SUP ', 1)
IF HDR.SUPP THEN
OUTPUT.CRITERIA = OUTPUT.CRITERIA[1, HDR.SUPP]:OUTPUT.CRITERIA[HDR.SUPP + 9, LEN(OUTPUT.CRITERIA)]
END
END
*-* Strip Column Header Suppress from OUTPUT.CRITERIA
COL.HDR.SUPP = INDEX(OUTPUT.CRITERIA, ' COL-HDR-SUPP ', 1)
IF COL.HDR.SUPP THEN
OUTPUT.CRITERIA = OUTPUT.CRITERIA[1, COL.HDR.SUPP]:OUTPUT.CRITERIA[COL.HDR.SUPP + 14, LEN(OUTPUT.CRITERIA)]
END
RETURN
*
*-* Setup Xfer File
*
300 *
IF DEBUGFLAG THEN CRT "Setting up Xfer File"
FILENAME = "TUXFER.DATA.":PORTNO
OPEN '',FILENAME TO TUXFER.DATA ELSE
MOD = 251
 INCLUDE TUBP EXEC.CREATE.FILE.H
*
OPEN '',FILENAME TO TUXFER.DATA ELSE
WRITE (FTE.TUXFER.DATA.FILE.OPEN.ERROR:AM:'TUXFER.DATA.':PORTNO) ON TUSTATE,'ERROR.':PORTNO
STATUS = FTE.TUXFER.DATA.FILE.OPEN.ERROR
RETURN
END
END
EXECUTE 'CLEAR-FILE DATA ':FILENAME CAPTURING RUBBISH
RETURN
*
*-* Search for Break or Total modifier
*
400 *
IF DEBUGFLAG THEN CRT "Searching for Break or Total modifier"
DICTCOUNT = COUNT(HEADER<HED.DICTNAME>, VM) + (HEADER<HED.DICTNAME> # '')
BREAK.ON = ''; HAVE.BREAK = 0
TOTALS = ''; HAVE.TOTAL = 0
FOR I = 1 TO DICTCOUNT
IF HEADER<HED.BORT, I> = 'B' THEN
BREAK.ON<I> = EMPTY
HAVE.BREAK = 1
END ELSE
BREAK.ON<I> = NO.BREAK
END
IF HEADER<HED.BORT, I> = 'T' THEN
HAVE.TOTAL = 1
END
NEXT I
HEADER<HED.SELECTION> = SELECTION
RETURN
*
*-* Parse field list for Correlatives
*
500 *
IF DEBUGFLAG THEN CRT "Parse field list for Correlative"
FOR I = 1 TO DICTCOUNT
IF HEADER<HED.POSITION, I> < 0 THEN CORRELATIVE = CORRELATIVE + 1
NEXT I
RETURN
*
*-* Build data with REFORMAT verb
*
600 *
IF DEBUGFLAG THEN CRT "Building data with correlatives using REFORMAT verb"
EXECUTE 'DELETE-LIST ':FILENAME CAPTURING OUTPUT
SELECTCOUNT = 0; OK = TRUE; OLD.ID = ""
*-* Check for Get List used in selection syntax
FIRSTONE = FIELD(TRIM(SELECTION), ' ', 1)
GLINDEX = INDEX('GET-LIST;GET.LIST;GL', FIRSTONE, 1)
IF NOT(GLINDEX) OR FIRSTONE = "" THEN
GOSUB 610; * Build select list
IF STATUS THEN RETURN
END
GOSUB 620; * Build REFORMAT syntax
GOSUB 630; * Run REFORMAT command and get active select list
LOOP
READNEXT FORMATTEDID ELSE
GOSUB 850; * process break and grand total
OK = FALSE
END
WHILE OK DO
*-* FORMATTEDITEM record written to Xfer data file by REFORMAT verb
LOCATE FORMATTEDID IN OLD.ID<1> SETTING POS ELSE POS = 0
IF NOT(POS) THEN
READ FORMATTEDITEM FROM TUXFER.DATA, FORMATTEDID ELSE
WRITE (FTE.ITEM.READ.ERROR:AM:'TU.BUILD.XFER.DATA':AM:'TUXFER.DATA.':PORTNO:' ':FORMATTEDID) ON TUSTATE,'ERROR.':PORTNO
STATUS = FTE.ITEM.READ.ERROR
RETURN
END
OLD.ID<1,-1> = FORMATTEDID
GOSUB 800; * process each record
IF STATUS THEN OK = FALSE
DELETE TUXFER.DATA,FORMATTEDID
END
REPEAT
RETURN
*
*-* Build select list
*
610 *
IF DEBUGFLAG THEN CRT "Building select list"
IF DICTIONARY # "" THEN
ACCESS1 = SORT:"SELECT ":HOSTFILENAME:" USING DICT ":DICTIONARY:" ":SELECT.CRITERIA
END ELSE
ACCESS1 = SORT:"SELECT ":HOSTFILENAME:" ":SELECT.CRITERIA
END
ACCESS2 = "SAVE-LIST TUXFER.DATA.":PORTNO
IF DEBUGFLAG THEN
CRT "ACCESS1 => ":ACCESS1
CRT "ACCESS2 => ":ACCESS2
END
 INCLUDE TUBP EXEC.DOUBLE.ACCESS.H
*-* Fix for any rouge data statements after err 401 IMS
STACK = SYSTEM(10)
!@!STACK = 0 ;!*ULT*!
IF STACK THEN
INPUT DATA.STATEMENT
END
SELECT.CRITERIA = 'GET-LIST TUXFER.DATA.':PORTNO
*-*    Figure out how many items were selected
!@!EXECUTE SELECT.CRITERIA CAPTURING OUTPUT ; !*ULT*!
GOSUB 640; * count items selected
RETURN
*
*-* Build REFORMAT syntax
*
620 *
IF DEBUGFLAG THEN CRT "Building REFORMAT syntax"
READ TU.ITEM.ID FROM DICTHOSTFILE,'@ID' ELSE TU.ITEM.ID = ''
IF TU.ITEM.ID = '' THEN
 INCLUDE TUBP DEFAULT.DICT.ID.H
END
*-* Dict support
IF USINGDICT THEN
OUTPUT.CRITERIA = OUTPUT.CRITERIA:' USING DICT ':DICTIONARY
WRITE TU.ITEM.ID ON USINGDICTFL,'@ID'
END ELSE
WRITE TU.ITEM.ID ON DICTHOSTFILE,'@ID'
END
*
TCL=SORT:'REFORMAT ':HOSTFILENAME:' @ID ':OUTPUT.CRITERIA:ID.SUPP
*-* Strip TOTAL from OUTPUT.CRITERIA
LOOP
P = INDEX(TCL, ' TOTAL ', 1)
WHILE (P > 0) DO
TCL = TCL[1, P]:TCL[P + 7, LEN(TCL)]
REPEAT
*-* Strip BREAK-ON from OUTPUT.CRITERIA
LOOP
P = INDEX(TCL, ' BREAK-ON ', 1)
IF NOT(P) THEN
P = INDEX(TCL, ' BREAK.ON ', 1)
END
WHILE (P > 0) DO
TCL = TCL[1, P]:TCL[P + 10, LEN(TCL)]
REPEAT
*-* Strip BREAK.SUP from OUTPUT.CRITERIA
LOOP
P = INDEX(TCL, ' BREAK.SUP ', 1)
WHILE (P > 0) DO
TCL = TCL[1, P]:TCL[P + 11, LEN(TCL)]
REPEAT
*-* Strip BREAK/TOTAL Text
LOOP
P2 = INDEX(TCL, '"', 2)
WHILE (P2 > 0) DO
P = INDEX(TCL, '"', 1)
TCL = TCL[1, P-1]:TCL[P2 + 1, LEN(TCL)]
REPEAT
TCL = TRIM(TCL)
RETURN
*
*-* Run REFORMAT command and get active select list
*
630 *
IF DEBUGFLAG THEN CRT "Executing REFORMAT command"
IF QBH THEN CALL ROC.SET_454(QBH, "status", 'Formatting data ....', ERR)
ACCESS1 = SELECT.CRITERIA
ACCESS2 = "TUXFER.DATA.":PORTNO
ACCESS3 = TCL
 INCLUDE TUBP PTERM.ECHO.OFF.H
*
 INCLUDE TUBP EXEC.TRIPLE.ACCESS.H
*
STACK = SYSTEM(10)
!@!STACK = 0 ;!*ULT*!
IF STACK THEN
INPUT JUNK; * Fix rouge DATA statement
END
 INCLUDE TUBP PTERM.ECHO.ON.H
*
OUTCOUNT = 0; INCOUNT = 0; ID = 1; AC = 1; ITEM = NULL
EXECUTE SELECT.CRITERIA CAPTURING OUTPUT; !*-MRX*!
!@!PERFORM SELECT.CRITERIA RTNLIST CAPTURING OUTPUT; !*MRX*!
LASTPERCENTAGE = 0
RETURN
*
*-* count items selected
*
640 *
IF DEBUGFLAG THEN CRT "Counting items in active select list"
 INCLUDE TUBP SELECT.COUNT.H
*
IF SELECTCOUNT = 0 THEN
WRITE (FTE.NO.ITEMS.FOUND:AM:HOSTFILENAME:AM:SELECTION) ON TUSTATE,'ERROR.':PORTNO
STATUS = FTE.NO.ITEMS.FOUND
END
IF APPLICATION = 'GUI' AND SELECTCOUNT > MAX.GUI.ITEMS THEN
STATUS = FTE.TOO.MANY.ITEMS.SELECTED
RETURN
END
*
IF QBH THEN CALL ROC.SET_454(QBH, "status", SELECTCOUNT:' items selected ....', ERR)
RETURN
*
*-* Build data
*
700 *
IF DEBUGFLAG THEN CRT "Building data without correlatives"
OUTCOUNT = 0; INCOUNT = 0; ID = 1; AC = 1; ITEM = NULL
LASTPERCENTAGE = 0; SELECTCOUNT = 0; OK = TRUE; OLD.ID = ""
*-* Check for Get List used in selection syntax
FIRSTONE = FIELD(TRIM(SELECTION), ' ', 1)
GLINDEX = INDEX('GET-LIST;GET.LIST;GL', FIRSTONE, 1)
IF NOT(GLINDEX) OR FIRSTONE = "" THEN
IF SQLATOR.FILE THEN
UDTEXECUTE SORT:"SELECT ":HOSTFILENAME:" ":SELECT.CRITERIA CAPTURING OUTPUT; !*UDT*!
END ELSE
EXECUTE SORT:"SELECT ":HOSTFILENAME:" ":SELECT.CRITERIA CAPTURING OUTPUT; !*-MRX*!
END
!@!PERFORM SORT:"SELECT ":HOSTFILENAME:" ":SELECT.CRITERIA RTNLIST CAPTURING OUTPUT; !*MRX*!
END ELSE
IF SQLATOR.FILE THEN
UDTEXECUTE SELECT.CRITERIA:" ONSERVER ":SQLATOR.SERVER CAPTURING OUTPUT; !*UDT*!
END ELSE
EXECUTE SELECT.CRITERIA CAPTURING OUTPUT; !*-MRX*!
END
!@!PERFORM SELECT.CRITERIA CAPTURING OUTPUT; !*MRX*!
END
GOSUB 640; * count items selected
IF STATUS THEN RETURN
*-* get file handle for host file
OPEN '',HOSTFILENAME TO F.FILE ELSE
STATUS = FTE.HOSTFILE.OPEN.ERROR
RETURN
END
*-* process list
LOOP
READNEXT FORMATTEDID ELSE
GOSUB 850; * process break and grand total
OK = FALSE
END
WHILE OK DO
LOCATE FORMATTEDID IN OLD.ID<1> SETTING POS ELSE POS = 0
IF NOT(POS) THEN
*-* FORMATTEDITEM record written to Xfer data file by REFORMAT verb
READ FORMATTEDITEM FROM F.FILE, FORMATTEDID ELSE
WRITE (FTE.ITEM.READ.ERROR:AM:'TU.BUILD.XFER.DATA':AM:'TUXFER.DATA.':PORTNO:' ':FORMATTEDID) ON TUSTATE,'ERROR.':PORTNO
STATUS = FTE.ITEM.READ.ERROR
RETURN
END
OLD.ID<1,-1> = FORMATTEDID
NEW.FORMATTEDITEM = ""; DICT.ID.USED = FALSE; IDX = 1
FOR X = 1 TO DICTCOUNT
ATT = HEADER<HED.POSITION,X>
IF ATT > 0 THEN
NEW.FORMATTEDITEM<IDX> = FORMATTEDITEM<ATT>
END ELSE
DICT.ID.USED = TRUE
NEW.FORMATTEDITEM<IDX> = FORMATTEDID
END
*-* need to process any conversion.
IF HEADER<HED.OCONV,X> # "" THEN
NEW.FORMATTEDITEM<IDX> = OCONV(NEW.FORMATTEDITEM<IDX>, HEADER<HED.OCONV, X>)
END
IDX = IDX + 1
NEXT X
FORMATTEDITEM = NEW.FORMATTEDITEM
GOSUB 800; * process each record
IF STATUS THEN OK = FALSE
END
REPEAT
RETURN
*
*-* process each record
*
800 *
AMC = COUNT(FORMATTEDITEM, AM) + (FORMATTEDITEM # '')
*-* build and array showing value marks per attribute in record
VMC = 1; LASTVMC = 1
IF INDEX(FORMATTEDITEM, VM, 1) THEN
FOR I = 1 TO AMC
V = COUNT(FORMATTEDITEM<I>,VM) + (FORMATTEDITEM # '')
IF V > VMC THEN VMC = V
LASTVMC<I> = V
NEXT I
END
*-* build item from formatted item
FOR J = 1 TO VMC
IF HAVE.BREAK THEN
FOR I = 1 TO AMC
IF (J > LASTVMC<I>) AND FORMAT.DATA THEN K = LASTVMC<I> ELSE K = J
FIELD = FORMATTEDITEM<I + USINGMENTOR, K>
GOSUB 860; * check for BREAK-ON
NEXT I
END
FOR I = 1 TO AMC
IF (J > LASTVMC<I>) AND FORMAT.DATA THEN K = LASTVMC<I> ELSE K = J
FIELD = FORMATTEDITEM<I + USINGMENTOR, K>
IF HEADER<HED.OCONV, I>[1,2] = 'ML' OR HEADER<HED.OCONV, I>[1,2] = 'MR' THEN
IF FIELD[1,1] = '$' THEN
FIELD = FIELD[2, LEN(FIELD)]
END
LOOP
P = INDEX(FIELD, ',', 1)
WHILE (P > 0) DO
FIELD = FIELD[1, P - 1]:FIELD[P + 1, LEN(FIELD)]
REPEAT
END
IF HAVE.TOTAL THEN
IF HEADER<HED.BORT, I> = 'T' THEN
IF NUM(FIELD) THEN
TOTALS<I, DICTCOUNT + 1> = TOTALS<I, DICTCOUNT + 1> + FIELD
FOR D = DICTCOUNT TO 1 STEP -1
IF HEADER<HED.BORT, D> = 'B' THEN
TOTALS<I, D> = TOTALS<I, D> + FIELD
END
NEXT D
END
END
END
IF NOT(DET.SUPP) THEN
IF APPLICATION = 'GUI' THEN
ITEM<AC, I> = FORMATTEDITEM<I + USINGMENTOR, K>
END ELSE
ITEM<AC, I> = FIELD
END
END
NEXT I
IF NOT(DET.SUPP) THEN
GOSUB 900; * check for overflow of cache
END
NEXT J
*-* update progress status
INCOUNT = INCOUNT + 1
IF SELECTCOUNT = 0 THEN
PERCENTAGE = 0
END ELSE
PERCENTAGE = INT((INCOUNT/SELECTCOUNT) * 100)
IF PERCENTAGE > 10 THEN PERCENTAGE = INT(PERCENTAGE/10) * 10
END
IF PERCENTAGE # LASTPERCENTAGE THEN
IF QBH THEN
PERCSTRING = 'Formatting data .... ':PERCENTAGE "R####":" %"
CALL ROC.SET_454(QBH, "status", PERCSTRING, ERR)
END
LASTPERCENTAGE = PERCENTAGE
END
RETURN
*
*-* process break and grand total
*
850 *
IF DEBUGFLAG THEN CRT "Processing break and grand total"
IF OUTCOUNT = 0 THEN
WRITE (FTE.NO.ITEMS.FOUND:AM:HOSTFILENAME:AM:SELECTION) ON TUSTATE,'ERROR.':PORTNO
STATUS = FTE.NO.ITEMS.FOUND
RETURN
END
*-* Break processing
BREAK.FOUND = FALSE
IF HAVE.BREAK THEN
FORMATTEDITEM = ''
K = 1
FIELD = FINAL
FOR I = 1 TO DICTCOUNT UNTIL BREAK.FOUND
IF HEADER<HED.BORT, I> = 'B' THEN
GOSUB 860; * check for BREAK-ON
BREAK.FOUND = TRUE
END
NEXT I
END
GOSUB 870; * grand total
RETURN
*
*-* check for BREAK-ON
*
860 *
IF BREAK.ON<I> # FIELD AND BREAK.ON<I> # NO.BREAK THEN
IF DEBUGFLAG THEN
CRT "Checking for BREAK-ON"
CRT "Should be breaking field ":I:" on ":BREAK.ON<I>
CRT "Current field value is ":FIELD
END
*-* force BREAK on all lower level BREAK-ONs
FOR D = DICTCOUNT TO I STEP -1
IF HEADER<HED.BORT, D> = 'B' THEN
IF BREAK.ON<D> # EMPTY THEN
IF DET.SUPP THEN
ITEM<AC,D> = BREAK.ON<D>
END ELSE
ITEM<AC,D> = '***'
END
FOR K = 1 TO DICTCOUNT
IF HEADER<HED.BORT, K> = 'T' THEN
IF APPLICATION = 'GUI' AND HEADER<HED.OCONV, K> # '' THEN
ITEM<AC, K> = OCONV(ICONV(TOTALS<K, D>, HEADER<HED.OCONV, K>), HEADER<HED.OCONV, K>)
END ELSE
ITEM<AC, K> = TOTALS<K, D>
END
TOTALS<K, D> = ''
END
NEXT K
GOSUB 900; * check for overflow of cache
END
BREAK.ON<D> = FORMATTEDITEM<D + USINGMENTOR, 1>
END
NEXT D
BREAK.ON<I> = FIELD
IF DEBUGFLAG THEN CRT "New break value for field ":I:" is ":BREAK.ON<I>
END
RETURN
*
*-* grand total
*
870 *
IF DEBUGFLAG THEN CRT "Grand Total"
IF HAVE.TOTAL AND NOT(TOTAL.SUPP) THEN
ITEM<AC> = '***'
FOR I = 1 TO DICTCOUNT
IF HEADER<HED.BORT,I> = 'T' THEN
IF APPLICATION = 'GUI' AND HEADER<HED.OCONV, I> # '' THEN
ITEM<AC, I> = OCONV(ICONV(TOTALS<I, DICTCOUNT + 1>, HEADER<HED.OCONV, I>), HEADER<HED.OCONV, I>)
END ELSE
ITEM<AC, I> = TOTALS<I, DICTCOUNT + 1> + 0
END
END
NEXT I
OUTCOUNT = OUTCOUNT + 1
END
GOSUB 950; * write cache to disk
HEADER<HED.IDCOUNT> = ID - 1
HEADER<HED.RECORDCOUNT> = OUTCOUNT
HEADER<HED.XFERSIZE> = XFER.SIZE
WRITE HEADER ON TUXFER.DATA,'XFER.HEADER'
EXECUTE 'DELETE-LIST TUXFER.DATA.':PORTNO CAPTURING OUTPUT
STATUS = 0
RETURN
*
*-* Check for overflow of cache
*
900 *
OUTCOUNT = OUTCOUNT + 1
AC = AC + 1
IF LEN(ITEM) > BLK.SIZE THEN GOSUB 950
RETURN
*
*-* Write cache to disk
*
950 *
IF DEBUGFLAG THEN CRT "Flushing cache"
IF FIRST.WRITE THEN
IF INSERT.BLANK THEN
ITEM = "":AM:ITEM
END
IF COLUMN.HEADER THEN
OUTPUT.HEADER = TRIM(HEADER<HED.HEADING>)
ITEM = OUTPUT.HEADER:AM:ITEM
END
FIRST.WRITE = FALSE
END
WRITE ITEM ON TUXFER.DATA,'XFER.DATA.':ID
XFER.SIZE = XFER.SIZE + LEN(ITEM)
ID = ID + 1
AC = 1; ITEM = NULL
RETURN
*
*-* The END
*
END
