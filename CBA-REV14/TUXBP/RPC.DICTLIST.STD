SUBROUTINE RPC.DICTLIST.STD(ARRAY, VALUE, ERROR)
*
** SBClient Host 3GL API
** Copyright (C) Ardent Software Inc. 1998
** Copyright (C) UniData, Inc. 1996, 1997
** Copyright (C) System Builder Corporation. 1995
**
**      This software is the proprietary property and contains
**      trade secrets of Ardent Software, Inc. Any unauthorized use,
**      disclosure or duplication is strictly prohibited.
**      All rights reserved.
*
*************************************************************************
*-* Subroutine RPC.DICTLIST.STD(Array, Value, Error)
*-*
*-* This function will return the contents of a dictionary of the specified
*-* file.
*-*
*-* [P] Array    String containing the file name to be queried.
*-* [R] Value    A dictionary list string in the following format:
*-*
*-*              <1> Dictionary Name ]]]
*-*              <3> Dictionary Description ]]]
*-*              <4> Justification ]]]
*-*              <5> Length ]]]
*-*              <6> Oconv ]]]
*-*
*-* Where ] is a value mark in the attribute.
*-*
*-* [R] Error    A non 0 error code. 0 indicates success.
*************************************************************************
*
 INCLUDE TUBP USER.INCLUDE.H
 INCLUDE TUBP TU.API.H
 INCLUDE TUBP SPECIAL.H
 INCLUDE TUBP HEADER.H
 INCLUDE TUBP TU.ERRORCODES.H
 INCLUDE TUBP ROC.H
*
VALUE = ''; ERROR = 0; FILENAME = ARRAY<1>; DICTCOUNT = 0
*
IF FILENAME[1, 5] = 'DICT ' THEN
FILENAME = FILENAME[6, 999]
END
OPEN 'DICT',FILENAME TO DICT.FILE ELSE
VALUE = 'Illegal file DICT ':FILENAME
ERROR = FTE.HOSTFILE.OPEN.ERROR
RETURN
END
*
SQLATOR.FILE = FALSE
OPEN '','VOC' TO F.VOC ELSE VALUE = "Unable to open VOC"; ERROR = FTE.MD.OPEN.ERROR; RETURN; !*UDT*!
READ RFILE FROM F.VOC, FILENAME ELSE RFILE = ""; !*UDT*!
IF RFILE<1> = "FX" THEN SQLATOR.FILE = TRUE; !*UDT*!
*
IF SQLATOR.FILE THEN
UDTEXECUTE "SELECT DICT ":FILENAME CAPTURING RUBBISH; !*UDT*!
END ELSE
 INCLUDE TUBP SELECT.DICTS.H
END
*
FIELDLIST = ''; NLIST = ''; ALIST = ''; FLIST = ''
1 *
READNEXT ID ELSE GOTO 2
IF NUM(ID) THEN
LOCATE(ID,NLIST ; POS ; 'AR') ELSE
NLIST = INSERT(NLIST,POS ; ID)
END
END ELSE
IF ID MATCHES '1A1N0N' THEN
LOCATE(ID[2,999],FLIST,1 ; POS1 ; 'AR') ELSE
FLIST = INSERT(FLIST,1,POS1 ; ID[2,999])
FLIST = INSERT(FLIST,2,POS1 ; '')
END
LOCATE(ID[1,1],FLIST,2,POS1 ; POS2 ; 'AL') ELSE
FLIST = INSERT(FLIST,2,POS1, POS2 ; ID[1,1])
END
END ELSE
LOCATE(ID,ALIST ; POS ; 'AL') ELSE
ALIST = INSERT(ALIST,POS ; ID)
END
END
END
GOTO 1
2 *
VMC = COUNT(FLIST<1>, VM) + (FLIST<1> # '')
IF VMC THEN
FOR I = 1 TO VMC
SVMC = COUNT(FLIST<2, I>, SVM) + (FLIST<2> # '')
FOR J = 1 TO SVMC
ID = FLIST<2, I, J>:FLIST<1, I>
IF NLIST = '' THEN
NLIST = ID
END ELSE
NLIST = NLIST:AM:ID
END
NEXT J
NEXT I
END
IF NLIST # '' AND ALIST # '' THEN
FIELDLIST = NLIST:AM:ALIST
END ELSE
IF NLIST # '' THEN
FIELDLIST = NLIST
END ELSE
FIELDLIST = ALIST
END
END
FIELDCOUNT = COUNT(FIELDLIST, AM) + (FIELDLIST # '')
FOR I = 1 TO FIELDCOUNT
DICTNAME = FIELDLIST<I>
READ DICTDEF FROM DICT.FILE,DICTNAME THEN
IF DICTDEF[1,1] = 'A' OR DICTDEF[1,1] = 'S' OR DICTDEF[1,1] = 'X' THEN
DICTCOUNT = DICTCOUNT + 1
VALUE<HED.DICTNAME,DICTCOUNT> = DICTNAME; * name of dictionary definition
TEXT = DICTDEF<3>
GOSUB 100; * remove VM, SPACE and DOTS
VALUE<HED.HEADING,DICTCOUNT> = TEXT; * VALUE
VALUE<HED.JUST,DICTCOUNT> = DICTDEF<9>; * justification
VALUE<HED.LENGTH,DICTCOUNT> = DICTDEF<10>; * length
VALUE<HED.OCONV,DICTCOUNT> = DICTDEF<7>; * output CONVersion
END ELSE
IF DICTDEF[1,1] = 'D' OR DICTDEF[1,1] = 'I' OR DICTDEF[1,1] = "V" THEN
DICTCOUNT = DICTCOUNT + 1
VALUE<HED.DICTNAME,DICTCOUNT> = DICTNAME; * name of dictionary definition
TEXT = DICTDEF<4>
GOSUB 100
VALUE<HED.HEADING,DICTCOUNT> = TEXT
VALUE<HED.JUST,DICTCOUNT> = DICTDEF<5>[LEN(DICTDEF<5>), 1]
VALUE<HED.LENGTH,DICTCOUNT> = DICTDEF<5>[1, LEN(DICTDEF<5>) - 1]
VALUE<HED.OCONV,DICTCOUNT> = DICTDEF<3>
END
END
END
NEXT I
RETURN
*
100 *
L = LEN(TEXT)
LOOP
P = INDEX(TEXT, VM, 1)
WHILE (P > 0) DO
TEXT = TEXT[1, P - 1]:UNDER:TEXT[P + 1, L]
REPEAT
RETURN
END
