1000 * Send Packet ZPKT.TYPE ZLEN ZTXBUF
BEGIN CASE
CASE ZPKT.TYPE = ZPKT.START OR ZPKT.TYPE = ZPKT.INITACK OR ZPKT.TYPE = ZPKT.END OR ZPKT.TYPE = ZPKT.IDLE
FORMAT = ZFMT.HEXPKT
CASE 1
IF TX.HIGHBIT THEN
IF TX.CANKER THEN
FORMAT = ZFMT.KERMIT; KO = 1; KOC = 0
END ELSE
IF TX.CANASC THEN
FORMAT = ZFMT.ASCPKT
END ELSE
FORMAT = ZFMT.HEXPKT
END
END
END ELSE
FORMAT = ZFMT.BINPKT
END
END CASE
TXCANRLE = (TX.CANRLE AND ZPKT.TYPE = ZPKT.DATA)
HEXOUTPUT = (HEX.OUTPUT AND ZPKT.TYPE = ZPKT.DATA)
OUTP = ZDLE:FORMAT:ZPKT.TYPE
CRCRESULT = SEQ(ZPKT.TYPE)
IF ZLEN THEN
BEGIN CASE
CASE FORMAT = ZFMT.BINPKT
FOR L = 1 TO 8
GOSUB 1010
GOSUB 1110
NEXT L
BEGIN CASE
CASE HEXOUTPUT AND TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1040
GOSUB 1110
NEXT L
CASE HEXOUTPUT
FOR L = 9 TO ZLEN
GOSUB 1030
GOSUB 1110
NEXT L
CASE TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1020
GOSUB 1110
NEXT L
CASE 1
FOR L = 9 TO ZLEN
GOSUB 1010
GOSUB 1110
NEXT L
END CASE
CASE FORMAT = ZFMT.HEXPKT
FOR L = 1 TO 8
GOSUB 1010
GOSUB 1120
NEXT L
BEGIN CASE
CASE HEXOUTPUT AND TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1040
GOSUB 1120
NEXT L
CASE HEXOUTPUT
FOR L = 9 TO ZLEN
GOSUB 1030
GOSUB 1120
NEXT L
CASE TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1020
GOSUB 1120
NEXT L
CASE 1
FOR L = 9 TO ZLEN
GOSUB 1010
GOSUB 1120
NEXT L
END CASE
CASE FORMAT = ZFMT.ASCPKT
FOR L = 1 TO 8
GOSUB 1010
GOSUB 1100
NEXT L
BEGIN CASE
CASE HEXOUTPUT AND TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1040
GOSUB 1100
NEXT L
CASE HEXOUTPUT
FOR L = 9 TO ZLEN
GOSUB 1030
GOSUB 1100
NEXT L
CASE TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1020
GOSUB 1100
NEXT L
CASE 1
FOR L = 9 TO ZLEN
GOSUB 1010
GOSUB 1100
NEXT L
END CASE
CASE FORMAT = ZFMT.KERMIT
FOR L = 1 TO 8
GOSUB 1010
GOSUB 1100
NEXT L
BEGIN CASE
CASE HEXOUTPUT AND TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1040
GOSUB 1130
NEXT L
CASE HEXOUTPUT
FOR L = 9 TO ZLEN
GOSUB 1030
GOSUB 1130
NEXT L
CASE TXCANRLE
FOR L = 9 TO ZLEN
GOSUB 1020
GOSUB 1130
NEXT L
CASE 1
FOR L = 9 TO ZLEN
GOSUB 1010
GOSUB 1130
NEXT L
END CASE
END CASE
END
IF NOT(NON.RESILIENT) THEN CRCRESULT = ZLEN + 1
GOSUB 2100
OUTP = OUTP:ZDLE:ZFMT.PKTEND:HEXCRC
CRT OUTP:CHAR(13):
IF TU.TRACE THEN TRACE = 'O->':OCONV(OUTP, 'MCP'); GOSUB 6000
RETURN
1010 * get next char C & S with NO RLE encoding
C = ZTXBUF[L, 1]; S = SEQ(C)
CRCRESULT = CRCRESULT + S
RETURN
1020 * get next char C & S and test RLE encoding
C = ZTXBUF[L, 1]; S = SEQ(C)
CRCRESULT = CRCRESULT + S
IF ZTXBUF[L, 3] # C:C:C THEN
IF C = ZRLE.CHAR THEN OUTP = OUTP:ZRLE.CHAR
RETURN
END
RLE = 1
LOOP
C2 = ZTXBUF[L+RLE, 1]
WHILE C2 = C AND C2 # '' DO
RLE = RLE + 1
REPEAT
IF RLE > 2 THEN
IF RLE > 93 THEN RLE = 93
CRCRESULT = CRCRESULT + (S * (RLE - 1))
L = L + RLE - 1
OUTP = OUTP:ZRLE.CHAR:CHAR(RLE + 30)
END
IF C = ZRLE.CHAR THEN OUTP = OUTP:ZRLE.CHAR
RETURN
1030 * get next HEX char C & S with NO RLE encoding
C = ZTXBUF[L, 1]; S = SEQ(C)
L = L + 1; C = OCONV(C:ZTXBUF[L, 1], 'MCU')
S = ICONV(C, MX.CONV)
IF S # 255 THEN
C = CHAR(S)
END ELSE
IF FF.ALLOW THEN C = CHAR(S)
END
CRCRESULT = CRCRESULT + S
RETURN
1040 * get next HEX char C & S and test RLE encoding
C = ZTXBUF[L, 1]; S = SEQ(C)
L = L + 1; C = OCONV(C:ZTXBUF[L, 1], 'MCU')
S = ICONV(C, MX.CONV)
IF S # 255 THEN
C = CHAR(S)
END ELSE
IF FF.ALLOW THEN C = CHAR(S)
END
CRCRESULT = CRCRESULT + S
S2 = ZTXBUF[L-1, 2]
IF ZTXBUF[L+1, 2] # S2 THEN
IF C = ZRLE.CHAR THEN OUTP = OUTP:ZRLE.CHAR
RETURN
END
RLE = 1
LOOP
C2 = ZTXBUF[L+RLE, 1]
RLE = RLE + 1; C2 = OCONV(C2:ZTXBUF[L+RLE, 1], 'MCU')
S2 = ICONV(C2, MX.CONV)
WHILE S2 = S AND C2 # '' DO
RLE = RLE + 1
REPEAT
IF RLE > 4 THEN
RLE = INT(RLE / 2)
IF RLE > 93 THEN RLE = 93
CRCRESULT = CRCRESULT + (S * (RLE - 1))
L = L + (RLE * 2) - 2
OUTP = OUTP:ZRLE.CHAR:CHAR(RLE + 30)
END
IF C = ZRLE.CHAR THEN OUTP = OUTP:ZRLE.CHAR
RETURN
1100 * encode ASCII data
BEGIN CASE
CASE C = "/" OR C = "\"; OUTP = OUTP:C
CASE S > 127; S = S - 128; C = CHAR(S)
IF C = "/" THEN OUTP = OUTP:"\" ELSE OUTP = OUTP:"/"
END CASE
1110 * put Binary BYTE C into OUTP
IF S < 32 OR S = 127 OR S > 251 THEN
OUTP = OUTP:ZDLE
IF S >= 127 THEN
C = CHAR(S - 64)
END ELSE
C = CHAR(S + 64)
END
END
OUTP = OUTP:C
RETURN
1120 * encode HEX data
BEGIN CASE
CASE S > 127; C = OCONV(S, MX.CONV)
OUTP = OUTP:"\":OCONV(C, 'MCL')
CASE S = 127; OUTP = OUTP:ZDLE:CHAR(S - 64)
CASE S < 32; OUTP = OUTP:ZDLE:CHAR(S + 64)
CASE C = '\'; OUTP = OUTP:'\\'
CASE 1; OUTP = OUTP:C
END CASE
RETURN
1130 * encode KERMIT data
IF S < KS(KO, 2) OR S > KS(KO, 3) THEN
BEGIN CASE
CASE S >= KS(1,2) AND S <= KS(1,3); KO = 1
CASE S >= KS(2,2) AND S <= KS(2,3); KO = 2
CASE S >= KS(3,2) AND S <= KS(3,3); KO = 3
CASE S >= KS(4,2) AND S <= KS(4,3); KO = 4
END CASE
OUTP = OUTP:CHAR(126 - KO); KOC = KS(KO, 1)
END
OUTP = OUTP:CHAR(S - KOC)
RETURN
1200 * SEND TX Start packet
OUTP = "_f":SUPPRESS.STATUS:ASCII.MODE:SEMI:APPEND.MODE:CLOSEBRACE
OUTP = OUTP:DOS.FILE.NAME:SEMI:DESCRIPTION
CRT CHAR(27):OUTP:CHAR(27):'\':
IF TU.TRACE THEN TRACE = 'O->':OCONV(OUTP, 'MCP'); GOSUB 6000
RETURN
1210 * SEND RX Start packet
OUTP = "_f":SUPPRESS.STATUS:ASCII.MODE:OPENBRACE
OUTP = OUTP:DOS.FILE.NAME:SEMI:DESCRIPTION
CRT CHAR(27):OUTP:CHAR(27):'\':
IF TU.TRACE THEN TRACE = 'O->':OCONV(OUTP, 'MCP'); GOSUB 6000
RETURN
1230 * SEND RX Data Acknowledgement
POS = RXPOS; GOSUB 3000; ZTXBUF = HEXPOS
ZPKT.TYPE = ZPKT.DATAACK; ZLEN = 8; TXRETRIES = 0
GOSUB 1000
RETURN
1250 * SEND Abort sequence
CRT STR(ZDLE, 8):STR(CHAR(8), 8):
IF TU.TRACE THEN TRACE = 'O->Abort Sequence'; GOSUB 6000
RETURN
