SUBROUTINE RPC.FT.DICTLIST(ARRAY, VALUE, ERROR)
 INCLUDE TUBP USER.INCLUDE.H
*
** SBClient Host 3GL API
** Copyright (C) Ardent Software Inc. 1998
** Copyright (C) UniData, Inc. 1996, 1997
** Copyright (C) System Builder Corporation. 1995
**
**      This software is the proprietary property and contains
**      trade secrets of Ardent Software, Inc. Any unauthorized use,
**      disclosure or duplication is strictly prohibited.
**      All rights reserved.
*
*
* Description : Stored Procedure To Retreive A DICT List
*
 INCLUDE TUBP SPECIAL.H
*
 INCLUDE TUBP HEADER.H
*
*
VALUE = ''
ERROR = 0
FILENAME = ARRAY<1>
ACCTNAME = ARRAY<2>
*
IF TRIM(ACCTNAME)#'' THEN
MD.FILE = 'VOC'; !*PI/O,PR1ME,UDT,UDTVMS,UP,UV*!
!@!MD.FILE = 'MD'; !*ADDS,ALTOS,AP,GA,MRX,PICK,SEQ,ULT*!
OPEN MD.FILE TO MDFL ELSE
MD.FILE = 'MD'
OPEN MD.FILE TO MDFL ELSE ERROR = 201; RETURN
END
QREC = ''
QREC<1> = 'Q'
QREC<2> = ACCTNAME
QREC<3> = FILENAME
WRITE QREC ON MDFL,'QFILE'
FILENAME = 'QFILE'
END
*
IF FILENAME[1, 5] = 'DICT ' THEN
FILENAME = FILENAME[6, 999]
END
OPEN 'DICT',FILENAME TO DICT.FILE ELSE
VALUE = 'Illegal file DICT ':FILENAME
ERROR = 1
RETURN
END
DICTCOUNT = 0
!@!EXECUTE 'SELECT DICT ':FILENAME:' IF *A1 = "A]" "S]" "X]"' CAPTURING OUTPUT; !*PICK,AP,SEQ,ADDS,ULT,GA,ALTOS*!
!@!PERFORM 'SELECT DICT ':FILENAME:' IF *A1 = "A]" "S]" "X]"' RTNLIST CAPTURING OUTPUT ; !*MRX*!
EXECUTE 'SELECT DICT ':FILENAME:' IF F1 = "A]" "S]" "X]" "D]" "I]" "V]"' CAPTURING OUTPUT          ;!*UV,UP,UDT,UDTVMS,PI/O,PR1ME*!
FIELDLIST = ''
NLIST = ''
ALIST = ''
FLIST = ''
1 *
READNEXT ID ELSE GOTO 2
IF NUM(ID) THEN
LOCATE(ID,NLIST ; POS ; 'AR') ELSE
NLIST = INSERT(NLIST,POS ; ID)
END
END ELSE
IF ID MATCHES '1A1N0N' THEN
LOCATE(ID[2,999],FLIST,1 ; POS1 ; 'AR') ELSE
FLIST = INSERT(FLIST,1,POS1 ; ID[2,999])
FLIST = INSERT(FLIST,2,POS1 ; '')
END
LOCATE(ID[1,1],FLIST,2,POS1 ; POS2 ; 'AL') ELSE
FLIST = INSERT(FLIST,2,POS1, POS2 ; ID[1,1])
END
END ELSE
LOCATE(ID,ALIST ; POS ; 'AL') ELSE
ALIST = INSERT(ALIST,POS ; ID)
END
END
END
!*!      FIELDLIST<-1> = ID
GOTO 1
2 *
VMC = COUNT(FLIST<1>, VM) + (FLIST<1> # '')
IF VMC THEN
FOR I = 1 TO VMC
SVMC = COUNT(FLIST<2, I>, SVM) + (FLIST<2> # '')
FOR J = 1 TO SVMC
ID = FLIST<2, I, J>:FLIST<1, I>
IF NLIST = '' THEN
NLIST = ID
END ELSE
NLIST = NLIST:AM:ID
END
NEXT J
NEXT I
END
IF NLIST # '' AND ALIST # '' THEN
FIELDLIST = NLIST:AM:ALIST
END ELSE
IF NLIST # '' THEN
FIELDLIST = NLIST
END ELSE
FIELDLIST = ALIST
END
END
FIELDCOUNT = COUNT(FIELDLIST, AM) + (FIELDLIST # '')
FOR I = 1 TO FIELDCOUNT
DICTNAME = FIELDLIST<I>
READ DICTDEF FROM DICT.FILE,DICTNAME THEN
IF DICTDEF[1,1] = 'A' OR DICTDEF[1,1] = 'S' OR DICTDEF[1,1] = 'X' THEN
DICTCOUNT = DICTCOUNT + 1
VALUE<HED.DICTNAME,DICTCOUNT> = DICTNAME; * name of dictionary definition
TEXT = DICTDEF<3>
GOSUB 100; * remove VM, SPACE and DOTS
VALUE<HED.HEADING,DICTCOUNT> = TEXT; * VALUE
VALUE<HED.JUST,DICTCOUNT> = DICTDEF<9>; * justification
VALUE<HED.LENGTH,DICTCOUNT> = DICTDEF<10>; * length
VALUE<HED.OCONV,DICTCOUNT> = DICTDEF<7>; * output CONVersion
END ELSE
IF DICTDEF[1,1] = 'D' OR DICTDEF[1,1] = 'I' THEN
DICTCOUNT = DICTCOUNT + 1
VALUE<HED.DICTNAME,DICTCOUNT> = DICTNAME; * name of dictionary definition
TEXT = DICTDEF<4>
GOSUB 100
VALUE<HED.HEADING,DICTCOUNT> = TEXT
VALUE<HED.JUST,DICTCOUNT> = DICTDEF<5>[LEN(DICTDEF<5>), 1]
VALUE<HED.LENGTH,DICTCOUNT> = DICTDEF<5>[1, LEN(DICTDEF<5>) - 1]
VALUE<HED.OCONV,DICTCOUNT> = DICTDEF<3>
END
END
END
NEXT I
RETURN
*
100 *
L = LEN(TEXT)
LOOP
P = INDEX(TEXT, VM, 1)
WHILE (P > 0) DO
TEXT = TEXT[1, P - 1]:UNDER:TEXT[P + 1, L]
REPEAT
RETURN
END
