*****************************************************************
*
* REVISION    - [08.0]
*
* PROGRAM      - PROG.ANAL
*
* BY           - NICK AMENDOLA,  COMPUTER BUSINESS ASSOCIATES
*
* DATE         - 06/01/84
*
* DESCRIPTION
*
*  This program will scan a source program and build a cross-reference
*  file containing the following information:
*
*       1.  Source file name
*       2.  Author
*       3.  Date written
*       4.  Program narratives
*       5.  Program/Subroutine indicator
*       6.  Files referenced
*       7.  Files opened
*       8.  Files read
*       9.  Files locked
*      10.  Files written
*      11.  Files deleted
*      12.  Subroutines called
*      13.  Programs calling this subroutine
*      14.  Screens used
*      15.  Copy library calls
*
*****************************************************************
*
*COPY>CPYLIB>PROG.FILE.XREF
*COPY>CPYLIB>CHAR
*
*---- DEFINE VARIABLES
*
      DIM FVAR(200)
*
*---- INITIALIZATION
*
      PROMPT ""
      MAT PFX.REC = ''
      LINE.COUNT = 0
      FND.ENDDOC = 0
      FND.DESC = 0
      ST = 0
      EN = 0
      ERRMSG = ''
      VERBS = ""
      VERBS<1,-1> = "OPEN"
      VERBS<1,-1> = "MATREAD"
      VERBS<1,-1> = "MATREADU"
      VERBS<1,-1> = "READ"
      VERBS<1,-1> = "READU"
      VERBS<1,-1> = "READV"
      VERBS<1,-1> = "READVU"
      VERBS<1,-1> = "READUV"
      VERBS<1,-1> = "MATWRITE"
      VERBS<1,-1> = "MATWRITEU"
      VERBS<1,-1> = "WRITE"
      VERBS<1,-1> = "WRITEU"
      VERBS<1,-1> = "WRITEV"
      VERBS<1,-1> = "WRITEVU"
      VERBS<1,-1> = "WRITEUV"
      VERBS<1,-1> = "DELETE"
      VERBS<1,-1> = "CALL"
      VERBS<1,-1> = "SUBROUTINE"
      VERBS<1,-1> = "COPY"
      VERBS<1,-1> = "ECD.SCRN.NAME"
      VERBS<1,-1> = "SCREEN"
*
*---- OPEN FILES
*
100*
      PRINT @(-1):
      PRINT @(0,0):"VERCOM":
      PRINT @(25,0):"CREATE PROGRAM DOCUMENTATION":
      PRINT @(72,0):OCONV(DATE(),"D2/"):
      PRINT @(0,1):STR("-",80):
      PRINT @(0,22):STR("-",80):
110*
      FOR ROW = 2 TO 19
         PRINT @(0,ROW):CL:
      NEXT ROW
      PRINT @(20,10):CL:"Enter Program Source File - ":
      INPUT PROG.FILE.NAME
      PRINT @(0,23):CL:
      IF PROG.FILE.NAME = "" OR PROG.FILE.NAME = "END" THEN
         ERRMSG = ''
         GOTO 99999
      END
      OPEN "",PROG.FILE.NAME TO PROG.FILE ELSE
         ERRMSG = "CANNOT OPEN ":PROG.FILE.NAME:" FILE"
         GOSUB 95000
         GOTO 110
      END
*
      OPEN "","PROG.FILE.XREF" TO PROG.FILE.XREF ELSE
         ERRMSG = "CANNOT OPEN PROG.FILE.XREF FILE"
         GOTO 99999
      END
*
      OPEN "","CPYLIB" TO CPYLIB ELSE
         ERRMSG = "CANNOT OPEN CPYLIB FILE"
         GOTO 99999
      END
*
*     OPEN "DICT","MD" TO MD ELSE
*        ERRMSG = "CANNOT OPEN MASTER DICTIONARY"
*        GOTO 99999
*     END
*
      MATREAD FVAR FROM CPYLIB, "FILE.VARS" ELSE
         MAT FVAR = ""
      END
      FILE.NAMES = ""
      FILE.NAMES.CNT = 0
      FOR I = 1 TO 100
         FVAR.LINE = TRIM(FVAR(I))
         IF FIELD(FVAR.LINE," ",1) = "EQU" THEN
            FILE.NAMES<1,-1> = TRIM(FIELD(FVAR.LINE," ",2))
            FILE.NAMES.CNT = FILE.NAMES.CNT + 1
         END
      NEXT I
*
*---- MAIN PROCESSING
*
1000*
      PRINT @(20,12):CL:'Enter Program Name or "ALL" - ':
      INPUT NAME.PROGRAM
      PRINT @(0,23):CL:
      BEGIN CASE
      CASE NAME.PROGRAM = "" OR NAME.PROGRAM = "END" 
         GOTO 110
      CASE NAME.PROGRAM = "ALL" 
         PRINT @(20,14):CL:"CLEAR FILE OK (Y) - ":
         INPUT OPTI
         IF OPTI = "Y" THEN
            CLEARFILE PROG.FILE.XREF
         END
         SELECT PROG.FILE
1010*
         READNEXT PROG.NAME ELSE
            PRINT @(0,23):"** COMPLETED **":
            GOTO 110
         END
         IF PROG.NAME[1,1] = "$" THEN GOTO 1010
         IF PROG.NAME[1,1] = "_" THEN GOTO 1010
*           READ MD.REC FROM MD, PROG.NAME ELSE GOTO 1010
         PROG = ''
         READ PROG FROM PROG.FILE, PROG.NAME ELSE GOTO 1010
         GOSUB 1100
*           PRINT PROG.NAME
         GOTO 1010
      CASE 1
         PROG.NAME = NAME.PROGRAM
         PROG = ''
         READ PROG FROM PROG.FILE,PROG.NAME ELSE 
            PRINT @(0,23):CL:"INVALID PROGRAM NAME":
            GOTO 1000
         END
         GOSUB 1100
         PRINT @(0,23):CL:"** COMPLETED **":
         GOTO 1000
      END CASE
*---- PROCESS PROGRAM
1100*
      MATREAD PFX.REC FROM PROG.FILE.XREF, PROG.NAME ELSE
         MAT PFX.REC = ""
      END
      TEMP = PFX.CALLED.BY.PROG
      MAT PFX.REC = ""
      LINE.CNT = 0
      PFX.CALLED.BY.PROG = TEMP
      LINE.CNT = COUNT(PROG,AM) + (PROG # '')
*     FOR I = PROG.MAX TO 1 STEP -1 WHILE LINE.CNT = 0
*        IF PROG(I) # "" THEN
*           LINE.CNT = I
*        END
*     NEXT I
      FOR L = 1 TO LINE.CNT
         PROG.LINE = PROG<L>
         IF PROG.LINE[1,6] = "*COPY>" OR PROG.LINE[1,6] = "*COPY " THEN
            PROG.LINE = "COPY ":PROG.LINE[7,99]
         END
         IF PROG.LINE[1,7] = "**COPY>" OR PROG.LINE[1,7] = "**COPY " THEN
            PROG.LINE = "COPY ":PROG.LINE[8,99]
         END
         IF PROG.LINE[1,1] = "*" AND FND.ENDDOC = 0 THEN
            GOSUB 11000
            GOTO 1599
         END
         IF TRIM(PROG.LINE)[1,6] = "SCREEN" THEN
            IF TRIM(PROG.LINE)[1,13] = "SCREEN DEFINE" THEN
               STMT.CNT = COUNT(PROG.LINE,";") + (PROG.LINE # "")
               PROG.LINE = "SCREEN ":FIELD(PROG.LINE,";",STMT.CNT)
            END ELSE
               GOTO 1599
            END
         END
         STMT.CNT = COUNT(PROG.LINE,";") + (PROG.LINE # "")
         FOR S = 1 TO STMT.CNT
            PROG.STMT = TRIM(FIELD(PROG.LINE,";",S))
            IF PROG.STMT[1,1] = "*" THEN GOTO 1595
            IF PROG.STMT[1,11] = "SUBROUTINE(" THEN
               PROG.STMT = "SUBROUTINE (":PROG.STMT[12,99]
            END
            IF PROG.STMT[1,13] = "ECD.SCRN.NAME" THEN
               PROG.STMT = "ECD.SCRN.NAME ":PROG.STMT[14,99]
            END
            PTR1 = INDEX(PROG.STMT," ",1)
            IF PTR1 = 0 THEN GOTO 1595
            PROG.VERB = PROG.STMT[1,PTR1-1]
            LOCATE PROG.VERB IN VERBS<1>,1 SETTING FND ELSE GOTO 1595
            BEGIN CASE
            CASE PROG.VERB = "OPEN"
               GOSUB 2000
            CASE PROG.VERB[1,4] = "READ"
               IF PROG.VERB[5,1] = "U" OR PROG.VERB[6,1] = "U" THEN
                  LOCK.FLAG = 1
               END ELSE
                  LOCK.FLAG = 0
               END
               GOSUB 3000
            CASE PROG.VERB[1,7] = "MATREAD"
               IF PROG.VERB[8,1] = "U" THEN
                  LOCK.FLAG = 1
               END ELSE
                  LOCK.FLAG = 0
               END
               GOSUB 3000
            CASE PROG.VERB[1,5] = "WRITE"
               IF PROG.VERB[6,1] = "U" OR PROG.VERB[7,1] = "U" THEN
                  LOCK.FLAG = 1
               END ELSE
                  LOCK.FLAG = 0
               END
               GOSUB 4000
            CASE PROG.VERB[1,8] = "MATWRITE"
               IF PROG.VERB[9,1] = "U" THEN
                  LOCK.FLAG = 1
               END ELSE
                  LOCK.FLAG = 0
               END
               GOSUB 4000
            CASE PROG.VERB = "DELETE"
               GOSUB 5000
            CASE PROG.VERB = "CALL"
               GOSUB 6000
            CASE PROG.VERB = "SUBROUTINE"
               PFX.SUBR.FLAG = "X"
            CASE PROG.VERB = "COPY"
               GOSUB 8000
            CASE PROG.VERB = "ECD.SCRN.NAME"
               GOSUB 9000
            CASE PROG.VERB = "SCREEN"
               GOSUB 9100
            END CASE
1595*
         NEXT S
1599*
      NEXT L
*
*
      PFX.SOURCE.FILE = PROG.FILE.NAME
      MATWRITE PFX.REC ON PROG.FILE.XREF, PROG.NAME
*
      PROG.CALLED = PFX.PROG.CALLED
      PROG.CALLED.CNT = COUNT(PROG.CALLED, VM) + (PROG.CALLED # "")
      FOR N = 1 TO PROG.CALLED.CNT
         MATREAD PFX.REC FROM PROG.FILE.XREF, PROG.CALLED<1,N> ELSE
            MAT PFX.REC = ""
            PFX.SUBR.FLAG = "X"
         END
         LOCATE PROG.NAME IN PFX.CALLED.BY.PROG<1>,1 BY "AL" SETTING CP ELSE
            PFX.CALLED.BY.PROG = INSERT(PFX.CALLED.BY.PROG,1,CP,0,PROG.NAME)
         END
         MATWRITE PFX.REC ON PROG.FILE.XREF, PROG.CALLED<1,N>
      NEXT N
      FND.DESC = 0
      FND.ENDDOC = 0
      LINE.COUNT = 0
      ST = 0
      EN = 0
      RETURN
*
*---- PROCESS "OPEN" VERB
*
2000*
      PTR2 = INDEX(PROG.STMT," TO ",1)
      IF PTR2 = 0 THEN
         GOSUB 90000
         RETURN
      END
      LINE.SEG = TRIM(PROG.STMT[PTR2+4,99])
      PTR3 = INDEX(LINE.SEG," ",1)
      IF PTR3 = 0 THEN
         GOSUB 90000
         RETURN
      END
      FNAME = TRIM(LINE.SEG[1,PTR3-1])
      GOSUB 10000
      PFX.OPEN.FLAG<1,FN> = "X"
      RETURN
*
*---- PROCESS "READ" VERB
*
3000*
      PTR2 = INDEX(PROG.STMT," FROM ",1)
      IF PTR2 = 0 THEN
         GOSUB 90000
         RETURN
      END
      LINE.SEG = TRIM(PROG.STMT[PTR2+6,99])
      PTR3 = INDEX(LINE.SEG,",",1)
      IF PTR3 = 0 THEN
         GOSUB 90000
         RETURN
      END
      FNAME = TRIM(LINE.SEG[1,PTR3-1])
      GOSUB 10000
      IF LOCK.FLAG THEN
         PFX.READ.FLAG<1,FN> = "XX"
      END ELSE
         PFX.READ.FLAG<1,FN> = "X" : PFX.READ.FLAG<1,FN>[2,1]
      END
      RETURN
*
*---- PROCESS "WRITE" VERB
*
4000*
      PTR2 = INDEX(PROG.STMT," ON ",1)
      IF PTR2 = 0 THEN
         PTR2 = INDEX(PROG.STMT," TO ",1)
      END
      IF PTR2 = 0 THEN
         GOSUB 90000
         RETURN
      END
      LINE.SEG = TRIM(PROG.STMT[PTR2+4,99])
      PTR3 = INDEX(LINE.SEG,",",1)
      IF PTR3 = 0 THEN
         GOSUB 90000
         RETURN
      END
      FNAME = TRIM(LINE.SEG[1,PTR3-1])
      GOSUB 10000
      IF LOCK.FLAG THEN
         PFX.WRITE.FLAG<1,FN> = "XX"
      END ELSE
         PFX.WRITE.FLAG<1,FN> = "X" : PFX.WRITE.FLAG<1,FN>[2,1]
      END
      RETURN
*
*---- PROCESS "DELETE" VERB
*
5000*
      LINE.SEG = TRIM(PROG.STMT[PTR1+1,99])
      PTR3 = INDEX(LINE.SEG,",",1)
      IF PTR3 = 0 THEN
         GOSUB 90000
         RETURN
      END
      FNAME = TRIM(LINE.SEG[1,PTR3-1])
      GOSUB 10000
      PFX.DELETE.FLAG<1,FN> = "X"
      RETURN
*
*---- PROCESS "CALL" VERB
*
6000*
      LINE.SEG = TRIM(PROG.STMT[PTR1+1,99])
      PTR2 = INDEX(LINE.SEG,"(",1)
      IF PTR2 = 0 THEN
         PNAME = TRIM(LINE.SEG[1,99])
      END ELSE
         PNAME = TRIM(LINE.SEG[1,PTR2-1])
      END
      LOCATE PNAME IN PFX.PROG.CALLED<1>,1 BY "AL" SETTING PC ELSE
         PFX.PROG.CALLED = INSERT(PFX.PROG.CALLED,1,PC,0,PNAME)
      END
      RETURN
*
*---- PROCESS "COPY" STATEMENT
*
8000*
      LINE.SEG = TRIM(FIELD(PROG.STMT," ",2))
      SEP.CNT = COUNT(LINE.SEG,">") + (LINE.SEG # "")
      IF SEP.CNT > 0 THEN
         INSERT.ITEM = FIELD(LINE.SEG,">",SEP.CNT)
         LOCATE INSERT.ITEM IN PFX.CPYLIB<1>,1 BY "AL" SETTING CP ELSE
            PFX.CPYLIB = INSERT(PFX.CPYLIB,1,CP,0,INSERT.ITEM)
            LOCATE INSERT.ITEM IN FILE.NAMES<1>,1 SETTING FND ELSE FND = 0
            IF FND THEN
               FNAME = INSERT.ITEM
               GOSUB 10000
            END
         END
      END
      RETURN
*
*---- LOCATE SCREEN NAME
*
9000*
      LINE.SEG = TRIM(FIELD(PROG.STMT,"=",2))
      SEP.CNT = COUNT(LINE.SEG,":") + (LINE.SEG # "")
      FOR N = 1 TO SEP.CNT
         SCREEN.NAME = TRIM(FIELD(LINE.SEG,":",N))
         IF SCREEN.NAME # "AM" THEN
            SCREEN.NAME = SCREEN.NAME[2,LEN(SCREEN.NAME)-2]
            PFX.SCREEN<1,-1> = SCREEN.NAME
         END
      NEXT N
      RETURN
*
*---- LOCATE SCREEN NAME
*
9100*
      SCREEN.NAME = FIELD(PROG.STMT," ",2)
      PFX.SCREEN<1,-1> = SCREEN.NAME
      RETURN
*
*---- LOCATE FILE NAME
*
10000*
      LOCATE FNAME IN PFX.FILE.NAME<1>,1 BY "AL" SETTING FN ELSE
         PFX.FILE.NAME = INSERT(PFX.FILE.NAME,1,FN,0,FNAME)
         PFX.OPEN.FLAG = INSERT(PFX.OPEN.FLAG,1,FN,0,"")
         PFX.READ.FLAG = INSERT(PFX.READ.FLAG,1,FN,0,"")
         PFX.WRITE.FLAG = INSERT(PFX.WRITE.FLAG,1,FN,0,"")
         PFX.DELETE.FLAG = INSERT(PFX.DELETE.FLAG,1,FN,0,"")
      END
      RETURN
*
*---- Process Program documentation line
*
11000*
      BEGIN CASE
      CASE TRIM(PROG.LINE)[1,6] = "* DATE" OR TRIM(PROG.LINE)[1,5] = "*DATE"
         PFX.DATE.WRITTEN = ICONV(TRIM(FIELD(PROG.LINE,"-",2)),"D")
      CASE TRIM(PROG.LINE)[1,4] = "* BY" OR TRIM(PROG.LINE)[1,8] = "* AUTHOR" OR TRIM(PROG.LINE)[1,3] = "*BY" OR TRIM(PROG.LINE)[1,7] = "*AUTHOR"
         FOUND.FLG = 0
         ST = 1
         EN = 77
         FOR XX = 1 TO 100 UNTIL FOUND.FLG = 1
            IF PROG.LINE[XX,1] = '-' THEN
               ST = XX + 1
            END ELSE
               IF PROG.LINE[XX,1] = ',' THEN
                  EN = XX - ST
                  FOUND.FLG = 1
               END
            END
         NEXT XX
         PFX.WRITTEN.BY = TRIM(PROG.LINE[ST,EN])
      CASE TRIM(PROG.LINE)[1,13] = "* DESCRIPTION" AND NOT(FND.DESC)
         FND.DESC = 1
         PROG.LINE = TRIM(FIELD(PROG.LINE,"-",2))
         PROG.LINE = "*  ":PROG.LINE
      CASE TRIM(PROG.LINE)[1,12] = "*DESCRIPTION" AND NOT(FND.DESC)
         FND.DESC = 1
         PROG.LINE = TRIM(FIELD(PROG.LINE,"-",2))
         PROG.LINE = "*  ":PROG.LINE
      CASE TRIM(PROG.LINE)[1,6] = "* DESC" AND NOT(FND.DESC)
         FND.DESC = 1
         PROG.LINE = TRIM(FIELD(PROG.LINE,"-",2))
         PROG.LINE = "*  ":PROG.LINE
      CASE (TRIM(PROG.LINE)[1,7] = "*ENDDOC" OR TRIM(PROG.LINE)[1,6] = "*ENDOC" OR TRIM(PROG.LINE)[1,2] = "**") AND FND.DESC
         FND.ENDDOC = 1
         DESC.CNT = COUNT(PFX.DESC,VM) + (PFX.DESC # "")
         FOR N = DESC.CNT TO 1 STEP -1
            IF TRIM(PFX.DESC<1,N>) = "" AND TRIM(PFX.DESC<1,N+1>) = "" THEN
               PFX.DESC = DELETE(PFX.DESC,1,N,0)         ;* DELETE DUPLICATE AND TRAILING BLANK LINES
            END
         NEXT N
      END CASE
      IF FND.DESC AND NOT(FND.ENDDOC) THEN
         BEGIN CASE
         CASE PFX.DESC = "" AND LEN(PROG.LINE) < 4
         CASE 1
            LINE.COUNT = LINE.COUNT + 1
            PFX.DESC<1,LINE.COUNT> = PROG.LINE[2,LEN(PROG.LINE) - 1]
         END CASE
      END
      RETURN
*
*---- ERROR ROUTINE
*
90000*
      PRINT PROG.NAME "L#25" : OCONV(L,"MD0") "R#4" : " - " : PROG.STMT
      RETURN
95000*
      PRINT @(0,23):CL:ERRMSG:
      INPUT REPLY:
      PRINT @(0,23):CL:
      RETURN
99999*
      PRINT @(-1):
      IF ERRMSG # "" THEN
         PRINT ERRMSG:
         INPUT REPLY:
      END
      STOP
   END
