      SUBROUTINE SCREEN_CALC (EXPSTACK, TYPSTACK, SEPARATOR, FNAME, FPTR, RESULT, ERRMSG)
*COPY>CPYLIB>COM1
*********************************************************************
*
* PROGRAM - EXP.COMPUTE
*
* AUTHOR  - NICK AMENDOLA, COMPUTER BUSINESS ASSOCIATES
*
* DATE    - 11/19/90
*
* DESCRIPTION
*
* This program will calculate the result of the expression previously
* converted to reverse polish notation by the EXP.COMPILE subroutine.
*
* All variables in EXPSTACK must have been evaluated prior to calling
* this subroutine.
*
* EXPSTACK and TYPSTACK are not altered by this subtoutine.
*
*********************************************************************
*
*---- DEFINE EQUATES
*
*COPY>CPYLIB>FILE.VARS
*COPY>CPYLIB>CHAR
*COPY>CPYLIB>SYSCOM
MAT SYSCOM.REC =  ""; SYS.TYPE = 2
*
*---- INITIALIZATION
*
      IF SEPARATOR = "" THEN
         ESTACK = EXPSTACK
         TSTACK = TYPSTACK
      END ELSE
         ESTACK = ""
         TSTACK = ""
         ECNT = DCOUNT(TYPSTACK,SEPARATOR)
         FOR EPTR = 1 TO ECNT
            ESTACK<EPTR> = FIELD(EXPSTACK,SEPARATOR,EPTR)
            TSTACK<EPTR> = FIELD(TYPSTACK,SEPARATOR,EPTR)
         NEXT EPTR
      END
      RESULT = 0
      ERRMSG = ""
*
*---- MAIN PROCESSING
*
      EPTR = 0
      LOOP
         EPTR = EPTR + 1
         EVAL = ESTACK<EPTR>
         ETYP = TSTACK<EPTR>
         BEGIN CASE
         CASE ETYP = "V"
            GOSUB 1000
         CASE ETYP = "A"
            GOSUB 2000
         CASE ETYP = "R"
            GOSUB 3000
         CASE ETYP = "L"
            GOSUB 4000
         CASE ETYP[1,1] = "F"
            GOSUB 5000
         CASE ETYP = "C"
         CASE ETYP = "N"
         CASE ETYP = "X"
         CASE 1
            ERRMSG = "ILLEGAL DATA TYPE - ":ETYP
         END CASE
      WHILE DCOUNT(ESTACK,AM) > 1 AND ERRMSG = "" DO
      REPEAT
      RESULT = ESTACK
      GOTO 99999
*
*---- PROCESS VARIABLE TYPE
*
1000 *
      BEGIN CASE
      CASE EVAL = "DATE"
         ESTACK<EPTR> = DATE()
      CASE EVAL = "TIME"
         ESTACK<EPTR> = TIME()
      CASE EVAL = "AM"
         ESTACK<EPTR> = CHAR(254)
      CASE EVAL = "VM"
         ESTACK<EPTR> = CHAR(253)
      CASE EVAL = "SM"
         ESTACK<EPTR> = CHAR(252)
      END CASE
*     ERRMSG = "UNRESOLVED VARIABLE - ":EVAL
      RETURN
*
*---- PROCESS ARITHMETIC OPERATOR
*
2000 *
      BEGIN CASE
      CASE EVAL = "~"
         PCNT=1; PTYPE="N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
      CASE 1
         PCNT=2; PTYPE="N,N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
      END CASE
      BEGIN CASE
      CASE EVAL = "+"
         ESTACK<EPTR> = ESTACK<EPTR-2> + ESTACK<EPTR-1>
      CASE EVAL = "-"
         ESTACK<EPTR> = ESTACK<EPTR-2> - ESTACK<EPTR-1>
      CASE EVAL = "*"
         ESTACK<EPTR> = ESTACK<EPTR-2> * ESTACK<EPTR-1>
      CASE EVAL = "/"
         IF ESTACK<EPTR-1> + 0 = 0 THEN
            ESTACK<EPTR> = 0
         END ELSE
            ESTACK<EPTR> = ESTACK<EPTR-2> / ESTACK<EPTR-1>
         END
      CASE EVAL = "~"
         ESTACK<EPTR> = ESTACK<EPTR-1> * (-1)
      CASE EVAL = "^" OR EVAL = "**"
         ESTACK<EPTR> = ESTACK<EPTR-2> ^ ESTACK<EPTR-1>
      END CASE
      GOSUB 9000
      RETURN
*
*---- PROCESS RELATIONAL OPERATOR
*
3000 *
      PCNT=2; PTYPE="X,X"; GOSUB 8000
      IF ERRMSG # "" THEN RETURN
      ESTACK<EPTR> = 0
      BEGIN CASE
      CASE EVAL = "="
         IF ESTACK<EPTR-2> = ESTACK<EPTR-1> THEN ESTACK<EPTR> = 1
      CASE EVAL = "#" OR EVAL = "<>" OR EVAL = "><"
         IF ESTACK<EPTR-2> # ESTACK<EPTR-1> THEN ESTACK<EPTR> = 1
      CASE EVAL = "<"
         IF ESTACK<EPTR-2> < ESTACK<EPTR-1> THEN ESTACK<EPTR> = 1
      CASE EVAL = "<=" OR EVAL = "=<"
         IF ESTACK<EPTR-2> <= ESTACK<EPTR-1> THEN ESTACK<EPTR> = 1
      CASE EVAL = ">"
         IF ESTACK<EPTR-2> > ESTACK<EPTR-1> THEN ESTACK<EPTR> = 1
      CASE EVAL = ">=" OR EVAL = "=>"
         IF ESTACK<EPTR-2> >= ESTACK<EPTR-1> THEN ESTACK<EPTR> = 1
      END CASE
      GOSUB 9000
      RETURN
*
*---- PROCESS LOGICAL OPERATOR
*
4000 *
      PCNT=2; PTYPE="B,B"; GOSUB 8000
      IF ERRMSG # "" THEN RETURN
      ESTACK<EPTR> = 0
      BEGIN CASE
      CASE EVAL = "AND" OR EVAL = "&"
         IF ESTACK<EPTR-2> = "1" AND ESTACK<EPTR-1> = "1" THEN ESTACK<EPTR> = 1
      CASE EVAL = "OR" OR EVAL = "|"
         IF ESTACK<EPTR-2> = "1" OR ESTACK<EPTR-1> = "1" THEN ESTACK<EPTR> = 1
      END CASE
      GOSUB 9000
      RETURN
*
*---- PROCESS FUNCTION
*
5000 *
      BEGIN CASE
      CASE EVAL = "DATE"
         PCNT=0
         ESTACK<EPTR> = DATE()
      CASE EVAL = "TIME"
         PCNT=0
         ESTACK<EPTR> = TIME()
      CASE EVAL = "ABS"
         PCNT=1; PTYPE="N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = ABS(ESTACK<EPTR-1>)
      CASE EVAL = "INT"
         PCNT=1; PTYPE="N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = INT(ESTACK<EPTR-1>)
      CASE EVAL = "SQRT"
         PCNT=1; PTYPE="N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = SQRT(ESTACK<EPTR-1>)
      CASE EVAL = "SPACE"
         PCNT=1; PTYPE=">="; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = SPACE(ESTACK<EPTR-1>)
      CASE EVAL = "SUM"
         PCNT=1; PTYPE="X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = SUM(ESTACK<EPTR-1>)
      CASE EVAL = "ALPHA"
         PCNT=1; PTYPE="X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = ALPHA(ESTACK<EPTR-1>)
      CASE EVAL = "NOT"
         PCNT=1; PTYPE="B"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = NOT(ESTACK<EPTR-1>)
      CASE EVAL = "NUM"
         PCNT=1; PTYPE="X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = NUM(ESTACK<EPTR-1>)
      CASE EVAL = "ROUND"
         PCNT=1; PTYPE="N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         IF ESTACK<EPTR-1> >= 0 THEN
            ESTACK<EPTR> = INT(ESTACK<EPTR-1>+0.5)
         END ELSE
            ESTACK<EPTR> = INT(ESTACK<EPTR-1>-0.5)
         END
      CASE EVAL = "RNDUP"
         PCNT=1; PTYPE="N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         IF ESTACK<EPTR-1> >= 0 THEN
            ESTACK<EPTR> = INT(ESTACK<EPTR-1>+0.999999)
         END ELSE
            ESTACK<EPTR> = INT(ESTACK<EPTR-1>-0.999999)
         END
      CASE EVAL = "RNDDN"
         PCNT=1; PTYPE="N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         IF ESTACK<EPTR-1> >= 0 THEN
            ESTACK<EPTR> = INT(ESTACK<EPTR-1>)
         END ELSE
            ESTACK<EPTR> = INT(ESTACK<EPTR-1>-0.999999)
         END
      CASE EVAL = "MOD"
         PCNT=2; PTYPE="N,N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = MOD(ESTACK<EPTR-2>,ESTACK<EPTR-1>)
      CASE EVAL = "STR"
         PCNT=2; PTYPE="X,>="; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = STR(ESTACK<EPTR-2>,ESTACK<EPTR-1>)
      CASE EVAL = "OCONV"
         PCNT=2; PTYPE="X,X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = OCONV(ESTACK<EPTR-2>,ESTACK<EPTR-1>)
      CASE EVAL = "ICONV"
         PCNT=2; PTYPE="X,X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = ICONV(ESTACK<EPTR-2>,ESTACK<EPTR-1>)
      CASE EVAL = "PWR"
         PCNT=2; PTYPE="N,N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = PWR(ESTACK<EPTR-2>,ESTACK<EPTR-1>)
      CASE EVAL = "FIELD"
         PCNT=3; PTYPE="X,X,>"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = FIELD(ESTACK<EPTR-3>,ESTACK<EPTR-2>,ESTACK<EPTR-1>)
      CASE EVAL = "LOCVAL"
         PCNT=2; PTYPE="X,X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         SEARCHFLD = ESTACK<EPTR-2>
         LOCATE ESTACK<EPTR-1> IN SEARCHFLD<1>,1 SETTING P ELSE P=0
         ESTACK<EPTR> = P
      CASE EVAL = "IF"
         PCNT=3; PTYPE="B,X,X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         IF ESTACK<EPTR-3> THEN
            ESTACK<EPTR> = ESTACK<EPTR-2>
         END ELSE
            ESTACK<EPTR> = ESTACK<EPTR-1>
         END
      CASE EVAL = "INDEX"
         PCNT=3; PTYPE="X,X,>"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = INDEX(ESTACK<EPTR-3>,ESTACK<EPTR-2>,ESTACK<EPTR-1>)
      CASE EVAL = "SUBSTR"
         PCNT=3; PTYPE="X,N,N"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = ESTACK<EPTR-3>[ESTACK<EPTR-2>,ESTACK<EPTR-1>]
      CASE EVAL = "EXTRACT"
         PCNT=TSTACK<EPTR>[2,99]; PTYPE="X,>,>,>="; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         BEGIN CASE
         CASE PCNT = 2
            IF ESTACK<EPTR-1> < 1 THEN ESTACK<EPTR-1> = 999
            ESTACK<EPTR> = EXTRACT(ESTACK<EPTR-2>,ESTACK<EPTR-1>,0,0)
         CASE PCNT = 3
            IF ESTACK<EPTR-2> < 1 THEN ESTACK<EPTR-2> = 999
            IF ESTACK<EPTR-1> < 1 THEN ESTACK<EPTR-1> = 999
            ESTACK<EPTR> = EXTRACT(ESTACK<EPTR-3>,ESTACK<EPTR-2>,ESTACK<EPTR-1>,0)
         CASE PCNT = 4
            IF ESTACK<EPTR-3> < 1 THEN ESTACK<EPTR-3> = 999
            IF ESTACK<EPTR-2> < 1 THEN ESTACK<EPTR-2> = 999
            IF ESTACK<EPTR-1> < 1 THEN ESTACK<EPTR-1> = 999
            ESTACK<EPTR> = EXTRACT(ESTACK<EPTR-4>,ESTACK<EPTR-3>,ESTACK<EPTR-2>,ESTACK<EPTR-1>)
         END CASE
      CASE EVAL = "CONCAT" OR EVAL = ":"
         PCNT=2; PTYPE="X,X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = ESTACK<EPTR-2> : ESTACK<EPTR-1>
      CASE EVAL = "DCOUNT"
         PCNT=2; PTYPE="X,X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = DCOUNT(ESTACK<EPTR-2>,ESTACK<EPTR-1>)
      CASE EVAL = "TRIM"
         PCNT=1; PTYPE="X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = TRIM(ESTACK<EPTR-1>)
      CASE EVAL = "COUNT"
         PCNT=2; PTYPE="X,X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         ESTACK<EPTR> = COUNT(ESTACK<EPTR-2>,ESTACK<EPTR-1>)
      CASE EVAL = "READ"
         PCNT=3; PTYPE="X,>,X"; GOSUB 8000
         IF ERRMSG # "" THEN RETURN
         FVAR = ESTACK<EPTR-3>
         ATTR = ESTACK<EPTR-2>
         FKEY = ESTACK<EPTR-1>
         LOCATE FVAR IN FNAME<1>,1 SETTING FLOC ELSE FLOC = 0
         IF FLOC > 0 THEN
            READV REC FROM FILE.VARS(FPTR<FLOC>), FKEY,ATTR ELSE REC = ""
            ESTACK<EPTR> = REC
         END ELSE
            ESTACK<EPTR> = ""
         END
      END CASE
      GOSUB 9000
      RETURN
*
*---- EDIT ARGUMENTS
*
8000 *
      IF EPTR-1 < PCNT THEN
         ERRMSG = "INSUFFICIENT NUMBER OF ARGUMENTS"
      END ELSE
         FOR PPTR = 1 TO PCNT
            PTYP = FIELD(PTYPE,",",PPTR)
            AVAL = ESTACK<EPTR-PCNT+PPTR-1>
            BEGIN CASE
            CASE PTYP = "B" AND (AVAL # "0" AND AVAL # "1")
               ERRMSG = "INVALID BOOLEAN VALUE"
            CASE PTYP = "N" OR PTYP = ">" OR PTYP = "<" OR PTYP = ">=" OR PTYP = "<="
               BEGIN CASE
               CASE NOT(NUM(AVAL))
                  ERRMSG = "(":AVAL:") NON-NUMERIC FOUND WHERE NUMERIC REQUIRED"
               CASE AVAL = ""
                  AVAL = 0
               CASE PTYP = "N"
                  NULL
               CASE PTYP = ">"
                  BEGIN CASE
                  CASE AVAL = 0
                     ERRMSG = "ZERO WHERE POSITIVE REQUIRED"
                  CASE AVAL < 0
                     ERRMSG = "NEGATIVE NUMBER WHERE POSITIVE REQUIRED"
                  END CASE
               CASE PTYP = "<"
                  BEGIN CASE
                  CASE AVAL = 0
                     ERRMSG = "ZERO WHERE NEGATIVE REQUIRED"
                  CASE AVAL > 0
                     ERRMSG = "POSITIVE NUMBER WHERE NEGATIVE REQUIRED"
                  END CASE
               CASE PTYP = ">=" AND AVAL < 0
                  ERRMSG = "NEGATIVE NUMBER WHERE POSITIVE REQUIRED"
               CASE PTYP = "<=" AND AVAL > 0
                  ERRMSG = "POSITIVE NUMBER WHERE NEGATIVE REQUIRED"
               END CASE
            END CASE
         NEXT PPTR
      END
      RETURN
*
*---- COMPRESS STACK
*
9000 *
      FOR PPTR = 1 TO PCNT
         ESTACK = DELETE(ESTACK,EPTR-1,0,0)
         TSTACK = DELETE(TSTACK,EPTR-1,0,0)
         EPTR = EPTR - 1
      NEXT PPTR
      RETURN
*
*---- ERROR ROUTINE
*
90000 ERR.TYPE=1;CALL SYSCOM(MAT SYSCOM.REC);RETURN
* 90000 *
*       ERRMSG=CHANGE(ERRMSG,VM,"}")
*       PRINT @(0,23):@(-4):ERRMSG[1,78]:
*       INPUT REPLY,1_:
*       PRINT @(0,23):@(-4):
*       RETURN
*
*---- END OF PROGRAM
*
99999 *
      RETURN
      END
