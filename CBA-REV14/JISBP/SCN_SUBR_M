      SUBROUTINE SCN_SUBR_M(S_NAME,FLD_ID,FLD_SUBR,FLD_FNAME,FLD_VNAME,SBR_VID,SBR_VVAL)
*COPY>CPYLIB>COM_SCREENM
*********************************************************************
* Copyright 1982 by Computer Business Associates (Vercom Software, Inc.)
* Revision      - [10.0]
* Revision Date - 04/28/94
* System        - PRIMAC
* Library       - JISBP/SCN_SUBR_M
* Author        - Ziad Yamout, VERCOM Software, Inc.
*********************************************************************
*
*---- Data Structure Libraries
*
*COPY>PMC.CPYLIB>MENUS.CONTROL
*COPY>PMC.CPYLIB>SECURITY
*COPY>JIS.CPYLIB>SYS_SCN_DEF
*COPY>JIS.CPYLIB>SYS_FILES
*COPY>JIS.CPYLIB>PFX_FILES
*COPY>JIS.CPYLIB>SYS_FIELDS
*COPY>CPYLIB>EDIT.COM
*COPY>CPYLIB>GEN.XREF.SUB
*COPY>CPYLIB>FILE.VARS
*COPY>CPYLIB>CHAR
*
*---- Declarations and initializations
*
      DIM S_SSD_REC(40)
      DIM FLD_NAME_REC(5)
      DIM X_LOC_REC(5)
      DIM Y_LOC_REC(5)
      DIM FMT_REC(5)
      MAX_SNO = 2; SCNO = 1
      DIM SCN_HDR_CRT(MAX_SNO)
      DIM SCN_CLR_CRT(MAX_SNO)
*
      EQU SUBR_X_L  TO X_LOC_REC(1)
      EQU FNAME_X_L TO X_LOC_REC(2)
      EQU VNAME_X_L TO X_LOC_REC(3)
      EQU VID_X_L TO X_LOC_REC(4)
      EQU VVAL_X_L TO X_LOC_REC(5)
*
      EQU SUBR_Y_L  TO Y_LOC_REC(1)
      EQU FNAME_Y_L TO Y_LOC_REC(2)
      EQU VNAME_Y_L TO Y_LOC_REC(3)
      EQU VID_Y_L TO Y_LOC_REC(4)
      EQU VVAL_Y_L TO Y_LOC_REC(5)
*
      EQU SUBR_FMT  TO FMT_REC(1)
      EQU FNAME_FMT TO FMT_REC(2)
      EQU VNAME_FMT TO FMT_REC(3)
      EQU VID_FMT TO FMT_REC(4)
      EQU VVAL_FMT TO FMT_REC(5)
*
      FLD_NAME_REC(1) = "SSD_FLD_SUBR"
      FLD_NAME_REC(2) = "SSD_SBR_FNAME"
      FLD_NAME_REC(3) = "SSD_SBR_VNAME"
      FLD_NAME_REC(4) = "SSD_SBR_VID"
      FLD_NAME_REC(5) = "SSD_SBR_VVALUE"
*
      SCN_NAME = "SCN_SUBR_M"
      OTH_FILES = "ESTIMATE.DEPT"
*
      OLD.LINES = 0; BEGIN.FPAGE = 6; BEGIN.VPAGE = 11; BEGIN.MPAGE = 17
      PAGE.FSIZE = 2; PAGE.VSIZE = 3; PAGE.MSIZE = 3
      FLN = 1; VLN = 1; MLN = 1; LINE.SPACE = 1
      OLD.START.FLINE = 0; OLD.START.VLINE = 0; OLD.START.MLINE = 0
      FLINES = DCOUNT(FLD_FNAME,SM); VLINES = DCOUNT(FLD_VNAME,SM)
      MLINES = DCOUNT(SBR_VID,SM)
*
*---- Copy screen
*
      CALL SCN_CRT_BLD(SCN_NAME,MAT SCN_HDR_CRT,MAT SCN_CLR_CRT,ERRMSG)
      IF ERRMSG # "" THEN GOTO 93000
*
*---- Prompt messages' X & Y
*
      PMSG_X_L = 0; PMSG_Y_L = 21
      ID_X_L = 15; ID_Y_L = 2
*
*---- Copy data to arrays
*
      MAT S_SSD_REC = MAT SSD.REC
      MATREAD SSD.REC FROM SYS_SCN_DEF, SCN_NAME ELSE
         ERRMSG = "Cannot locate Setup screen - ":SCN_NAME
         MAT SSD.REC = MAT S_SSD_REC
         GOTO 93000
      END
      FOR OPT = 1 TO 5
         LOCATE FLD_NAME_REC(OPT) IN SSD_FIELDS<1>,1 SETTING LOC ELSE LOC=1
         X_LOC_REC(OPT) = SSD_FLD_X<1,LOC>
         Y_LOC_REC(OPT) = SSD_FLD_Y<1,LOC>
         FMT_REC(OPT) = SSD_FLD_FMT<1,LOC>
      NEXT OPT
      MAT SSD.REC = MAT S_SSD_REC
*
*---- Type initializations
*
      TYPE_INI = "T"; TYPE_DSC = "Text"; OTYP_INI = 1
      TYPE_INI<2> = "N"; TYPE_DSC<2> = "Numeric"; OTYP_INI<2> = 3
      TYPE_INI<3> = "C"; TYPE_DSC<3> = "deCimal"; OTYP_INI<3> = 4
      TYPE_INI<4> = "A"; TYPE_DSC<4> = "Alpha"; OTYP_INI<4> = 2
      TYPE_INI<5> = "D"; TYPE_DSC<5> = "Date"; OTYP_INI<5> = 6
      TYPE_INI<6> = "L"; TYPE_DSC<6> = "Logical"; OTYP_INI<6> = 8
      TYPE_INI<7> = "P"; TYPE_DSC<7> = "Pattern"; OTYP_INI<7> = 7
      TYPE_INI<8> = "U"; TYPE_DSC<8> = "coUnter"; OTYP_INI<8> = 3
*
*---- Prompt messages
*
      PMSG1 = "Enter # to change, (F)ile names, f(I)eld names, (V)ariables, (E)nd :"
      PMSG2 = "(A)dd, (C)hange, (I)nsert, (D)elete, (S)croll, (E)nd :"
      PMSG3 = "Line Number :"
*
*---- Print screen
*
      CRT SCN_HDR_CRT(SCNO):
      CRT @(ID_X_L,ID_Y_L): FLD_ID "L#25":
      IF FLD_SUBR # "" THEN
         CRT @(SUBR_X_L,SUBR_Y_L): FLD_SUBR SUBR_FMT:CL:
         GOSUB 1500; GOSUB 1750
         GOSUB 2500; GOSUB 2750
         GOSUB 3500; GOSUB 3750
      END ELSE
         GOSUB 100
         IF FLD_SUBR = "" THEN 
            GOSUB 1700; GOSUB 2700; GOSUB 3700
            GOTO 10
         END
         GOSUB 1100; GOSUB 2100; GOSUB 3100
      END
10*
*
*---- Prompt line
*
      MORE = 1
      LOOP
         X = PMSG_X_L; Y = PMSG_Y_L
         TYP = 1; MAXL = 4
         PMSG = PMSG1; CALL EDIT.SUB
         VALUE = OCONV(VALUE,"MCU")
         BEGIN CASE
         CASE VALUE = "E" OR VALUE = "END"
            IF FLD_SUBR = "" THEN
               IF FLD_FNAME # "" OR FLD_VNAME # "" OR SBR_VID # "" THEN
                  PMSG = "Subroutine name is null. Do you want to continue?(Y/N) :"
                  X = PMSG_X_L; Y = PMSG_Y_L; TYP = 8; CALL EDIT.SUB
                  IF VALUE = "Y" THEN
                     FLD_FNAME = ""
                     FLD_VNAME = ""
                     SBR_VID = ""
                     SBR_VVAL = ""
                     MORE = 0
                  END 
               END ELSE
                  MORE = 0
               END
            END ELSE
               MORE = 0
            END
         CASE VALUE = "F" AND FLD_SUBR = ""
            ERRMSG = "Cannot pass files to non existing subroutine"
            GOSUB 91000
         CASE VALUE = "F"
            GOSUB 1000
         CASE VALUE = "I" AND FLD_SUBR = ""
            ERRMSG = "Cannot pass fields to non existing subroutine"
            GOSUB 91000
         CASE VALUE = "I"
            GOSUB 2000
         CASE VALUE = "V" AND FLD_SUBR = ""
            ERRMSG = "Cannot pass variables to non existing subroutine"
            GOSUB 91000
         CASE VALUE = "V"
            GOSUB 3000
         CASE NOT(NUM(VALUE))
         CASE VALUE # 1
         CASE VALUE = 1
            GOSUB 100
         CASE 1
            ERRMSG = "*** OUT OF RANGE ***"
            GOSUB 91000
         END CASE
      WHILE MORE DO REPEAT
      GOTO 99999
*
*---- Subroutine Name
100*
      OPT = ""
      FLD_NAME = "SSD_FLD_SUBR"
      GOSUB 5000
      IF ERRMSG = "" THEN
         GOSUB 6000
         X = SUBR_X_L; Y = SUBR_Y_L; O.R = "O"
         IF FLD_SUBR # "" THEN
            DEFAULT = FLD_SUBR
         END
         CALL EDIT.SUB
         BEGIN CASE
         CASE VALUE = "END"
            CRT @(SUBR_X_L,SUBR_Y_L): FLD_SUBR SUBR_FMT:CL:
            GOTO 199
         CASE VALUE = ""
         CASE VALUE[1,4] # "JKT_"
            ERRMSG = "Subroutine name ":VALUE:" is not valid for JOB TICKET"
            GOSUB 91000; GOTO 100
         CASE VALUE[1,4] = "JKT_"
         END CASE
         FLD_SUBR = VALUE
      END ELSE
         GOSUB 91000
      END
199*
      RETURN
*
*---- Prompt line
1000*
      IF FLINES = 0 THEN
         GOSUB 1100
      END
      MORE1 = 1
      LOOP
         X = PMSG_X_L; Y = PMSG_Y_L; MAXL = 4; MINL = 1
         O.R = "O"; TYP = 1; PMSG = PMSG2; CALL EDIT.SUB
         OPTION = VALUE
         BEGIN CASE
           CASE OPTION = "E" OR OPTION = "END"
              MORE1 = 0
           CASE OPTION[1,1] = "S" OR OPTION = ""
              GOSUB 1400
           CASE OPTION = "A"
              GOSUB 1100
           CASE OPTION = "D" AND FLINES > 0
              GOSUB 1300
              IF LNO # 0 THEN
                 FLN = LNO
                 FLD_FNAME = DELETE(FLD_FNAME,1,1,FLN)
                 FLINES = FLINES - 1; FLN = OLD.START.FLINE
                 IF FLN > FLINES THEN FLN = FLINES
                 OLD.START.FLINE = 0; GOSUB 1500; GOSUB 1750
              END
           CASE OPTION = "C" AND FLINES > 0
              MODE = "C"; GOSUB 1300
              BEGIN CASE
                 CASE LNO = 0
                 CASE NUM(LNO)
                    FLN = LNO; GOSUB 1200
              END CASE
           CASE OPTION = "I" AND FLINES > 0
              MODE = "B"; GOSUB 1300
              IF LNO > 0 THEN
                 FLD_FNAME = INSERT(FLD_FNAME,1,1,LNO,"")
                 OLD.START.FLINE = 0; FLINES = FLINES + 1; GOSUB 1500
                 GOSUB 1750; FLN = LNO; GOSUB 1200
              END
              OLD.START.FLINE = 0; GOSUB 1500
           CASE 1
              ERRMSG = "*** INVALID ENTRY ***"
              GOSUB 91000
        END CASE
     WHILE MORE1 DO REPEAT
     RETURN
*---- End of loop
*
*
*--- Add mode
*
1100*
     MODE = "A"
     LOOP
       FLN = FLINES + 1
       OLD.LINES = FLINES
       GOSUB 1500
       GOSUB 1200
     WHILE FLINES > OLD.LINES DO
       GOSUB 1700
     REPEAT
     FLN = FLINES
     OLD.START.FLINE = 0; GOSUB 1500; GOSUB 1750
     RETURN
*
*---- Prompt lines in paging area
*
1200*
      SSLN = BEGIN.FPAGE + LINE.SPACE * MOD(FLN-1,PAGE.FSIZE)
      CRT @(0,SSLN): FLN "R#3":
      FLD_NAME = "SSD_SBR_FNAME"; GOSUB 5000
      IF ERRMSG = "" THEN
         X = 4; Y = SSLN; O.R = "R"; MAXL = 40; MINL = 1; TYP = 1
         GOSUB 6000
         IF FLD_FNAME<1,1,FLN> # "" THEN
            DEFAULT = FLD_FNAME<1,1,FLN>
         END
         CALL EDIT.SUB
         BEGIN CASE
         CASE VALUE = "END"
            BEGIN CASE
            CASE MODE = "A"
              CRT @(0,SSLN):CL:
            CASE MODE = "B"
              DEL FLD_FNAME<1,1,FLN>
              FLINES = DCOUNT(FLD_FNAME,SM)
            CASE 1
              N = FLN; GOSUB 1600
            END CASE
            GOTO 1299
         CASE VALUE = "" OR VALUE = "???"
            M_LIST = ""
            M_CNT = DCOUNT(SSD_M_TABLE,VM)
            FOR I = 1 TO M_CNT
               M_LIST<1,I> = SSD_M_TABLE<1,I>
            NEXT I 
            FOR I = 1 TO DCOUNT(SSD_S_TABLE,VM)
               M_LIST<1,I+M_CNT> = SSD_S_TABLE<1,I>
            NEXT I
            MAT GEN.XREF.REC = ""
            GXR.NAME = "SSD.M.CODE"
            GXR.IDLIST = M_LIST
            CALL GEN.XREF.SUB(MAT GEN.XREF.REC,PREFIX,XREF.DATA)
            CRT SCN_HDR_CRT(SCNO):
            CRT @(ID_X_L,ID_Y_L): FLD_ID "L#25":
            CRT @(SUBR_X_L,SUBR_Y_L):FLD_SUBR SUBR_FMT:CL:
            OLD.START.FLINE = 0; GOSUB 1500; GOSUB 1700
            OLD.START.VLINE = 0; GOSUB 2500; GOSUB 2700
            OLD.START.MLINE = 0; GOSUB 3500; GOSUB 3700
            IF GXR.ID = "" THEN GOTO 1200
            SSLN = BEGIN.FPAGE + LINE.SPACE * MOD(FLN-1,PAGE.FSIZE)
            VALUE = GXR.ID
            CRT @(0,SSLN): FLN "R#3":
            CRT @(FNAME_X_L,SSLN): VALUE FNAME_FMT:CL:
         END CASE
         LOCATE VALUE IN FLD_FNAME<1,1>,1 SETTING QNUM THEN
            IF FLN # QNUM THEN
               ERRMSG = "*** This Entry has been used ***"
               GOSUB 91000; GOTO 1200
            END
         END ELSE
            LOCATE VALUE IN OTH_FILES,1 SETTING FND ELSE
               LOCATE VALUE IN SSD_M_TABLE<1>,1 SETTING QNUM ELSE
                  LOCATE VALUE IN SSD_S_TABLE<1>,1 SETTING QNUM ELSE
                     ERRMSG = "*** This Entry is not found in M_TABLE or S_TABLE ***"
                     GOSUB 91000; GOTO 1200
                  END
               END
            END
         END
      END ELSE
         GOSUB 91000
      END
      FLD_FNAME<1,1,FLN> = VALUE
      FLINES = DCOUNT(FLD_FNAME,SM)
1299*
      RETURN
*
*---- Check line number
*
1300*
      OLD.START.FLINE = 0; GOSUB 1500
      X = PMSG_X_L
      Y = PMSG_Y_L; MINL = 1; MAXL = 3; O.R = "O"; TYP = 1; DEFAULT = ""
      PMSG = PMSG3; CALL EDIT.SUB
      BEGIN CASE
         CASE VALUE = "" OR VALUE = "END"
            LNO = 0
         CASE NOT(NUM(VALUE))
            ERRMSG = "*** INVALID ENRTY ***"
            GOSUB 91000; GOTO 1300
         CASE VALUE >= START.FLINE AND VALUE <= LAST.FLINE
            LNO = VALUE
         CASE 1
            ERRMSG = "*** OUT OF RANGE ***"
            GOSUB 91000; GOTO 1300
      END CASE
      RETURN
*
*---- Find page of scroll
*
1400*
      OPT2 = OPTION[2,1]
      BEGIN CASE
      CASE OPT2 = "" OR OPT2 = "F"
         FLN = FLN + PAGE.FSIZE
         IF FLN > FLINES THEN FLN = 1
      CASE OPT2 = "R"
         FLN = FLN - PAGE.FSIZE
         IF FLN < 1 THEN FLN = 1
      CASE OPT2 = "T"
         FLN = 1
      CASE OPT2 = "B"
         FLN = FLINES
         IF FLN < 1 THEN FLN = 1
      CASE NUM(OPT2)
         LN.NO = OPTION[2,99]
         IF LN.NO < 1 OR LN.NO > FLINES THEN
            ERRMSG = "*** INVALID SELECTION ***"
            GOSUB 91000
         END ELSE
            FLN = LN.NO
         END
      END CASE
*
*---- Print data
*
1500*
      START.FLINE = 1 + INT((FLN - 1)/PAGE.FSIZE) * PAGE.FSIZE
      LAST.FLINE = START.FLINE + PAGE.FSIZE - 1
      IF LAST.FLINE > FLINES THEN LAST.FLINE = FLINES
      IF START.FLINE = OLD.START.FLINE THEN GOTO 1599
      OLD.START.FLINE = START.FLINE
      PAGE.NO = INT(LAST.FLINE/PAGE.FSIZE+.9)
      CRT @(70,8): PAGE.NO "R%2":
      CNT = 1
      FOR N = START.FLINE TO LAST.FLINE
         SSLN = BEGIN.FPAGE + LINE.SPACE * MOD(N-1,PAGE.FSIZE)
         GOSUB 1600
         CNT = CNT + 1
      NEXT N
      GOSUB 1800
1599*
      RETURN
*
*---- Print line
*
1600*
      CRT@(0,SSLN) : N "R#3":
      CRT @(FNAME_X_L,SSLN): FLD_FNAME<1,1,N> FNAME_FMT:CL:
      RETURN
*
*---- Print page no & pages
*
1700*
      PAGE.NO = INT(FLN/PAGE.FSIZE+.9)
      CRT @(70,8):PAGE.NO "R%2":
1750*
      PAGES = INT(FLINES/PAGE.FSIZE+.9)
      CRT @(76,8): PAGES "R%2":
      RETURN
*
*---- Fill blank lines
*
1800*
      FOR N = CNT TO PAGE.FSIZE
         SSLN = BEGIN.FPAGE + LINE.SPACE * MOD(N-1,PAGE.FSIZE)
         CRT @(0,SSLN):CL:
      NEXT N
      RETURN
*
*---- Loop begin
*
2000*
      IF VLINES < 1 THEN
         GOSUB 2100
      END
      MORE1 = 1
      LOOP
         X = PMSG_X_L; Y = PMSG_Y_L; MAXL = 4; MINL = 1
         O.R = "O"; TYP = 1; PMSG = PMSG2; CALL EDIT.SUB
         OPTION = VALUE
         BEGIN CASE
           CASE OPTION = "E" OR OPTION = "END"
              MORE1 = 0
           CASE OPTION[1,1] = "S" OR OPTION = ""
              GOSUB 2400
           CASE OPTION = "A"
              GOSUB 2100
           CASE OPTION = "D" AND VLINES > 0
              GOSUB 2300
              IF LNO # 0 THEN
                 VLN = LNO
                 FLD_VNAME = DELETE(FLD_VNAME,1,1,VLN)
                 VLINES = VLINES - 1; VLN = OLD.START.VLINE
                 IF VLN > VLINES THEN VLN = VLINES
                 OLD.START.VLINE = 0; GOSUB 2500; GOSUB 2750
              END
           CASE OPTION = "C" AND VLINES > 0
              MODE = "C"; GOSUB 2300
              BEGIN CASE
                 CASE LNO = 0
                 CASE NUM(LNO)
                    VLN = LNO; GOSUB 2200
              END CASE
           CASE OPTION = "I" AND VLINES > 0
              MODE = "B"; GOSUB 2300
              IF LNO > 0 THEN
                 FLD_VNAME = INSERT(FLD_VNAME,1,1,LNO,"")
                 OLD.START.VLINE = 0; VLINES = VLINES + 1; GOSUB 2500
                 GOSUB 2750; VLN = LNO; GOSUB 2200
              END
              OLD.START.VLINE = 0; GOSUB 2500
           CASE 1
              ERRMSG = "*** INVALID ENTRY ***"
              GOSUB 91000
        END CASE
     WHILE MORE1 DO REPEAT
     RETURN
*
*--- Add mode
*
2100*
     MODE = "A"
     LOOP
       VLN = VLINES + 1
       OLD.LINES = VLINES
       GOSUB 2500
       GOSUB 2200
     WHILE VLINES > OLD.LINES DO
       GOSUB 2700
     REPEAT
     VLN = VLINES
     OLD.START.VLINE = 0; GOSUB 2500; GOSUB 2750
     RETURN
*
*---- Prompt line
*
2200*
      SSLN = BEGIN.VPAGE + LINE.SPACE * MOD(VLN-1,PAGE.VSIZE)
      CRT @(0,SSLN): VLN "R#3":
      FLD_NAME = "SSD_SBR_VNAME"; GOSUB 5000
      IF ERRMSG = "" THEN
         GOSUB 6000
         X = VNAME_X_L; Y = SSLN; O.R = "R"; MAXL = 40; MINL = 1; TYP = 1
         IF MODE = "C" THEN
            DEFAULT = FLD_VNAME<1,1,VLN>
         END ELSE
            DEFAULT = ""
         END
         CALL EDIT.SUB
         BEGIN CASE
         CASE VALUE = "END"
            BEGIN CASE
            CASE MODE = "A"
               CRT @(0,SSLN): CL:
            CASE MODE = "B"
               DEL FLD_VNAME<1,1,VLN>
               VLINES = DCOUNT(FLD_VNAME,SM)
            CASE 1
               N = VLN; GOSUB 2600
            END CASE
            GOTO 2299
         CASE VALUE = "" OR VALUE = "???"
            MAT GEN.XREF.REC = ""
            GXR.NAME = "SSD.CODE"
            GXR.XREF = SYS_SCN_DEF
            GXR.FILE = SYS_SCN_DEF
            GXR.SRCH.ID = S_NAME
            CALL GEN.XREF.SUB(MAT GEN.XREF.REC,PREFIX,XREF.DATA)
            CRT SCN_HDR_CRT(SCNO):
            CRT @(ID_X_L,ID_Y_L): FLD_ID "L#25":
            CRT @(SUBR_X_L,SUBR_Y_L):FLD_SUBR SUBR_FMT:CL:
            OLD.START.FLINE = 0; GOSUB 1500; GOSUB 1750
            OLD.START.VLINE = 0; GOSUB 2500; GOSUB 2750
            OLD.START.MLINE = 0; GOSUB 3500; GOSUB 3750
            IF GXR.ID = "" THEN GOTO 2200
            SSLN = BEGIN.VPAGE + LINE.SPACE * MOD(VLN-1,PAGE.VSIZE)
            VALUE = GXR.ID
            CRT @(0,SSLN): VLN "R#3":
            CRT @(VNAME_X_L,SSLN): VALUE VNAME_FMT:
         END CASE
         LOCATE VALUE IN FLD_VNAME<1,1>,1 SETTING QNUM THEN
            IF VLN # QNUM THEN
               ERRMSG = "*** This Entry has been used ***"
               GOSUB 91000; GOTO 2200
            END
         END ELSE
            IF VALUE[1,1] # "^" THEN
               LOCATE VALUE IN SSD_FIELDS<1>,1 SETTING QNUM ELSE
                  ERRMSG = "*** Entry is not found in FIELDS ***"
                  GOSUB 91000; GOTO 2200
               END
            END ELSE
               L = LEN(VALUE)
               IF VALUE[L,1] # VALUE[1,1] THEN
                  ERRMSG = "*** Entry is not in the right format ***"
                  GOSUB 91000; GOTO 2200
               END
            END
         END
      END ELSE
         GOSUB 91000
      END
      FLD_VNAME<1,1,VLN> = VALUE
      VLINES = DCOUNT(FLD_VNAME,SM)
2299*
      RETURN
*
*---- Check line number
*
2300*
      OLD.START.VLINE = 0; GOSUB 2500
      X = PMSG_X_L
      Y = PMSG_Y_L; MINL = 1; MAXL = 3; O.R = "O"; TYP = 1; DEFAULT = ""
      PMSG = PMSG3; CALL EDIT.SUB
      BEGIN CASE
         CASE VALUE = "" OR VALUE = "END"
            LNO = 0
         CASE NOT(NUM(VALUE))
            ERRMSG = "*** INVALID ENRTY ***"
            GOSUB 91000; GOTO 2300
         CASE VALUE >= START.VLINE AND VALUE <= LAST.VLINE
            LNO = VALUE
         CASE 1
            ERRMSG = "*** OUT OF RANGE ***"
            GOSUB 91000; GOTO 2300
      END CASE
      RETURN
*
*---- Find page of scroll
*
2400*
      OPT2 = OPTION[2,1]
      BEGIN CASE
      CASE OPT2 = "" OR OPT2 = "F"
         VLN = VLN + PAGE.VSIZE
         IF VLN > VLINES THEN VLN = 1
      CASE OPT2 = "R"
         VLN = VLN - PAGE.VSIZE
         IF VLN < 1 THEN VLN = 1
      CASE OPT2 = "T"
         VLN = 1
      CASE OPT2 = "B"
         VLN = VLINES
         IF VLN < 1 THEN VLN = 1
      CASE NUM(OPT2)
         LN.NO = OPTION[2,99]
         IF LN.NO < 1 OR LN.NO > VLINES THEN
            ERRMSG = "*** INVALID SELECTION ***"
            GOSUB 91000
         END ELSE
            VLN = LN.NO
         END
      END CASE
*
*---- Print data
*
2500*
      START.VLINE = 1 + INT((VLN - 1)/PAGE.VSIZE) * PAGE.VSIZE
      LAST.VLINE = START.VLINE + PAGE.VSIZE - 1
      IF LAST.VLINE > VLINES THEN LAST.VLINE = VLINES
      IF START.VLINE = OLD.START.VLINE THEN GOTO 2599
      OLD.START.VLINE = START.VLINE
      PAGE.NO = INT(LAST.VLINE/PAGE.VSIZE+.9)
      CRT @(70,14): PAGE.NO "R%2":
      CNT = 1
      FOR N = START.VLINE TO LAST.VLINE
         SSLN = BEGIN.VPAGE + LINE.SPACE * MOD(N-1,PAGE.VSIZE)
         GOSUB 2600
         CNT = CNT + 1
      NEXT N
      GOSUB 2800
2599*
      RETURN
*
*---- Print Line
*
2600*
      CRT@(0,SSLN) : N "R#3":
      CRT @(VNAME_X_L,SSLN): FLD_VNAME<1,1,N> VNAME_FMT:CL:
      RETURN
*
*---- Print page no & pages
*
2700*
      PAGE.NO = INT(VLN/PAGE.VSIZE+.9)
      CRT @(76,14):PAGE.NO "R%2":
2750*
      PAGES = INT(VLINES/PAGE.VSIZE+.9)
      CRT @(76,14): PAGES "R%2":
      RETURN
*
*---- Fill blank lines
*
2800*
      FOR N = CNT TO PAGE.VSIZE
         SSLN = BEGIN.VPAGE + LINE.SPACE * MOD(N-1,PAGE.VSIZE)
         CRT @(0,SSLN):CL:
      NEXT N
      RETURN
*
*---- Prompt line
3000*
      IF MLINES = 0 THEN
         GOSUB 3100
      END
      MORE1 = 1
      LOOP
         X = PMSG_X_L; Y = PMSG_Y_L; MAXL = 4; MINL = 1
         O.R = "O"; TYP = 1; PMSG = PMSG2; CALL EDIT.SUB
         OPTION = VALUE
         BEGIN CASE
           CASE OPTION = "E" OR OPTION = "END"
              MORE1 = 0
           CASE OPTION[1,1] = "S" OR OPTION = ""
              GOSUB 3400
           CASE OPTION = "A"
              GOSUB 3100
           CASE OPTION = "D" AND MLINES > 0
              GOSUB 3300
              IF LNO # 0 THEN
                 MLN = LNO
                 SBR_VID = DELETE(SBR_VID,1,1,MLN)
                 SBR_VVAL = DELETE(SBR_VVAL,1,1,MLN)
                 MLINES = MLINES - 1; MLN = OLD.START.MLINE
                 IF MLN > MLINES THEN MLN = MLINES
                 OLD.START.MLINE = 0; GOSUB 3500; GOSUB 3750
              END
           CASE OPTION = "C" AND MLINES > 0
              MODE = "C"; GOSUB 3300
              BEGIN CASE
                 CASE LNO = 0
                 CASE NUM(LNO)
                    MLN = LNO; GOSUB 3200
              END CASE
           CASE OPTION = "I" AND MLINES > 0
              MODE = "B"; GOSUB 3300
              IF LNO > 0 THEN
                 SBR_VID = INSERT(SBR_VID,1,1,LNO,"")
                 SBR_VVAL = INSERT(SBR_VVAL,1,1,LNO,"")
                 OLD.START.MLINE = 0; MLINES = MLINES + 1; GOSUB 3500
                 GOSUB 3750; MLN = LNO; GOSUB 3200
              END
              OLD.START.MLINE = 0; GOSUB 3500
           CASE 1
              ERRMSG = "*** INVALID ENTRY ***"
              GOSUB 91000
        END CASE
     WHILE MORE1 DO REPEAT
     RETURN
*---- End of loop
*
*
*--- Add mode
*
3100*
     MODE = "A"
     LOOP
       MLN = MLINES + 1
       OLD.LINES = MLINES
       GOSUB 3500
       GOSUB 3200
     WHILE MLINES > OLD.LINES DO
       GOSUB 3700
     REPEAT
     MLN = MLINES
     OLD.START.MLINE = 0; GOSUB 3500; GOSUB 3750
     RETURN
*
*---- Prompt lines in paging area
*
3200*
      SSLN = BEGIN.MPAGE + LINE.SPACE * MOD(MLN-1,PAGE.MSIZE)
      CRT @(0,SSLN): MLN "R#3":
      FLD_NAME = "SSD_SBR_VID"; GOSUB 5000
      IF ERRMSG = "" THEN
         X = VID_X_L; Y = SSLN; O.R = "R"; MAXL = 30; MINL = 1; TYP = 1
         GOSUB 6000
         IF SBR_VID<1,1,MLN> # "" THEN
            DEFAULT = SBR_VID<1,1,MLN>
         END
         CALL EDIT.SUB
         IF VALUE = "END" THEN
            GOSUB 3250
            GOTO 3299
         END
         GET_VID = VALUE
*
         FLD_NAME = "SSD_SBR_VVALUE"; GOSUB 5000
         IF ERRMSG = "" THEN
            X = VVAL_X_L; Y = SSLN; O.R = "O"; MAXL = 30; MINL = 1; TYP = 1
            GOSUB 6000
            IF SBR_VVAL<1,1,MLN> # "" THEN
               DEFAULT = SBR_VVAL<1,1,MLN>
            END
            CALL EDIT.SUB
            IF VALUE = "END" THEN
               GOSUB 3250
               GOTO 3200
            END
            SBR_VVAL<1,1,MLN> = VALUE
         END ELSE
            GOSUB 91000
         END
      END ELSE
         GOSUB 91000
      END
      SBR_VID<1,1,MLN> = GET_VID
      MLINES = DCOUNT(SBR_VID,SM)
3299*
      RETURN
*
*---- End input
*
3250*
      BEGIN CASE
      CASE MODE = "A"
        CRT @(0,SSLN):CL:
      CASE MODE = "B"
        DEL SBR_VID<1,1,MLN>
        DEL SBR_VVAL<1,1,MLN>
        MLINES = DCOUNT(SBR_VID,SM)
      CASE 1
        N = MLN; GOSUB 3600
      END CASE
      RETURN
*
*---- Check line number
*
3300*
      OLD.START.FLINE = 0; GOSUB 3500
      X = PMSG_X_L
      Y = PMSG_Y_L; MINL = 1; MAXL = 3; O.R = "O"; TYP = 1; DEFAULT = ""
      PMSG = PMSG3; CALL EDIT.SUB
      BEGIN CASE
         CASE VALUE = "" OR VALUE = "END"
            LNO = 0
         CASE NOT(NUM(VALUE))
            ERRMSG = "*** INVALID ENRTY ***"
            GOSUB 91000; GOTO 3300
         CASE VALUE >= START.MLINE AND VALUE <= LAST.MLINE
            LNO = VALUE
         CASE 1
            ERRMSG = "*** OUT OF RANGE ***"
            GOSUB 91000; GOTO 3300
      END CASE
      RETURN
*
*---- Find page of scroll
*
3400*
      OPT2 = OPTION[2,1]
      BEGIN CASE
      CASE OPT2 = "" OR OPT2 = "F"
         MLN = MLN + PAGE.MSIZE
         IF MLN > MLINES THEN MLN = 1
      CASE OPT2 = "R"
         MLN = MLN - PAGE.MSIZE
         IF MLN < 1 THEN MLN = 1
      CASE OPT2 = "T"
         MLN = 1
      CASE OPT2 = "B"
         MLN = MLINES
         IF MLN < 1 THEN MLN = 1
      CASE NUM(OPT2)
         LN.NO = OPTION[2,99]
         IF LN.NO < 1 OR LN.NO > MLINES THEN
            ERRMSG = "*** INVALID SELECTION ***"
            GOSUB 91000
         END ELSE
            MLN = LN.NO
         END
      END CASE
*
*---- Print data
*
3500*
      START.MLINE = 1 + INT((MLN - 1)/PAGE.MSIZE) * PAGE.MSIZE
      LAST.MLINE = START.MLINE + PAGE.MSIZE - 1
      IF LAST.MLINE > MLINES THEN LAST.MLINE = MLINES
      IF START.MLINE = OLD.START.MLINE THEN GOTO 3599
      OLD.START.MLINE = START.MLINE
      PAGE.NO = INT(LAST.MLINE/PAGE.MSIZE+.9)
      CRT @(70,20): PAGE.NO "R%2":
      CNT = 1
      FOR N = START.MLINE TO LAST.MLINE
         SSLN = BEGIN.MPAGE + LINE.SPACE * MOD(N-1,PAGE.MSIZE)
         GOSUB 3600
         CNT = CNT + 1
      NEXT N
      GOSUB 3800
3599*
      RETURN
*
*---- Print line
*
3600*
      CRT@(0,SSLN) : N "R#3":
      CRT @(VID_X_L,SSLN): SBR_VID<1,1,N> VID_FMT:
      CRT @(VVAL_X_L,SSLN): SBR_VVAL<1,1,N> VVAL_FMT:
      RETURN
*
*---- Print page no & pages
*
3700*
      PAGE.NO = INT(MLN/PAGE.MSIZE+.9)
      CRT @(70,20):PAGE.NO "R%2":
3750*
      PAGES = INT(MLINES/PAGE.MSIZE+.9)
      CRT @(76,20): PAGES "R%2":
      RETURN
*
*---- Fill blank lines
*
3800*
      FOR N = CNT TO PAGE.MSIZE
         SSLN = BEGIN.MPAGE + LINE.SPACE * MOD(N-1,PAGE.MSIZE)
         CRT @(0,SSLN):CL:
      NEXT N
      RETURN
*
*---- Get field Definition
5000*
      ERRMSG = ""
      MATREAD DFD.REC FROM SYS_FIELDS, FLD_NAME ELSE
         ERRMSG = "Cannot locate field (":FLD_NAME:") Definition"
      END
      RETURN
*
*---- Setup EDIT.SUB
6000*
      LOCATE DFD_TYPE IN TYPE_INI,1 SETTING TLOC ELSE TLOC = 1
      TYP = OTYP_INI<TLOC>; SCALER = DFD_DEC
      MAXL = DFD_LEN; MINL = DFD_MINL
      MAXV = DFD_MAXV; MINV = DFD_MINV
      JUSTIFY = DFD_JUSTIFY; FILL.CHR = DFD_FILL
      O.R = DFD_O_R; DEFAULT = DFD_DEFAULT
      PATRN = DFD_PATRN
      INVALCHR = FIELD(DFD_INVALCHR,",",1)
      CNT = DCOUNT(DFD_INVALCHR,",")
      FOR I = 2 TO CNT
         INVALCHR<1,I> = FIELD(DFD_INVALCHR,",",I)
      NEXT I
      ORVATDAT = DFD_ORVALDAT; VALDAT = DFD_VALDAT
      READ HMSG_REC FROM SYS_FLD_HMSG, FLD_NAME ELSE
         HMSG_REC = ""
      END
      HMSG = HMSG_REC<1>
      CNT = DCOUNT(HMSG_REC,AM)
      FOR I = 2 TO CNT
         HMSG<1,I> = HMSG_REC<I>
      NEXT I
      RETURN
*
*---- Error routines
91000*
      CRT @(0,23):ERRMSG:CL:
      INPUT REPLY,1_:
      CRT @(0,23):CL:
      RETURN
93000*
      CRT @(0,23):ERRMSG:CL:
      INPUT REPLY,1_:
99999*
      RETURN
   END
