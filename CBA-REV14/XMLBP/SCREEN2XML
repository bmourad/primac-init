   FUNCTION SCREEN_TO_XML(DEF.REC, MAT BLD.SCRN)
********************************************************************
* REVISION - [12.0]
* Copyright 1982 by Computer Business Associates (Vercom Software, Inc.)
* SYSTEM   - PRIMAC
* SOURCE   - FUNBP
* PROGRAM  - SCREEN_TO_XML
* BY       - Abdullah Jibaly, COMPUTER BUSINESS ASSOCIATES
* DATE     - 06/05/02
*
* DESCRIPTION
*
* This function returns an XML string defining the screen based on the two
* parameters passed in:
*    - DEF.REC :  Contains the screen text info
*    - BLD.SCRN:  Contains the screen field info
*
*********************************************************************
*
*COPY>CPYLIB>NEW.BUILD.SCREEN
*
*------------------------*
*---- INITIALIZATION ----*
*------------------------*
   DEFFUN XML_FORMAT_CDATA(STR)
   SCREEN.WIDTH  = 80
   SCREEN.HEIGHT = 23
   DIM SCREEN(SCREEN.HEIGHT,SCREEN.WIDTH)
   MAT SCREEN = ''
   XML.SCREEN = ''
*------------------------*
*----   SCREEN I/O   ----*
*------------------------*
   ;*
   ;* Determine where the fields are on the screen
   ;* When a field is found, each grid location it takes on the screen
   ;* is replaced with the field number
   ;*
   FOR BLD.IDX = 1 TO BLD.FIELD.CNT
      SCREEN.Y = BLD.SCRN(BLD.IDX)<1,B.Y> + 1
      SCREEN.X = BLD.SCRN(BLD.IDX)<1,B.X> + 1
      SCREEN.MAXL = BLD.SCRN(BLD.IDX)<1,B.MAXL>
      SCREEN.ROWS = BLD.SCRN(BLD.IDX)<1,B.MULTI.LN>
      IF SCREEN.ROWS+0 < 1 THEN SCREEN.ROWS = 1
      FOR SCREEN.ROW = SCREEN.Y TO SCREEN.Y+SCREEN.ROWS-1
         FOR SCREEN.COL = SCREEN.X TO SCREEN.X+SCREEN.MAXL-1
            SCREEN(SCREEN.ROW, SCREEN.COL) = BLD.IDX
         NEXT SCREEN.COL
      NEXT SCREEN.ROW
   NEXT BLD.IDX
   ;*
   ;* Parse DEF.REC:
   ;* 1-If a label contains a colon, split into two after colon's location.
   ;* (Colons should terminate labels)
   ;* 2-If a label has an adjacent label following it starting with a colon,
   ;* combine the two into one label (and split after the colon, if need be)
   ;* 3-If a field interesects a label, split the label into two removing
   ;* the intersecting part.
   ;*
   DEF.IDX = 0
   LOOP
      DEF.IDX = DEF.IDX + 1
      DEF.Y = DEF.REC<DEF.IDX,1>
      DEF.X = DEF.REC<DEF.IDX,2>
      DEF.T = DEF.REC<DEF.IDX,3>
      ;*
      ;* 1-Convert non-terminating colons to terminating colons
      ;*
      COLON.IDX  = INDEX(DEF.T,":",1)
      IF COLON.IDX > 0 AND COLON.IDX < LEN(DEF.T) THEN
         WHITE.SPACE = 0
         LOOP WHILE DEF.T[COLON.IDX+WHITE.SPACE+1,1] = ' '
            WHITE.SPACE += 1
         REPEAT
         DEF.X.SPLIT = DEF.X + COLON.IDX + WHITE.SPACE
         DEF.T.SPLIT = DEF.T[COLON.IDX+WHITE.SPACE+1,LEN(DEF.T)]
         DEF.SPLIT   = DEF.Y : @VM : DEF.X.SPLIT : @VM : DEF.T.SPLIT
         DEF.T       = DEF.T[1,COLON.IDX]
         DEF.REC<DEF.IDX,3> = DEF.T
         DEF.REC<DEF.IDX>   = DEF.REC<DEF.IDX> : @AM : DEF.SPLIT
      END
      ;*
      ;* 2-Check following adjacent label for starting colon
      ;*
      NEXT.DEF.T = DEF.REC<DEF.IDX+1,3>
      COLON.IDX  = INDEX(NEXT.DEF.T,":",1)
      IF COLON.IDX > 0 AND TRIM(NEXT.DEF.T[1,COLON.IDX]) = ":" THEN
         NEXT.DEF.X = DEF.REC<DEF.IDX+1,2>
         DEF.GAP = NEXT.DEF.X - DEF.X - LEN(DEF.T)
         DEF.T   = DEF.T : SPACE(DEF.GAP) : NEXT.DEF.T
         DEF.REC<DEF.IDX,3> = DEF.T
         DEL DEF.REC<DEF.IDX+1>
         ;*
         ;* Runs through this label again in case it needs to be split
         ;*
         DEF.IDX = DEF.IDX - 1
         CONTINUE
      END
*
      FOR LABEL.IDX = 1 TO LEN(DEF.T)
         ;*
         ;* 3-Check for intersecting fields
         ;*
         SCREEN.X = DEF.X + LABEL.IDX
         SCREEN.Y = DEF.Y + 1
         IF SCREEN(SCREEN.Y, SCREEN.X) # '' THEN
            IF LABEL.IDX = 1 THEN
               LOOP WHILE DEF.T[1,1] = ' '
                  DEF.X = DEF.X + 1
                  DEF.T = DEF.T[2,LEN(DEF.T)]
               REPEAT
               DEF.REC<DEF.IDX,2> = DEF.X
               DEF.REC<DEF.IDX,3> = DEF.T
               DEF.IDX = DEF.IDX - 1
               EXIT
            END ELSE
               WHITE.SPACE = 0
               LOOP WHILE DEF.T[LABEL.IDX+WHITE.SPACE+1,1] = ' '
                  WHITE.SPACE += 1
               REPEAT
               DEF.X.SPLIT = DEF.X + LABEL.IDX + WHITE.SPACE
               DEF.T.SPLIT = DEF.T[LABEL.IDX+WHITE.SPACE+1,LEN(DEF.T)]
               DEF.SPLIT   = DEF.Y : @VM : DEF.X.SPLIT : @VM : DEF.T.SPLIT
               DEF.T       = DEF.T[1,LABEL.IDX-1]
               DEF.REC<DEF.IDX,3> = DEF.T
               DEF.REC<DEF.IDX>   = DEF.REC<DEF.IDX> : @AM : DEF.SPLIT
            END
         END
      NEXT LABEL.IDX
   WHILE DEF.IDX # DCOUNT(DEF.REC,@AM) DO REPEAT
   ;*
   ;* Create XML string for screen
   ;* Since DEF.REC was changed, update DEF.CNT
   ;*
   DEF.CNT = DCOUNT(DEF.REC,@AM)
   FOR DEF.IDX = 1 TO DEF.CNT
      DEF.Y = DEF.REC<DEF.IDX,1>
      DEF.X = DEF.REC<DEF.IDX,2>
      DEF.T = DEF.REC<DEF.IDX,3>
      ;*
      ;* Mark the boundaries of a field if it cannot be expanded | example
      ;* 1 marks a right boundary (with respect to field)        | 2  3  1
      ;* 2 marks a left boundary (with respect to field)         | v  v  v
      ;* 3 (1 ORed with 2) marks a right and left boundary       |A###v###B
      ;*                                                         |D##E#F
      SCREEN.Y = DEF.Y + 1
      SCREEN.X = DEF.X + 1
      IF SCREEN.X # 1 THEN
         BOUND.RIGHT = SCREEN(SCREEN.Y,SCREEN.X-1)<2>+0
         SCREEN(SCREEN.Y,SCREEN.X-1)<2> = BITOR(BOUND.RIGHT,1)
      END
      SCREEN.X = DEF.X + LEN(DEF.T)
      IF SCREEN.X # SCREEN.WIDTH THEN
         BOUND.LEFT = SCREEN(SCREEN.Y,SCREEN.X+1)<2>+0
         SCREEN(SCREEN.Y,SCREEN.X+1)<2> = BITOR(BOUND.LEFT,2)
      END
      ;*
      DEF.Y = QUOTE(DEF.Y)
      DEF.X = QUOTE(DEF.X)
      DEF.T = QUOTE(XML_FORMAT_CDATA(DEF.T))
      XML.SCREEN<-1> = '<def x=':DEF.X:' y=':DEF.Y:' text=':DEF.T:'/>'
   NEXT DEF.IDX
*
   FOR BLD.IDX = 1 TO BLD.FIELD.CNT
      XML.SCREEN.ADD = ''
      FLD.X = BLD.SCRN(BLD.IDX)<1,B.X>
      FLD.LEN  = BLD.SCRN(BLD.IDX)<1,B.MAXL>
      FLD.FORM = "L#" : FLD.LEN
      FLD.ROWS = BLD.SCRN(BLD.IDX)<1,B.MULTI.LN>+0
      FLD.FLDTYPE =  BLD.SCRN(BLD.IDX)<1,B.FLDTYPE>
      IF FLD.FLDTYPE[1,1] = 'D' OR FLD.FLDTYPE[2,1] = 'D' THEN
         XML.SCREEN.ADD := ' editable="N"'
      END
      IF FLD.FLDTYPE[1,1] = 'P' OR FLD.FLDTYPE[2,1] = 'P' THEN
         XML.SCREEN.ADD := ' prompt="Y"'
      END
      IF FLD.ROWS < 1 THEN FLD.ROWS = 1
      FOR ROW.IDX = 1 TO FLD.ROWS
         FLD.Y = BLD.SCRN(BLD.IDX)<1,B.Y> + ROW.IDX - 1
         FLD.LINE = ROW.IDX
         IF FLD.ROWS < 2 THEN FLD.LINE = 0
         BOUND.LEFT  = SCREEN(FLD.Y + 1,FLD.X + 1)<2>+0
         BOUND.RIGHT = SCREEN(FLD.Y + 1,FLD.X + FLD.LEN)<2>+0
         FLD.BOUNDS  = BITOR(BOUND.LEFT,BOUND.RIGHT)
         IF FLD.BOUNDS > 0 THEN
            XML.SCREEN.ADD := ' bounds=':QUOTE(FLD.BOUNDS)
         END
         XML.SCREEN.FLD = '<fld x=':QUOTE(FLD.X):' y=':QUOTE(FLD.Y)
         XML.SCREEN.FLD:= XML.SCREEN.ADD
         XML.SCREEN.FLD:= ' form=':QUOTE(FLD.FORM):' ln=':QUOTE(FLD.LINE):'/>'
         XML.SCREEN<-1> = XML.SCREEN.FLD
      NEXT ROW.IDX
   NEXT BLD.IDX
*
   RETURN XML.SCREEN
*
*------------------------*
*----  SUBROUTINES   ----*
*------------------------*
*
*---- DISPLAY ERROR MESSAGE
*
91000*
   RETURN
*
