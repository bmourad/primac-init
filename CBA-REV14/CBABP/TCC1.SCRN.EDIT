      SUBROUTINE SCRN.EDIT
*
*COPY>CPYLIB>COM1
*
********************************************************************
*
* REVISION    - [08.0]
* Copyright 1982 by Computer Business Associates (Vercom Software, Inc.)
*
* PROGRAM - SCRN.EDIT
*
* BY      - NICK AMENDOLA, COMPUTER BUSINESS ASSOCIATES
*
* DATE    - 03/10/84
*
* DESCRIPTION 
*
* This program provides the interface between an aplication program and
* associated screens built and defined by the SCREEN.BUILD sub-system.
* The screens are displayed upon request and all defined editing is
* performed. Editing criteria defined at creation time may be modified
* by the application program at run time.
*
*********************************************************************
*
*---- DEFINE DIMENSIONED VARIABLES
*
*COPY>CPYLIB>EDIT.COM.DRIVER
*COPY>CPYLIB>NEW.BUILD.SCREEN
*COPY>CPYLIB>TCC
*COPY>CPYLIB>FILE.VARS
*COPY>CPYLIB>CHAR
*
*------------------------*
*---- INITIALIZATION ----*
*------------------------*
      DISPLAY.ALL = 0
      DASHES = STR("-",80)
      ERRMSG = ""
      LINE.SPACE = 1
*-------------------------*
*---- MAIN PROCESSING ----*
*-------------------------*
100   PROMPT ""
      BEGIN CASE
      CASE ECD.ACTION = 1
         GOSUB 80000
         GOSUB 1000                 ;* DEFINE SCREEN NAMES
      CASE ECD.ACTION = 2
         GOSUB 2000                 ;* DISPLAY SCREEN
      CASE ECD.ACTION = 3
         GOSUB 3000                 ;* DISPLAY ALL DATA
      CASE ECD.ACTION = 4
         GOSUB 4000                 ;* GET INPUT DATA
      CASE ECD.ACTION = 5
         GOSUB 5000                 ;* DISPLAY SPECIFIED FIELD
      CASE ECD.ACTION = 6
         GOSUB 6000                 ;* CLEAR ALL DATA FIELDS
      CASE ECD.ACTION = 7
         GOSUB 7000                 ;* DISPLAY MULTI-LINE FIELD
      CASE 1
         ERRMSG = "INVALID ACTION CODE - ":ECD.ACTION
         GOSUB 90000
      END CASE
*
*---- END OF SUBROUTINE
*
      ECD.DEFAULT = ""
      ECD.VALDATION = ""
      ECD.PREFIX.ID = ""
      ECD.VALDAT.CODE = ""
      ECD.VALDAT.FILE = ""
      ECD.VALDAT = ""
      ECD.HMSG = ""
      ECD.Y = ""
      ECD.PMSG = ""
      ECD.MAXL = ""
      ECD.MINV = ""
      ECD.MAXV = ""
      ECD.PATRN = ""
      ECD.O.R = ""
      ECD.SCALER = ""
      RETURN
*
*------------------------*
*---- DEFINE SCREENS ----*
*------------------------*
1000  MAT BLD.SCRN = ""
      CALL TCC.SUB1(PORT.NO,MAT TCC.PORT.REC,MAT TCC.REC,MAT GRAPH.REC,MAT VIDEO.REC,MAT KSEL.REC,MAT HBOX.REC)
      IF VIDEO.PORT.TYPE = "STD" THEN
         ECD.ETX.OFF = ""
         ECD.ETX.VALS = ""
      END ELSE
         ECD.ETX.OFF = ETX.OFF
         ECD.ETX.VALS = ETX.DIN
         ECD.ETX.VALS<2> = ETX.DHD
         ECD.ETX.VALS<3> = ETX.PHD
         ECD.ETX.VALS<4> = ETX.HHD
         ECD.ETX.VALS<5> = ETX.EHD
         ECD.ETX.VALS<6> = ETX.DIN.OFF
         ECD.ETX.VALS<7> = ETX.EHD.OFF
         ECD.ETX.VALS<8> = ETX.HHD.OFF
      END
      RETURN
*----------------------------------*
*---- DISPLAY SPECIFIED SCREEN ----*
*----------------------------------*
2000 * IF BLD.SCRN.NO = ECD.SCRN.NO THEN GOTO 2050
      SCREEN.NAME = ECD.SCRN.NAME<ECD.SCRN.NO>
      BEGIN CASE
      CASE ECD.SCRN.FLAG<ECD.SCRN.NO> = 3
         CURR.SCREENS.FILE = THIRD.SCREENS
      CASE ECD.SCRN.FLAG<ECD.SCRN.NO> = 2
         CURR.SCREENS.FILE = SECOND.SCREENS
      CASE 1
         CURR.SCREENS.FILE = M.SCREENS
      END CASE
      MATREAD BLD.SCRN FROM CURR.SCREENS.FILE, SCREEN.NAME:"*FLD" ELSE
         ECD.ACTION = 0
         ERRMSG = "CANNOT LOCATE SCREEN - ":SCREEN.NAME
         GOSUB 90000
         GOTO 2099
      END
      READ BLD.COMP.SCRN FROM CURR.SCREENS.FILE, SCREEN.NAME:"*FRM" ELSE
         ECD.ACTION = 0
         ERRMSG = "CANNOT LOCATE SCREEN - ":SCREEN.NAME:"*FRM"
         GOSUB 90000
         GOTO 2099
      END
      BLD.SCRN.NO = ECD.SCRN.NO
2050  PRINT BLD.COMP.SCRN:
2099  RETURN
*--------------------------*
*---- DISPLAY ALL DATA ----*
*--------------------------*
3000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN GOSUB 2000
      DISPLAY.ALL = 1
      FOR INT.REF = 1 TO BLD.FIELD.CNT
         FDEF = BLD.SCRN(INT.REF)
         MULTI.LN = FDEF<1,B.MULTI.LN> + 0
         IF MULTI.LN < 2 THEN MULTI.LN = 1
         LINE.SPACE = FDEF<1,B.MULTI.SP> + 0
         IF LINE.SPACE < 2 THEN LINE.SPACE = 1
         FOR ECD.SUB.NUM = 1 TO MULTI.LN
            GOSUB 8000
         NEXT ECD.SUB.NUM
      NEXT INT.REF
      RETURN
*----------------------------*
*---- GET SPECIFIED DATA ----*
*----------------------------*
4000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN GOSUB 2000
      LOCATE ECD.NUM IN BLD.EXT.REF<1>,1 SETTING INT.REF ELSE
         ERRMSG = "CANNOT LOCATE FIELD REFERENCED - ":ECD.NUM
         GOSUB 90000
         GOTO 4099
      END
      ECD.VALDAT.ITEM = ""
      FDEF = BLD.SCRN(INT.REF)
      MULTI.LN = FDEF<1,B.MULTI.LN> + 0
      LINE.SPACE = FDEF<1,B.MULTI.SP> + 0
      IF LINE.SPACE < 2 THEN LINE.SPACE = 1
      IF MULTI.LN < 2 THEN
         MULTI.LN = 1
         ECD.SUB.NUM = 1
      END
      GOSUB 10000
4099  RETURN
*--------------------------------*
*---- DISPLAY SPECIFIED DATA ----*
*--------------------------------*
5000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN GOSUB 2000
      LOCATE ECD.NUM IN BLD.EXT.REF<1>,1 SETTING INT.REF ELSE
         ERRMSG = "CANNOT LOCATE FIELD REFERENCED - ":ECD.NUM
         GOSUB 90000
         GOTO 5099
      END
      FDEF = BLD.SCRN(INT.REF)
      MULTI.LN = FDEF<1,B.MULTI.LN> + 0
      LINE.SPACE = FDEF<1,B.MULTI.SP> + 0
      IF LINE.SPACE < 2 THEN LINE.SPACE = 1
      IF MULTI.LN < 2 THEN
         MULTI.LN = 1
         ECD.SUB.NUM = 1
      END
      GOSUB 8000
5099  RETURN
*-------------------------------*
*---- CLEAR ALL DATA FIELDS ----*
*-------------------------------*
6000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN
         GOSUB 2000
      END ELSE
         SCREEN.NAME = ECD.SCRN.NAME<ECD.SCRN.NO>
         READ BLD.CLR.DATA FROM CURR.SCREENS.FILE, SCREEN.NAME:"*CLR" ELSE
            BLD.CLR.DATA = ""
         END
         IF BLD.CLR.DATA = "" THEN
            GOSUB 2000
         END ELSE
            PRINT BLD.CLR.DATA:
         END
      END
      RETURN
*
*---- DISPLAY MULTI-LINE FIELD
*
7000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN GOSUB 2000
      LOCATE ECD.NUM IN BLD.EXT.REF<1>,1 SETTING INT.REF ELSE
         ERRMSG = "CANNOT LOCATE FIELD REFERENCED - ":ECD.NUM
         GOSUB 90000
         GOTO 7099
      END
      FDEF = BLD.SCRN(INT.REF)
      MULTI.LN = FDEF<1,B.MULTI.LN> + 0
      IF MULTI.LN < 2 THEN MULTI.LN = 1
      LINE.SPACE = FDEF<1,B.MULTI.SP> + 0
      IF LINE.SPACE < 2 THEN LINE.SPACE = 1
      SAVE.SUB.NUM = ECD.SUB.NUM
      FOR ECD.SUB.NUM = SAVE.SUB.NUM TO SAVE.SUB.NUM + MULTI.LN - 1
         GOSUB 8000
      NEXT ECD.SUB.NUM
7099  RETURN
*
*---- DISPLAY DATA
*
8000  IF FDEF<1,B.PMSG> # "" THEN RETURN
      TYP = FDEF<1,B.TYP>
      X = FDEF<1,B.X>
      Y = FDEF<1,B.Y> + LINE.SPACE * MOD(ECD.SUB.NUM-1, MULTI.LN)
      IF ECD.Y # "" THEN Y = ECD.Y
      MAXL = FDEF<1,B.MAXL>
      JUSTIFY = FDEF<1,B.JUSTIFY>
      IF ECD.SCALER # "" THEN
         SCALER = ECD.SCALER
      END ELSE
         SCALER = FDEF<1,B.SCALER>
      END
      ECD.NUM = BLD.EXT.REF<1,INT.REF>
      IF TYP = 9 THEN
         OUTPUT = ECD.SUB.NUM
      END ELSE
         OUTPUT = SCV.REC(ECD.NUM)<ECD.SCRN.NO,ECD.SUB.NUM>
      END
      IF DISPLAY.ALL AND OUTPUT = "" THEN RETURN
      BEGIN CASE
      CASE TYP = 4 AND INDEX(OUTPUT,".",1) > 0
      CASE TYP = 4
         CONV = "MD":SCALER
         OUTPUT = OCONV(OUTPUT,CONV)
      CASE TYP = 6
         OUTPUT = OCONV(OUTPUT,"D2/")
      END CASE
      FORM = JUSTIFY:"#":MAXL
      OUTPUT = OUTPUT FORM
      IF ECD.Y = "" THEN
         PRINT @(X,Y):OUTPUT:
      END ELSE
         PRINT @(X,ECD.Y):OUTPUT:
         ECD.Y = ""
      END
      RETURN
*------------------------*
*---- GET INPUT DATA ----*
*------------------------*
10000 TYP = FDEF<1,B.TYP>
      X = FDEF<1,B.X>
      Y = FDEF<1,B.Y> + LINE.SPACE * MOD(ECD.SUB.NUM-1, MULTI.LN)
      MAXL = FDEF<1,B.MAXL>
      JUSTIFY = FDEF<1,B.JUSTIFY>
      SCALER = FDEF<1,B.SCALER>
      BMSK = FDEF<1,B.MASK>
      IF BMSK = "" THEN BMSK = "#"
      MSKETX = " "
      IF ECD.ETX.OFF = "" THEN
         EETX.DIN = ""
         EETX.DHD = ""
         EETX.PHD = ""
         EETX.HHD = ""
         EETX.EHD = ""
         EETX.DIN.OFF = ""
         EETX.EHD.OFF = ""
         EETX.HHD.OFF = ""
      END ELSE
         EETX.DIN = ECD.ETX.VALS<1>
         EETX.DHD = ECD.ETX.VALS<2>
         EETX.PHD = ECD.ETX.VALS<3>
         EETX.HHD = ECD.ETX.VALS<4>
         EETX.EHD = ECD.ETX.VALS<5>
         EETX.DIN.OFF = ECD.ETX.VALS<6>
         EETX.EHD.OFF = ECD.ETX.VALS<7>
         EETX.HHD.OFF = ECD.ETX.VALS<8>
      END
      O.R = FDEF<1,B.O.R>
      DEFAULT = FDEF<1,B.DEFAULT>
      MINL = FDEF<1,B.MINL>
      MINV = FDEF<1,B.MINV>
      MAXV = FDEF<1,B.MAXV>
      VALDAT = FDEF<1,B.VALDAT>
      PATRN = FDEF<1,B.PATRN>
      BLINK = FDEF<1,B.BLINK>
      BLANK = FDEF<1,B.BLANK>
      REVERSE = FDEF<1,B.REVERSE>
      EMODE = FDEF<1,B.EMODE>
      EX = FDEF<1,B.EX>
      EY = FDEF<1,B.EY>
      PMSG = FDEF<1,B.PMSG>
      AUTO.RTN = FDEF<1,B.AUTO.RTN>
      FILL.CHR = FDEF<1,B.FILL.CHR>
      ORVALDAT = FDEF<1,B.ORVALDAT>
      INVALCHR = FDEF<1,B.INVALCHR>
      PVALUE = ""
      DVALUE = ""
      BLD.HMSG = ""
      IF TYP < 1 OR TYP > 9 THEN RETURN
*---- OVERRIDE SCREEN PARAMETERS
      IF ECD.VALDAT # "" THEN VALDAT = ECD.VALDAT
      IF ECD.HMSG # "" THEN BLD.HMSG = ECD.HMSG
      IF ECD.Y # "" THEN Y = ECD.Y
      IF ECD.PMSG # "" THEN PMSG = ECD.PMSG
      IF ECD.MAXL # "" THEN MAXL = ECD.MAXL
      IF ECD.MINV # "" THEN MINV = ECD.MINV
      IF ECD.MAXV # "" THEN MAXV = ECD.MAXV
      IF ECD.PATRN # "" THEN PATRN = ECD.PATRN
      IF ECD.O.R # "" THEN O.R = ECD.O.R
      IF ECD.SCALER # "" THEN SCALER = ECD.SCALER
      ORG.O.R = O.R
      BEGIN CASE
      CASE SCV.REC(ECD.NUM)<ECD.SCRN.NO,ECD.SUB.NUM> # ""
         O.R = "O"
         DEFAULT = SCV.REC(ECD.NUM)<ECD.SCRN.NO,ECD.SUB.NUM>
         PVALUE = DEFAULT
      CASE ECD.DEFAULT # ""
         O.R = "O"
         DEFAULT = ECD.DEFAULT
      END CASE
      BEGIN CASE
      CASE DEFAULT = ""
      CASE TYP = 4
         CONV = "MD":SCALER
         DEFAULT = OCONV(DEFAULT,CONV)
         IF PVALUE # "" THEN PVALUE = DEFAULT
      CASE TYP = 6
         IF DEFAULT = "DATE" THEN
            DEFAULT = OCONV(DATE(),"D2/")
         END ELSE
            DEFAULT = OCONV(DEFAULT,"D2/")
         END
         IF PVALUE # "" THEN PVALUE = DEFAULT
      END CASE
      VCNT = DCOUNT(VALDAT,",")
      PCNT = DCOUNT(PATRN,",")
      DPX = 0
      IF PMSG # "" THEN
         PX = X; PY = Y; X = X + LEN(PMSG) + 1
         IF ECD.ETX.OFF # "" AND X + MAXL < 77 THEN
            X = X + 1
            IF PX = 0 THEN
               DPX = 1
            END ELSE
               DPX = PX
            END
         END
      END
      IF Y # 23 AND TRIM(DEFAULT) # "" AND O.R = "O" THEN P.DEFAULT = 1 ELSE P.DEFAULT = 0
      BEGIN CASE
      CASE TYP = 6 AND MAXL = 8
         FILETX = MSKETX:MSKETX:"/":MSKETX:MSKETX:"/":MSKETX:MSKETX
         FILLER = BMSK:BMSK:"/":BMSK:BMSK:"/":BMSK:BMSK
      CASE TYP = 4 AND SCALER > 0
         FILETX = STR(MSKETX,MAXL-SCALER-1):".":STR(MSKETX,SCALER)
         FILLER = STR(BMSK,MAXL-SCALER-1):".":STR(BMSK,SCALER)
      CASE 1
         FILETX = STR(MSKETX,MAXL)
         FILLER = STR(BMSK,MAXL)
      END CASE
11000 BEGIN CASE
      CASE PMSG = ""
      CASE DPX
         PRINT @(DPX,PY):CL:PMSG:ECD.ETX.OFF:
         PRINT @(DPX-1,PY):EETX.PHD:
      CASE 1
         PRINT @(PX,PY):CL:PMSG:SPACE(1):
      END CASE
      BEGIN CASE
      CASE P.DEFAULT
         BEGIN CASE
         CASE ECD.ETX.OFF = ""
            IF LEN(DEFAULT) > 70 THEN
               PRINT @(0,23):CL:DEFAULT "L#79":
            END ELSE
               PRINT @(0,23):CL:"DEFAULT- ":DEFAULT:
            END
         CASE LEN(DEFAULT) < 70
            PRINT @(0,23):CL:EETX.HHD.OFF:"DEFAULT":EETX.HHD.OFF:DEFAULT:EETX.HHD.OFF:
            PRINT @(0,23):EETX.HHD:@(8,23):EETX.HHD:
         CASE LEN(DEFAULT) < 78
            PRINT @(0,23):CL:EETX.HHD.OFF:DEFAULT:EETX.HHD.OFF:
            PRINT @(0,23):EETX.HHD:
         CASE 1
            PRINT @(0,23):CL:DEFAULT "L#79":
         END CASE
         IF ECD.ETX.OFF # "" AND X > 0 AND X + MAXL < 80 THEN
            PRINT @(X-1,Y):EETX.DIN.OFF:FILETX:EETX.DIN.OFF:
            PRINT @(X-1,Y):EETX.DIN:
            INPUT DVALUE,MAXL _:
            PRINT @(X-1,Y):EETX.DHD:
         END ELSE
            PRINT @(X,Y):FILLER:@(X,Y):
            INPUT DVALUE,MAXL _:
         END
         PRINT @(0,23) : CL :
      CASE BLANK = ""
         IF ECD.ETX.OFF # "" AND X > 0 AND X + MAXL < 80 THEN
            PRINT @(X-1,Y):EETX.DIN.OFF:FILETX:EETX.DIN.OFF:
            PRINT @(X-1,Y):EETX.DIN:
            INPUT DVALUE,MAXL _:
            PRINT @(X-1,Y):EETX.DHD:
         END ELSE
            PRINT @(X,Y) : FILLER : @(X,Y) :
            INPUT DVALUE,MAXL _:
         END
      CASE 1
         IF ECD.ETX.OFF # "" AND X > 0 AND X + MAXL < 80 THEN
            PRINT @(X-1,Y):EETX.DIN.OFF:FILETX:EETX.DIN.OFF:
            PRINT @(X-1,Y):EETX.DIN:
            ECHO OFF
            INPUT DVALUE,MAXL _:
            ECHO ON
            PRINT @(X-1,Y):EETX.DHD:
         END ELSE
            PRINT @(X,Y) : FILLER : @(X,Y) :
            ECHO OFF
            INPUT DVALUE,MAXL _:
            ECHO ON
         END
      END CASE
      IF DVALUE # "" AND DVALUE = SPACE(LEN(DVALUE)) THEN
         DELETE.FLAG = 1
         DVALUE = ""
      END ELSE
         DELETE.FLAG = 0
      END
      INLEN = LEN(DVALUE)
      T.DVALUE = TRIM(DVALUE)
*
*---- CHECK INPUT LENGTH
*
      BEGIN CASE
      CASE DELETE.FLAG AND ORG.O.R = "O"
         MINL = 0
         DVALUE = FDEF<1,B.DEFAULT>
         INLEN = LEN(DVALUE)
         IF DVALUE = "" THEN
            VALUE = DVALUE
            GOTO 17000
         END
      CASE INLEN < 1 AND O.R = "O"
         MINL = 0
         DVALUE = DEFAULT
         INLEN = LEN(DVALUE)
         IF DVALUE = "" THEN
            VALUE = DVALUE
            GOTO 17000
         END
      CASE INLEN < 1
         ERRMSG = "** REQUIRED **"
         GOSUB 18000
         GOTO 11000
*
*---- CHECK END REQUEST
*
      CASE T.DVALUE = CHAR(27) OR T.DVALUE = "END" OR T.DVALUE = "^"
         DVALUE = PVALUE
         VALUE  = "END"
         GOTO 17000
*
*----  CHECK HELP REQUEST
*
      CASE T.DVALUE = "?"
         GOSUB 30000
         GOTO 11000
      CASE T.DVALUE = "!"
         GOSUB 40000
         GOTO 11000
      END CASE
*
*--- CHECK (OR) VALID INPUT
*
      IF ORVALDAT AND VCNT THEN
         FOR V = 1 TO VCNT
            IF DVALUE = FIELD(VALDAT,",",V) THEN VCNT = 0
         NEXT V
         IF NOT(VCNT) THEN
            VALUE = DVALUE; GOTO 17000
         END
      END
*
*---- RANGE CHECK INPUT LENGTH
*
      BEGIN CASE
      CASE INLEN < MINL
         ERRMSG = "** MINIMUM LENGTH = " : MINL : " **"
         GOSUB 18000
         GOTO 11000
*
*---  CHECK ILLEGAL CHARACTER INPUT
*
      CASE INVALCHR # ""
         ICNT = DCOUNT(INVALCHR,",")
         FOR I = 1 TO ICNT
            IF INDEX(DVALUE,FIELD(INVALCHR,",",I),1) THEN
               ERRMSG = FIELD(INVALCHR,",",I)
               ICNT = 0
            END
         NEXT I
         IF NOT(ICNT) THEN
            ERRMSG = "** INVALID CHARACTER (":ERRMSG:") INPUT - PLEASE RE-KEY **"
            GOSUB 18000
            GOTO 11000
         END
      END CASE
      T.LEN = LEN(T.DVALUE)
      FOR N = 1 TO T.LEN
         DEC.EQUIV = SEQ(T.DVALUE[N,1])
         IF DEC.EQUIV < 32 OR DEC.EQUIV > 126 THEN
            ERRMSG = "** INVALID INPUT - PLEASE RE-KEY **"
            GOSUB 18000
            GOTO 11000
         END
      NEXT N
*
*---- THE FOLLOWING ALLOWS DATE OR SPECIFIED INPUT
*
      IF TYP = 6 AND VCNT > 0 AND ORVALDAT = "" THEN
         FND = 0
         FOR V = 1 TO VCNT UNTIL FND > 0
            IF DVALUE = FIELD(VALDAT,",",V) THEN FND = V
         NEXT V
         IF FND > 0 THEN
            VALUE = DVALUE
            GOTO 17000
         END ELSE
            VALDAT = ""
         END
      END
      ERRMSG = ""
*
*---- ZERO OR BLANK FILL IF REQUESTED
*
      IF FILL.CHR # "" AND INLEN < MAXL THEN
         IF FILL.CHR = "B" THEN FILL.CHR = " "
         IF JUSTIFY = "R" THEN
            IF NUM(DVALUE) THEN
               DVALUE = STR(FILL.CHR,MAXL-INLEN):DVALUE
            END
         END ELSE
            DVALUE = DVALUE:STR(FILL.CHR,MAXL-INLEN)
         END
      END
*
*---- PROCESS EDIT REQUEST
*
      ON TYP GOSUB 17100,17200,17300,17400,17500,17600,17700,17800,17900
      IF ERRMSG # "" THEN
         GOSUB 18000
         GOTO 11000
      END
*
*---- RANGE CHECK IF REQUESTED
*
      BEGIN CASE
      CASE MINV = MAXV AND (MINV = 0 OR MINV = "")
      CASE VALUE < MINV OR VALUE > MAXV
         ERRMSG = "** OUT OF RANGE **"
         GOSUB 18000
         GOTO 11000
      END CASE
*
*---- CHECK VALID INPUT
*
      IF VCNT > 0 AND ECD.VALDAT.CODE = "" AND ORVALDAT = "" THEN
         FND = 0
         FOR V = 1 TO VCNT UNTIL FND > 0
            IF DVALUE = FIELD(VALDAT,",",V) THEN FND = V
         NEXT V
         IF FND = 0 THEN
            ERRMSG = "** INVALID RESPONSE **"
            GOSUB 18000
            GOTO 11000
         END
      END
17000 IF BLANK # "" THEN GOTO 17010
      FORM = JUSTIFY:"#":MAXL
      PVALUE = DVALUE FORM
      PRINT @(X,Y) : PVALUE :
17010 ECD.RET.VALUE = VALUE
      IF ECD.RET.VALUE = "END" THEN GOTO 17099
      IF ECD.VALDATION = "D" OR (ECD.VALDAT.CODE # "" AND ECD.RET.VALUE # "") THEN
         VAL.ERR = 0
         GOSUB 20000
         IF VAL.ERR = 1 THEN GOTO 11000
      END
      IF PMSG = "" THEN
         SCV.REC(ECD.NUM)<ECD.SCRN.NO,ECD.SUB.NUM> = ECD.RET.VALUE
      END
      TYP       = 1
      PVALUE    = ""
      MINL      = 1
      MAXL      = 1
      MINV      = ""
      MAXV      = ""
      O.R       = "R"
      DEFAULT   = ""
      JUSTIFY   = ""
      SCALER    = 2
      PATRN     = ""
      EMODE     = 1
      EX        = 0
      EY        = 23
      PMSG      = ""
      HMSG      = ""
      VALDAT    = ""
      AUTO.RTN  = 0
      FILL.CHR = ""
      ORVALDAT = ""
      INVALCHR = ""
17099 RETURN
*
*********************  S U B R O U T I N E S  *************************
*
*---- EDIT ALPHANUMERIC INPUT
*
17100 VALUE = DVALUE
      RETURN
*
*---- EDIT ALPHABETIC INPUT
*
17200 *ALPHA(DVALUE) WORKS ONLY WITH NEW COMPILER
      FOR I = 1 TO INLEN WHILE ERRMSG = ""
         CHR = DVALUE[I,1]
         IF CHR < "A" OR CHR > "Z" THEN
            ERRMSG = "** ALPHA INPUT REQUIRED **"
         END
      NEXT I
      IF ERRMSG = "" THEN
         VALUE = DVALUE
      END
17299 RETURN
*
*---- EDIT NUMERIC INPUT
*
17300 IF DVALUE MATCHES "0N" THEN
         VALUE = DVALUE
      END ELSE
         ERRMSG = "** NUMERIC INPUT REQUIRED **"
      END
17399 RETURN
*
*---- EDIT SCALED DECIMAL INPUT
*
17400 IF NOT(NUM(DVALUE)) THEN GOTO 17490
      IF LEN(FIELD(DVALUE,".",1)) > (MAXL - SCALER - 1) THEN GOTO 17490
      IF LEN(FIELD(DVALUE,".",2)) > SCALER THEN GOTO 17490
      CNV = "MD" : SCALER
      VALUE = ICONV(DVALUE,CNV)
      DVALUE= OCONV(VALUE,CNV)
      IF MINV = "" AND MAXV = "" THEN GOTO 17499
      IF INDEX(MINV,".",1) > 0 THEN MINV = ICONV(MINV,CNV)
      IF INDEX(MAXV,".",1) > 0 THEN MAXV = ICONV(MAXV,CNV)
      GOTO 17499
17490 ERRMSG = "** DECIMAL INPUT REQUIRED **"
17499 RETURN
*
*---- EDIT ALPHANUMERIC WITH NO SPACES INPUT
*
17500 IF INDEX(DVALUE," ",1) THEN
         ERRMSG = "** INVALID SPACE CHARACTER INPUT **"
      END ELSE
         VALUE = DVALUE
      END
17599 RETURN
*
*---- EDIT DATE INPUT
*
17600 IF DVALUE = "DATE" THEN DVALUE = OCONV(DATE(),"D2")
      VALUE = ICONV(DVALUE,"D")
      IF VALUE = DVALUE OR VALUE = "" THEN
         ERRMSG = "** INVALID DATE **"
      END ELSE
         DVALUE = OCONV(VALUE,"D2/")
         IF MINV = MAXV AND (MINV = 0 OR MINV = "") THEN GOTO 17699
         IF MINV = "DATE" THEN MINV = DATE()
         IF MAXV = "DATE" THEN MAXV = DATE()
      END
17699 RETURN
*
*---- EDIT PATTERN INPUT
*
17700 FND = 0
      FOR P = 1 TO PCNT UNTIL FND > 0
         IF DVALUE MATCHES FIELD(PATRN,",",P) THEN FND = P
      NEXT P
      IF FND > 0 THEN
         VALUE = DVALUE
      END ELSE
         ERRMSG = "** INVALID FORMAT **"
      END
17799 RETURN
*
*---- EDIT YES OR NO
*
17800 IF DVALUE # "Y" AND DVALUE # "N" THEN
         ERRMSG = "** PLEASE RESPOND (Y) OR (N) **"
      END ELSE
         VALUE = DVALUE
      END
17899 RETURN
*
*---- EDIT (OPEN)
*
17900 VALUE = DVALUE
17999 RETURN
*
*---- ERROR ROUTINE
*
18000 BEGIN CASE
      CASE EMODE = 1 OR EMODE = 4
         ERX = EX
         ERY = EY
      CASE EMODE = 2 OR EMODE = 5
         ERX = 40
         ERY = EY
      CASE EMODE = 3 OR EMODE = 6
         ERX = EX
         ERY = EY
      CASE 1
         ERX = 0
         ERY = 23
      END CASE
      SP.LEN = 79 - ERX
      PRINT @(ERX,ERY):SPACE(SP.LEN):
      PRINT @(ERX,ERY):EETX.EHD.OFF:BEL:ERRMSG:EETX.EHD.OFF:
      PRINT @(ERX,ERY):EETX.EHD:@(ERX+LEN(ERRMSG)+2,ERY):
      IF EMODE < 4 THEN
         INPUT STALL,1 _:
         PRINT @(ERX,ERY):SPACE(LEN(ERRMSG)+1):
      END
      ERRMSG = ""
      RETURN
*
*---- PROCESS VALIDATION REQUEST
*
20000 IF ECD.VALDATION = "D" THEN
         FOUND = 0
         FOR SCV = 1 TO SCV.REC.SIZE WHILE FOUND = 0
            IF SCV.REC(ECD.NUM)<ECD.SCRN.NO,SCV> = ECD.RET.VALUE THEN FOUND = SCV
         NEXT SCV
         IF FOUND AND FOUND # ECD.SUB.NUM THEN
            ERRMSG = "* * " : ECD.RET.VALUE : " ALREADY EXIST ON LINE # " : FOUND : " * *"
            GOSUB 90000
            VAL.ERR = 1
            GOTO 20099
         END
      END
      IF ECD.VALDAT.CODE # "" AND ECD.RET.VALUE # "" THEN
         FOUND = 0
         IF VALDAT # "" AND ORVALDAT = "" THEN
            CNT = COUNT(VALDAT,",") + 1
            FOR I = 1 TO CNT UNTIL FOUND
               IF ECD.RET.VALUE = FIELD(VALDAT,",",I) THEN FOUND = I
            NEXT I
         END
         IF FOUND = 0 THEN
            FOUND = 1
            IF ECD.VALDAT.CODE # "5" THEN
               READ ECD.VALDAT.ITEM FROM ECD.VALDAT.FILE, ECD.PREFIX.ID : ECD.RET.VALUE ELSE
                  FOUND = 0
                  ECD.VALDAT.ITEM = ""
                  BEGIN CASE
                  CASE ECD.VALDAT.CODE = "1"
                     ERRMSG = ECD.RET.VALUE : " IS NOT ON FILE"
                     GOSUB 90000
                  CASE ECD.VALDAT.CODE = "2"
                     ERRMSG = ECD.RET.VALUE : " IS NOT ON FILE TRY AGAIN !"
                     GOSUB 90000
                     VAL.ERR = 1
                     GOTO 20099
                  CASE ECD.VALDAT.CODE = "4"
                     ERRMSG = ECD.RET.VALUE : " IS NOT ON FILE. DO YOU WANT TO ADD (Y/N) :"
                     GOSUB 90000
                     IF ERRVAL # "Y" THEN
                        VAL.ERR = 1
                        GOTO 20099
                     END
                  END CASE
               END
            END ELSE
               READU ECD.VALDAT.ITEM FROM ECD.VALDAT.FILE, ECD.PREFIX.ID : ECD.RET.VALUE ELSE
                  FOUND = 0
                  ECD.VALDAT.ITEM = ""
                  ERRMSG = ECD.RET.VALUE : " IS NOT ON FILE TRY AGAIN !"
                  GOSUB 90000
                  VAL.ERR = 1
                  GOTO 20099
               END
            END
            IF FOUND AND ECD.VALDAT.CODE = "3" THEN
               ERRMSG = "** ":ECD.RET.VALUE:" ALREADY EXISTS ON FILE **"
               GOSUB 90000
               VAL.ERR = 1
               GOTO 20099
            END
         END
      END
20099 RETURN
*
*---- PROCESS HELP REQUEST
30000*
      PORT.NO = "TTY"; CALL SYSVARS.SUB(PORT.NO)
      CALL TCC.SUB1(PORT.NO,MAT TCC.PORT.REC,MAT TCC.REC,MAT GRAPH.REC,MAT VIDEO.REC,MAT KSEL.REC,MAT HBOX.REC)
      IF BLD.HMSG = "" THEN
         HBOX.FILE = CURR.SCREENS.FILE
         HBOX.ID = ECD.SCRN.NAME<ECD.SCRN.NO>:"*HMSG":ECD.NUM
      END ELSE
         HBOX.MSG = BLD.HMSG
         HBOX.ID = ""
      END
      HBOX.SEP = "SM"
      CALL @TCC.HLP.SUB(MAT TCC.REC, MAT GRAPH.REC, MAT VIDEO.REC, MAT KSEL.REC, MAT HBOX.REC)
      RETURN
*
*---- ENTER HELP MESSAGE
40000*
      PORT.NO = "TTY"; CALL SYSVARS.SUB(PORT.NO)
      CALL TCC.SUB1(PORT.NO,MAT TCC.PORT.REC,MAT TCC.REC,MAT GRAPH.REC,MAT VIDEO.REC,MAT KSEL.REC,MAT HBOX.REC)
      HBOX.FILE = CURR.SCREENS.FILE
      HBOX.ID = ECD.SCRN.NAME<ECD.SCRN.NO>:"*HMSG":ECD.NUM
      HBOX.MSG = BLD.HMSG
      HBOX.SEP = "SM"
      CALL @SCL.HLP.SUB(MAT TCC.REC, MAT GRAPH.REC, MAT VIDEO.REC, MAT KSEL.REC, MAT HBOX.REC)
      RETURN
*
*---- CHECK SERIAL NUMBER
*
80000 *
      PORT.NO = "TTY"; CALL SYSVARS.SUB(PORT.NO)
      ACCT.NM = "ACCT"; CALL SYSVARS.SUB(ACCT.NM)
      CALL CHECK.SYSTEM.SN("",SER)
      LSER = LEN(SER)
      CS1 = 0; CS2 = 0
      FOR N = 1 TO LSER
         IF MOD(N,2) THEN
            CS1 = CS1 + SEQ(SER[N,1])
         END ELSE
            CS2 = CS2 + SEQ(SER[N,1])
         END
      NEXT N
      TS1 = 1; TS2 = 1
      FOR N = 1 TO LSER
         IF MOD(N,2) THEN
            TS1 = TS1 * (CS2 + SEQ(SER[N,1]))
         END ELSE
            TS2 = TS2 * (CS1 + SEQ(SER[N,1]))
         END
      NEXT N
      SID = TS2:TS1
      FOUND = 1 ; ITEM.SID = ""
      OPEN "","SECURITY" TO SECURITY ELSE FOUND = 0
      IF FOUND = 1 THEN
         READV ITEM.SID FROM SECURITY, "SID",1 ELSE FOUND = 0
      END
      IF NOT(FOUND) OR ITEM.SID # SID THEN
         PRINT CHAR(12):CHAR(7)
         PRINT "**********************************************************"
         PRINT "*                                                        *"
         PRINT "*  This Software and documentation related thereto, and  *"
         PRINT "*  the information disclosed therein are confidential    *"
         PRINT "*  and proprietary to Computer Business Associates.      *"
         PRINT "*  Neither the software, regardless of the form, nor     *"
         PRINT "*  such data, nor information, may be used by or dis-    *"
         PRINT "*  closed to others for any purpose except as specific-  *"
         PRINT "*  ally authorized in writing by Computer Business       *"
         PRINT "*  Associates.                                           *"
         PRINT "*                                                        *"
         PRINT "**********************************************************"
         RQM 10
         DELETE SECURITY, "R.":PORT.NO
         CHAIN "LO"
      END
      RETURN
*
*---- ERROR ROUTINE
*
90000 PRINT @(0,23):EETX.EHD.OFF:CL:ERRMSG:EETX.EHD.OFF:
      PRINT @(0,23):EETX.EHD:@(LEN(ERRMSG)+2,23):
      INPUT ERRVAL,1 _:
      PRINT @(0,23):CL:
      RETURN
      END
