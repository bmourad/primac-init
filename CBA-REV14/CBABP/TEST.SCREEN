*
*COPY>CPYLIB>COMMON1
***************************************************************************
*
* REVISION    - [08.0]
* Copyright 1982 by Computer Business Associates (Vercom Software, Inc.)
*
* PROGRAM  - SCREEN.BUILD.SUB.1
*
* AUTHOR   - NICK AMENDOLA, COMPUTER BUSINESS ASSOCIATES
*
* DATE     - 01/24/84
*
* REVISION - A.1.1
*
* DESCRIPTION
*
* This program maintains a file of screen definitions. All fixed and
* data fields are defined. The data field definitions contain all
* information necessary to display and edit the data to be processed.
*
***************************************************************************
*
*COPY>CPYLIB>EDIT.COM
*COPY>CPYLIB>ALT.BUILD.SCREEN
*COPY>CPYLIB>CHAR
*
*---- DEFINE VARIABLES
*
     DIM FORM(24)
     DIM CLRS(24,2)
*
*---- OPEN ALL FILES
*
    OPEN "","M.SCREENS" TO M.SCREENS ELSE
       PRINT "CANNOT OPEN M.SCREENS FILE"
       STOP
    END
    OPEN "","UTL.SCREENS" TO SYS.SCREENS ELSE
       PRINT "CANNOT OPEN M.SCREENS FILE"
       STOP
    END
     OPEN "","CONTROL" TO CONTROL ELSE
        PRINT "CANNOT OPEN CONTROL FILE"
        STOP
     END
    OPEN "","O.M.SCREENS" TO O.M.SCREENS ELSE
       PRINT "CANNOT OPEN O.M.SCREENS FILE"
       STOP
    END
    OPEN "","O.UTL.SCREENS" TO O.SYS.SCREENS ELSE
       PRINT "CANNOT OPEN O.SYS.SCREENS FILE"
       STOP
    END
*
*---- INITIALIZATION
*
     TYP = 0
     CALL EDIT.SUB
      SCREEN.DIMENSIONS = ""
      SCREEN.DIMENSIONS<1> = 0
      SCREEN.DIMENSIONS<2> = 22
      SCREEN.DIMENSIONS<3> = 0
      SCREEN.DIMENSIONS<4> = 79
      SCREEN.DIMENSIONS<5> = 0
      SCREEN.DIMENSIONS<6> = 23
      SCREEN.DIMENSIONS<7> = 0
      SCREEN.DIMENSIONS<8> = 79
	  DATA = 1
	  LOOP
	  READNEXT SCREEN.NAME ELSE DATA = 0
	  WHILE DATA DO
     MIN.CRT.ROW = 0
     MAX.CRT.ROW = 22
     MIN.CRT.COL = 0
     MAX.CRT.COL = 79
     MAX.WIDTH = MAX.CRT.COL - MIN.CRT.COL + 1
     SPACE.WIDTH = SPACE(MAX.WIDTH)
     FIRST.ROW = SCREEN.DIMENSIONS<1>
     LAST.ROW = SCREEN.DIMENSIONS<2>
     FIRST.COL = SCREEN.DIMENSIONS<3>
     LAST.COL = SCREEN.DIMENSIONS<4>
     CLR.R1 = SCREEN.DIMENSIONS<5>
     CLR.R2 = SCREEN.DIMENSIONS<6>
     CLR.C1 = SCREEN.DIMENSIONS<7>
     CLR.C2 = SCREEN.DIMENSIONS<8>
     MID.COL = INT((LAST.COL-FIRST.COL)/2) + FIRST.COL
     WIDTH = LAST.COL - FIRST.COL + 1
     ADR.CNT = 4
     FILL = "#"
     COLNOS = ""
     COLNOS = COLNOS:"0.........1.........2.........3........."
     COLNOS = COLNOS:"4.........5.........6.........7........."
     COLNOS = COLNOS:"8.........9.........0.........1........."
     COLNOS = COLNOS:"2.........3.........4.........5........."
     DATA.ROW = ""
     DATA.COL1 = FIRST.COL
     DATA.COL2 = LAST.COL
     COL.REF.FLAG = 0
     ROW.REF.FLAG = 0
     COMP.FLAG = 0
     FIELD.NAME = ""
     HELP.MSG = ""
*
*---- MAIN PROCESSING
*
100*
     MAT FORM = SPACE.WIDTH
     MATREAD ABLD.SCRN FROM O.SYS.SCREENS, SCREEN.NAME:"*FLD" ELSE
        MAT ABLD.SCRN = ""
        PRINT @(-1):
        GOTO 150
     END
     FOR FLD = 1 TO BLD.FIELD.CNT
        EXT.REF = BLD.EXT.REF<1,FLD>
        READ FIELD.NAME FROM O.SYS.SCREENS, SCREEN.NAME:"*NAME":EXT.REF ELSE
           FIELD.NAME = ""
        END
         IF FIELD.NAME # "" THEN
            BLD.FIELD.NAME<1,EXT.REF> = FIELD.NAME
        END
        READ HELP.MSG FROM O.SYS.SCREENS, SCREEN.NAME:"*HMSG":EXT.REF ELSE
           HELP.MSG = ""
        END
         IF HELP.MSG # "" THEN
            BLD.HMSG<1,EXT.REF> = HELP.MSG
        END
     NEXT FLD
150*
     READ BLD.COMP.SCRN FROM O.SYS.SCREENS, SCREEN.NAME:"*FRM" ELSE
        BLD.COMP.SCRN = ""
     END
     GOSUB 6000
     GOSUB 7000
*
*---- GET USER REQUEST
*
1000*
           GOSUB 5000
           GOSUB 5500
				 PRINT BLD.COMP.SCRN:
           WRITE BLD.COMP.SCRN ON SYS.SCREENS, SCREEN.NAME:"*FRM"
           WRITE BLD.CLR.DATA ON SYS.SCREENS, SCREEN.NAME:"*CLR"
           BLD.COMP.SCRN = ""
           BLD.CLR.DATA = ""
           BLD.HMSG = ""
           BLD.FIELD.NAME = ""
			  REPEAT
           GOTO 99999
*
*---- GET ROW NUMBER
*
1100*
     IN.ROW = FIELD(COMMAND[3,99],",",1)
     BEGIN CASE
        CASE IN.ROW # "" AND IN.ROW >= MINROW AND IN.ROW <= MAXROW
           ROW = IN.ROW
        CASE 1
           SAVE.COL.DATA = ""
           FOR ROW = FIRST.ROW TO LAST.ROW
              SAVE.COL.DATA<1,ROW+1> = FORM(ROW+1)[MID.COL,4]
              PRINT @(MID.COL-1,ROW):" ":ROW "R#2":" ":
           NEXT ROW
           ROW.REF.FLAG = 1
           X = 0; Y = 23
           PMSG = CL:"ROW?"
           TYP = 3
           MINL = 1; MAXL = 2
           MINV = MINROW; MAXV = MAXROW
           O.R = "O"
           CALL EDIT.SUB
           ROW = VALUE
           GOSUB 6400
           IF ROW = "END" THEN ROW = ""
     END CASE
     RETURN
*
*---- GET COLUMN NUMBER
*
1200*
     IN.COL = FIELD(COMMAND[3,99],",",2)
     BEGIN CASE
        CASE IN.COL # "" AND IN.COL >= FIRST.COL AND IN.COL <= LAST.COL
           COL = IN.COL
        CASE 1
           IF ROW = MAX.CRT.ROW THEN
              PRINT @(0,ROW-1):CL:SPACE(FIRST.COL):COLNOS[FIRST.COL+1,WIDTH]:
           END ELSE
              PRINT @(0,ROW+1):CL:SPACE(FIRST.COL):COLNOS[FIRST.COL+1,WIDTH]:
           END
           COL.REF.FLAG = 1
           X = 0; Y = 23
           PMSG = CL:"COLUMN?"
           TYP = 3
           MINL = 1; MAXL = 2
           MINV = FIRST.COL; MAXV = LAST.COL
           O.R = "O"
           CALL EDIT.SUB
           COL = VALUE
           IF COL = "" OR COL = "END" THEN
              GOSUB 6500
              COL = ""
           END
     END CASE
     RETURN
*
*---- REPLACE SCREEN LINE
*
2000*
     OLD.LINE = FORM(ROW+1)
     PRINT @(COL,ROW):
     SZ = WIDTH - COL + FIRST.COL
     INPUT IN.DATA,SZ:
     IF LEN(IN.DATA) > 0 THEN COMP.FLAG = 1
     IF LEN(IN.DATA) = SZ THEN
2010*
        PRINT @(COL+SZ-1,ROW):
        INPUT LAST.CHAR,1:
        IF LEN(LAST.CHAR) > 0 THEN
           IN.DATA = IN.DATA[1,SZ-1]:LAST.CHAR
           GOTO 2010
        END
     END
     NEXT.COL = COL + LEN(IN.DATA)
     IF COL = 0 THEN
        FORM(ROW+1) = IN.DATA:OLD.LINE[NEXT.COL+1,999]
     END ELSE
        FORM(ROW+1) = OLD.LINE[1,COL]:IN.DATA:OLD.LINE[NEXT.COL+1,999]
     END
     PRINT @(COL,ROW):CL:FORM(ROW+1)[COL+1,999]:
     DATA.ROW = ROW
     GOSUB 7000
     GOSUB 6500
     RETURN
*
*---- INSERT NEW LINE
*
3000*
     FOR N = LAST.ROW+1 TO ROW+1 STEP -1
        FORM(N+1) = FORM(N)
     NEXT N
     FORM(ROW+1) = SPACE.WIDTH
     GOSUB 5000
     PRINT BLD.COMP.SCRN:
     FOR FLD = 1 TO BLD.FIELD.CNT
        FY = ABLD.SCRN(FLD)<1,B.Y>
        IF FY >= INSERT.ROW THEN
           ABLD.SCRN(FLD)<1,B.Y> = FY + 1
        END
     NEXT FLD
     GOSUB 7000
     RETURN
*
*---- DELETE OLD LINE
*
4000*
     FOR FLD = 1 TO BLD.FIELD.CNT
        FY = ABLD.SCRN(FLD)<1,B.Y>
        ML = ABLD.SCRN(FLD)<1,B.MULTI.LN>
        IF ML = "" THEN ML = 1
        LS = ABLD.SCRN(FLD)<1,B.MULTI.SP>
        IF LS = "" THEN LS = 1
        IF DELETE.ROW >= FY AND DELETE.ROW <= (FY+(ML-1)*LS) THEN
           ERRMSG = "Data fields must be deleted before row deletion..."
           GOSUB 95000
           GOTO 4090
        END
     NEXT FLD
     FOR N = ROW TO LAST.ROW-1
        FORM(N+1) = FORM(N+2)
     NEXT N
     FORM(LAST.ROW+1) = SPACE.WIDTH
     GOSUB 5000
     PRINT BLD.COMP.SCRN:
     FOR FLD = 1 TO BLD.FIELD.CNT
        IF ABLD.SCRN(FLD)<1,B.Y> > DELETE.ROW THEN
           ABLD.SCRN(FLD)<1,B.Y> = ABLD.SCRN(FLD)<1,B.Y> - 1
        END
     NEXT FLD
     GOSUB 7000
4090*
     RETURN
*
*---- COMPRESSION ROUTINE
*
5000*
     BEGIN CASE
        CASE CLR.R1 <= MIN.CRT.ROW AND CLR.R2 >= MAX.CRT.ROW AND CLR.C1 <= MIN.CRT.COL AND CLR.C2 >= MAX.CRT.COL
           BLD.COMP.SCRN = CS
        CASE CLR.C2 = MAX.CRT.COL
           BLD.COMP.SCRN = ""
           FOR ROW = CLR.R1 TO CLR.R2
              BLD.COMP.SCRN = BLD.COMP.SCRN:@(CLR.C1,ROW):CL
           NEXT ROW
        CASE 1
           BLD.COMP.SCRN = ""
           FOR ROW = CLR.R1 TO CLR.R2
              BLD.COMP.SCRN = BLD.COMP.SCRN:@(CLR.C1,ROW):SPACE(CLR.C2-CLR.C1+1)
           NEXT ROW
     END CASE
		 BLD.COMP.SCRN = BLD.COMP.SCRN:@(FIRST.COL,FIRST.ROW)
     DUP.CNT = 0
     FOR ROW = FIRST.ROW TO LAST.ROW
        FOR COL = MIN.CRT.COL TO MAX.CRT.COL
           CHR = FORM(ROW+1)[COL+1,1]
           BEGIN CASE
              CASE TRIM(CHR) = ""
                 DUP.CNT = DUP.CNT + 1
              CASE DUP.CNT < ADR.CNT
                 BLD.COMP.SCRN = BLD.COMP.SCRN:SPACE(DUP.CNT):CHR
                 DUP.CNT = 0
              CASE 1
                 BLD.COMP.SCRN = BLD.COMP.SCRN:@(COL,ROW):CHR
                 DUP.CNT = 0
           END CASE
        NEXT COL
     NEXT ROW
     COMP.FLAG = 0
     RETURN
*
*---- DERIVE STRING TO CLRS DATA ONLY
*
5500*
     MAT CLRS = ""
     FOR ROW = FIRST.ROW TO LAST.ROW
        DONE = 0
        FOR COL = LAST.COL TO FIRST.COL STEP -1 UNTIL DONE
           IF FORM(ROW+1)[COL+1,1] # " " THEN
              CLRS(ROW+1,2) = COL + 1
              DONE = 1
           END
        NEXT COL
     NEXT ROW
     FOR FLD = 1 TO BLD.FIELD.CNT
        ROW = ABLD.SCRN(FLD)<1,B.Y>
        COL = ABLD.SCRN(FLD)<1,B.X>
        ML = ABLD.SCRN(FLD)<1,B.MULTI.LN>
        IF ML = "" THEN ML = 1
        LS = ABLD.SCRN(FLD)<1,B.MULTI.SP>
        IF LS = "" THEN LS = 1
        FOR M = 1 TO ML STEP LS
           MROW = ROW + (M-1) * LS
           IF COL < CLRS(MROW+1,2) THEN
              CLRS(MROW+1,1) = CLRS(MROW+1,1):@(COL,MROW):SPACE(ABLD.SCRN(FLD)<1,B.MAXL>)
           END
        NEXT M
     NEXT FLD
     BLD.CLR.DATA = ""
     FOR ROW = FIRST.ROW TO LAST.ROW
        BLD.CLR.DATA = BLD.CLR.DATA:CLRS(ROW+1,1)
        COL = CLRS(ROW+1,2) + 0
        IF COL < 80 THEN
           BLD.CLR.DATA = BLD.CLR.DATA:@(COL,ROW):CL
        END
     NEXT ROW
     RETURN
*
*---- DECOMPRESSION ROUTINE
*
6000*
     COL = 0
     ROW = 0
     SLEN = LEN(BLD.COMP.SCRN)
     P = 1
     LOOP UNTIL P > SLEN DO
        CHR = BLD.COMP.SCRN[P,1]
        BEGIN CASE
           CASE CHR = CS OR CHR = CHAR(12)
              MAT FORM = SPACE.WIDTH
              COL = FIRST.COL
              ROW = FIRST.ROW
              P = P + 1
           CASE CHR = CHAR(16)        ;* ADDRESS COLUMN
              IF BLD.COMP.SCRN[P+1,1] = CHAR(128) THEN
						 ACOL = 0
						 END ELSE
						 ACOL = SEQ(BLD.COMP.SCRN[P+1,1])
					  END
              BEGIN CASE
              CASE SEQ(BLD.COMP.SCRN[P+2,1]) = 8
                 COL = INT(ACOL/16) * 10 + MOD(ACOL,16) - 1
                 P = P + 3
              CASE 1
                 COL = INT(ACOL/16) * 10 + MOD(ACOL,16)
                 P = P + 2
              END CASE
           CASE CHR = CHAR(11)        ;* ADDRESS ROW
              AROW = SEQ(BLD.COMP.SCRN[P+1,1])
              ROW = AROW - 64
              P = P + 2
           CASE CHR = CHAR(27)        ;* ESCAPE
              P = P + 2
           CASE COL = 0
              FORM(ROW+1) = CHR:FORM(ROW+1)[2,MAX.WIDTH-1]
              P = P + 1
              COL = COL + 1
              IF COL > LAST.COL THEN
                 COL = FIRST.COL
                 ROW = ROW + 1
              END
           CASE 1
              FORM(ROW+1) = FORM(ROW+1)[1,COL]:CHR:FORM(ROW+1)[COL+2,MAX.WIDTH-COL-1]
              P = P + 1
              COL = COL + 1
              IF COL > LAST.COL THEN
                 COL = FIRST.COL
                 ROW = ROW + 1
              END
        END CASE
     REPEAT
     RETURN
*
*---- RE-DISPLAY ROW REFERENCE COLUMNS
*
6400*
     IF ROW.REF.FLAG THEN
        ROW.REF.FLAG = 0
        FOR R = FIRST.ROW TO LAST.ROW
           PRINT @(MID.COL-1,R):SAVE.COL.DATA<1,R+1> "L#4":
        NEXT R
        DATA.COL1 = MID.COL-1
        DATA.COL2 = MID.COL+2
        GOSUB 7000
     END
     RETURN
*
*---- RE-DISPLAY COLUMN REFERENCE ROW
*
6500*
     IF COL.REF.FLAG THEN
        COL.REF.FLAG = 0
        IF ROW = MAX.CRT.ROW THEN
           PRINT @(0,ROW-1):CL:FORM(ROW):
           DATA.ROW = ROW-1
        END ELSE
           PRINT @(0,ROW+1):CL:FORM(ROW+2):
           DATA.ROW = ROW+1
        END
        GOSUB 7000
     END
     RETURN
*
*---- DISPLAY DATA FIELDS
*
7000*
     FOR FLD = 1 TO BLD.FIELD.CNT
        FX = ABLD.SCRN(FLD)<1,B.X>
        IF FX = "" THEN GOTO 7090
        FY = ABLD.SCRN(FLD)<1,B.Y>
        IF FY > LAST.ROW THEN GOTO 7090
        ML = ABLD.SCRN(FLD)<1,B.MULTI.LN>
        IF ML = "" THEN ML = 1
        LS = ABLD.SCRN(FLD)<1,B.MULTI.SP>
        IF LS = "" THEN LS = 1
        IF DATA.ROW = "" OR (DATA.ROW >= FY AND DATA.ROW <= (FY+(ML-1)*LS)) THEN
           IF DATA.COL1 < FX AND DATA.COL2 < FX THEN GOTO 7090
           IF DATA.COL1 >= FX+ABLD.SCRN(FLD)<1,B.MAXL> THEN GOTO 7090
           IF ABLD.SCRN(FLD)<1,B.MASK> = "" THEN
              DFILL = "#"
           END ELSE
              DFILL = ABLD.SCRN(FLD)<1,B.MASK>
           END
           PTYP = ABLD.SCRN(FLD)<1,B.TYP>
           PMAXL = ABLD.SCRN(FLD)<1,B.MAXL>
           BEGIN CASE
              CASE PTYP = 6
                 PMASK = STR(DFILL,2):"/":STR(DFILL,2):"/":STR(DFILL,2)
                 PMASK = PMASK[1,PMAXL]
              CASE PTYP = 4
                 PSCALER = ABLD.SCRN(FLD)<1,B.SCALER>
                 PMASK = STR(DFILL,PMAXL-PSCALER-1):".":STR(DFILL,PSCALER)
              CASE PTYP = 10
                 PMASK = STR(DFILL,2):":":STR(DFILL,4)
                 PMASK = PMASK[1,PMAXL]
              CASE 1
                 PMASK = STR(DFILL,PMAXL)
           END CASE
           *FOR L = 1 TO ML
           *   PRINT @(FX,FY+(L-1)*LS):PMASK:
           *NEXT L
        END
7090*
     NEXT FLD
     DATA.ROW = ""
     DATA.COL1 = FIRST.COL
     DATA.COL2 = LAST.COL
     RETURN
*
*---- DETERMINE EXACT COLUMN
*
8000*
     FOUND = 0
     FOUND2 = 0
     INT.REF = 1
     FOR FLD = 1 TO BLD.FIELD.CNT UNTIL FOUND2
        FX = ABLD.SCRN(FLD)<1,B.X>
        FY = ABLD.SCRN(FLD)<1,B.Y>
        IF ROW = FY AND COL >= FX AND COL < FX + ABLD.SCRN(FLD)<1,B.MAXL> THEN
           IF FOUND THEN
              FOUND2 = 1
           END ELSE
              COL = FX
              FOUND = 1
              INT.REF = FLD
           END
        END
     NEXT FLD
     RETURN
*
*---- GET FIELD REFERENCE NUMBER
*
8500*
     FOUND = 0
     X = 0; Y = 23
     PMSG = CL:"FIELD REFERENCE NUMBER?"
     MINL =1; MAXL = 3
     O.R = "O"; DEFAULT = ""
     CALL EDIT.SUB
     IF VALUE # "END" AND VALUE # "" THEN
        LOCATE VALUE IN BLD.EXT.REF<1>,1 SETTING INT.REF ELSE INT.REF = 0
        IF INT.REF > 0 THEN
           COL = ABLD.SCRN(FLD)<1,B.X>
           FOUND = 1
        END
     END
     RETURN
*
*---- DELETE DATA FIELD
*
9000*
     FX = ABLD.SCRN(INT.REF)<1,B.X>
     FY = ABLD.SCRN(INT.REF)<1,B.Y>
     ML = ABLD.SCRN(INT.REF)<1,B.MULTI.LN>
     IF ML = "" THEN ML = 1
     LS = ABLD.SCRN(INT.REF)<1,B.MULTI.SP>
     IF LS = "" THEN LS = 1
     SPC = SPACE(ABLD.SCRN(INT.REF)<1,B.MAXL>)
     FOR L = 1 TO ML
        PRINT @(FX,FY+(L-1)*LS):SPC:
     NEXT L
     FOR FLD = INT.REF TO BLD.FIELD.CNT-1
        ABLD.SCRN(FLD) = ABLD.SCRN(FLD+1)
     NEXT FLD
     ABLD.SCRN(BLD.FIELD.CNT) = ""
     EXT.REF = BLD.EXT.REF<1,INT.REF>
     IF BLD.HMSG<1,EXT.REF> # "" THEN BLD.HMSG<1,EXT.REF> = "*DELETE*"
     IF BLD.FIELD.NAME<1,EXT.REF> # "" THEN BLD.FIELD.NAME<1,EXT.REF> = "*DELETE*"
     BLD.EXT.REF = DELETE(BLD.EXT.REF,1,INT.REF,0)
     BLD.SORT.ID = DELETE(BLD.SORT.ID,1,INT.REF,0)
     BLD.FIELD.CNT = BLD.FIELD.CNT - 1
     RETURN
*
*---- ERROR PROCESS
*
95000*
     PRINT @(0,23):CL:ERRMSG:
     INPUT REPLY,1:
     PRINT @(0,23):CL:
     RETURN
*
*---- END OF PROGRAM
*
99999*
   END
