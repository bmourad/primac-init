     SUBROUTINE SCREEN.EDIT
*
*COPY>CPYLIB>COMMON1
*
**********************************************************************
*
* REVISION    - [08.0]
* Copyright 1982 by Computer Business Associates (Vercom Software, Inc.)
*
* PROGRAM - SCREEN.EDIT
*
* BY      - NICK AMENDOLA, COMPUTER BUSINESS ASSOCIATES
*
* DATE    - 03/10/84
*
* DESCRIPTION 
*
* This program provides the interface between an aplication program and
* associated screens built and defined by the SCREEN.BUILD sub-system.
* The screens are displayed upon request and all defined editing is
* performed. Editing criteria defined at creation time may be modified
* by the application program at run time.
*
*********************************************************************
*
*---- DEFINE DIMENSIONED VARIABLES
*
*COPY>CPYLIB>EDIT.COM.DRIVER
*COPY>CPYLIB>NEW.BUILD.SCREEN
*COPY>CPYLIB>FILE.VARS
*COPY>CPYLIB>CHAR
*
*------------------------*
*---- INITIALIZATION ----*
*------------------------*
      DISPLAY.ALL = 0
      DASHES = STR('-',80)
      ERRMSG = ''
      LINE.SPACE = 1
*-------------------------*
*---- MAIN PROCESSING ----*
*-------------------------*
100   PROMPT ""
      BEGIN CASE
      CASE ECD.ACTION = 1
         GOSUB 1000                 ;* DEFINE SCREEN NAMES
      CASE ECD.ACTION = 2
         GOSUB 2000                 ;* DISPLAY SCREEN
      CASE ECD.ACTION = 3
         GOSUB 3000                 ;* DISPLAY ALL DATA
      CASE ECD.ACTION = 4
         GOSUB 4000                 ;* GET INPUT DATA
      CASE ECD.ACTION = 5
         GOSUB 5000                 ;* DISPLAY SPECIFIED FIELD
      CASE ECD.ACTION = 6
         GOSUB 6000                 ;* CLEAR ALL DATA FIELDS
      CASE ECD.ACTION = 7
         GOSUB 7000                 ;* DISPLAY MULTI-LINE FIELD
      CASE 1
         ERRMSG = 'INVALID ACTION CODE - ':ECD.ACTION
         GOSUB 90000
      END CASE
*
*---- END OF SUBROUTINE
*
      ECD.DEFAULT = ''
      ECD.VALDATION = ''
      ECD.PREFIX.ID = ''
      ECD.VALDAT.CODE = ''
      ECD.VALDAT.FILE = ''
      ECD.VALDAT = ''
      ECD.HMSG = ''
      ECD.Y = ''
      ECD.PMSG = ''
      ECD.MAXL = ''
      ECD.MINV = ''
      ECD.MAXV = ''
      ECD.PATRN = ''
      ECD.O.R = ''
      ECD.SCALER = ''
      RETURN
*
*------------------------*
*---- DEFINE SCREENS ----*
*------------------------*
1000  MAT BLD.SCRN = ""
      RETURN
*----------------------------------*
*---- DISPLAY SPECIFIED SCREEN ----*
*----------------------------------*
2000* IF BLD.SCRN.NO = ECD.SCRN.NO THEN GOTO 2050
      SCREEN.NAME = ECD.SCRN.NAME<ECD.SCRN.NO>
      MATREAD BLD.SCRN FROM M.SCREENS, SCREEN.NAME:"*FLD" ELSE
         ECD.ACTION = 0
         ERRMSG = "CANNOT LOCATE SCREEN - ":SCREEN.NAME
         GOSUB 90000
         GOTO 2099
      END
      READ BLD.COMP.SCRN FROM M.SCREENS, SCREEN.NAME:"*FRM" ELSE
         ECD.ACTION = 0
         ERRMSG = "CANNOT LOCATE SCREEN - ":SCREEN.NAME:"*FRM"
         GOSUB 90000
         GOTO 2099
      END
      BLD.SCRN.NO = ECD.SCRN.NO
2050  PRINT BLD.COMP.SCRN:
2099  RETURN
*--------------------------*
*---- DISPLAY ALL DATA ----*
*--------------------------*
3000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN GOSUB 2000
      DISPLAY.ALL = 1
      FOR INT.REF = 1 TO BLD.FIELD.CNT
         FDEF = BLD.SCRN(INT.REF)
         MULTI.LN = FDEF<1,B.MULTI.LN> + 0
         IF MULTI.LN = 0 THEN MULTI.LN = 1
         FOR ECD.SUB.NUM = 1 TO MULTI.LN
            GOSUB 8000
         NEXT ECD.SUB.NUM
      NEXT INT.REF
      RETURN
*----------------------------*
*---- GET SPECIFIED DATA ----*
*----------------------------*
4000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN GOSUB 2000
      LOCATE ECD.NUM IN BLD.EXT.REF<1>,1 SETTING INT.REF ELSE
         ERRMSG = "CANNOT LOCATE FIELD REFERENCED - ":ECD.NUM
         GOSUB 90000
         GOTO 4099
      END
      ECD.VALDAT.ITEM = ""
      FDEF = BLD.SCRN(INT.REF)
      MULTI.LN = FDEF<1,B.MULTI.LN> + 0
      IF MULTI.LN < 2 THEN
         MULTI.LN = 1
         ECD.SUB.NUM = 1
      END
      GOSUB 10000
4099  RETURN
*--------------------------------*
*---- DISPLAY SPECIFIED DATA ----*
*--------------------------------*
5000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN GOSUB 2000
      LOCATE ECD.NUM IN BLD.EXT.REF<1>,1 SETTING INT.REF ELSE
         ERRMSG = "CANNOT LOCATE FIELD REFERENCED - ":ECD.NUM
         GOSUB 90000
         GOTO 5099
      END
      FDEF = BLD.SCRN(INT.REF)
      MULTI.LN = FDEF<1,B.MULTI.LN> + 0
      IF MULTI.LN < 2 THEN
         MULTI.LN = 1
         ECD.SUB.NUM = 1
      END
      GOSUB 8000
5099  RETURN
*-------------------------------*
*---- CLEAR ALL DATA FIELDS ----*
*-------------------------------*
6000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN
         GOSUB 2000
      END ELSE
         SCREEN.NAME = ECD.SCRN.NAME<ECD.SCRN.NO>
         READ BLD.CLR.DATA FROM M.SCREENS, SCREEN.NAME:"*CLR" ELSE
            BLD.CLR.DATA = ""
         END
         IF BLD.CLR.DATA = "" THEN
            GOSUB 2000
         END ELSE
            PRINT BLD.CLR.DATA:
         END
      END
      RETURN
*
*---- DISPLAY MULTI-LINE FIELD
*
7000  IF ECD.SCRN.NO # BLD.SCRN.NO THEN GOSUB 2000
      LOCATE ECD.NUM IN BLD.EXT.REF<1>,1 SETTING INT.REF ELSE
         ERRMSG = "CANNOT LOCATE FIELD REFERENCED - ":ECD.NUM
         GOSUB 90000
         GOTO 7099
      END
      FDEF = BLD.SCRN(INT.REF)
      MULTI.LN = FDEF<1,B.MULTI.LN> + 0
      SAVE.SUB.NUM = ECD.SUB.NUM
      FOR ECD.SUB.NUM = SAVE.SUB.NUM TO SAVE.SUB.NUM + MULTI.LN - 1
         GOSUB 8000
      NEXT ECD.SUB.NUM
7099  RETURN
*
*---- DISPLAY DATA
*
8000  IF FDEF<1,B.PMSG> # "" THEN RETURN
      TYP = FDEF<1,B.TYP>
      X = FDEF<1,B.X>
      Y = FDEF<1,B.Y> + LINE.SPACE * MOD(ECD.SUB.NUM-1, MULTI.LN)
      IF ECD.Y # "" THEN Y = ECD.Y
      MAXL = FDEF<1,B.MAXL>
      JUSTIFY = FDEF<1,B.JUSTIFY>
      IF ECD.SCALER # "" THEN
         SCALER = ECD.SCALER
      END ELSE
         SCALER = FDEF<1,B.SCALER>
      END
      ECD.NUM = BLD.EXT.REF<1,INT.REF>
      IF TYP = 9 THEN
         OUTPUT = ECD.SUB.NUM
      END ELSE
         OUTPUT = ECD.RET.VALUES<ECD.SCRN.NO,ECD.NUM,ECD.SUB.NUM>
      END
      IF DISPLAY.ALL AND OUTPUT = "" THEN RETURN
      BEGIN CASE
      CASE TYP = 4
         CONV = 'MD':SCALER
         OUTPUT = OCONV(OUTPUT,CONV)
      CASE TYP = 6
         OUTPUT = OCONV(OUTPUT,"D2/")
      CASE TYP = 10
         OUTPUT = OCONV(OUTPUT, "MTH")
      END CASE
      FORM = JUSTIFY:'#':MAXL
      OUTPUT = OUTPUT FORM
      IF ECD.Y = "" THEN
         PRINT @(X,Y):OUTPUT:
      END ELSE
         PRINT @(X,ECD.Y):OUTPUT:
         ECD.Y = ""
      END
      RETURN
*------------------------*
*---- GET INPUT DATA ----*
*------------------------*
10000 TYP = FDEF<1,B.TYP>
      X = FDEF<1,B.X>
      Y = FDEF<1,B.Y> + LINE.SPACE * MOD(ECD.SUB.NUM-1, MULTI.LN)
      MAXL = FDEF<1,B.MAXL>
      JUSTIFY = FDEF<1,B.JUSTIFY>
      SCALER = FDEF<1,B.SCALER>
      MASK = FDEF<1,B.MASK>
      O.R = FDEF<1,B.O.R>
      DEFAULT = FDEF<1,B.DEFAULT>
      MINL = FDEF<1,B.MINL>
      MINV = FDEF<1,B.MINV>
      MAXV = FDEF<1,B.MAXV>
      VALDAT = FDEF<1,B.VALDAT>
      PATRN = FDEF<1,B.PATRN>
      BLINK = FDEF<1,B.BLINK>
      BLANK = FDEF<1,B.BLANK>
      REVERSE = FDEF<1,B.REVERSE>
      EMODE = FDEF<1,B.EMODE>
      EX = FDEF<1,B.EX>
      EY = FDEF<1,B.EY>
      PMSG = FDEF<1,B.PMSG>
      AUTO.RTN = FDEF<1,B.AUTO.RTN>
      FILL.CHR = FDEF<1,B.FILL.CHR>
      PVALUE = ''
      DVALUE = ''
      BLD.HMSG = ''
      IF TYP < 1 OR TYP > 10 THEN RETURN
      IF MASK = "" THEN MASK = "#"
*---- OVERRIDE SCREEN PARAMETERS
      IF ECD.VALDAT # "" THEN VALDAT = ECD.VALDAT
      IF ECD.HMSG # "" THEN BLD.HMSG = ECD.HMSG
      IF ECD.Y # "" THEN Y = ECD.Y
      IF ECD.PMSG # "" THEN PMSG = ECD.PMSG
      IF ECD.MAXL # "" THEN MAXL = ECD.MAXL
      IF ECD.MINV # "" THEN MINV = ECD.MINV
      IF ECD.MAXV # "" THEN MAXV = ECD.MAXV
      IF ECD.PATRN # "" THEN PATRN = ECD.PATRN
      IF ECD.O.R # "" THEN O.R = ECD.O.R
      IF ECD.SCALER # "" THEN SCALER = ECD.SCALER
      BEGIN CASE
      CASE ECD.RET.VALUES<ECD.SCRN.NO,ECD.NUM,ECD.SUB.NUM> # ''
         O.R = "O"
         DEFAULT = ECD.RET.VALUES<ECD.SCRN.NO,ECD.NUM,ECD.SUB.NUM>
         PVALUE = DEFAULT
      CASE ECD.DEFAULT # ''
         O.R = "O"
         DEFAULT = ECD.DEFAULT
      END CASE
      IF DEFAULT # '' THEN
         BEGIN CASE
         CASE TYP = 4
            CONV = 'MD':SCALER
            DEFAULT = OCONV(DEFAULT,CONV)
            IF PVALUE # "" THEN PVALUE = DEFAULT
         CASE TYP = 6
            IF DEFAULT = "DATE" THEN
               DEFAULT = OCONV(DATE(),"D2/")
            END ELSE
               DEFAULT = OCONV(DEFAULT,"D2/")
            END
            IF PVALUE # "" THEN PVALUE = DEFAULT
         CASE TYP = 10
            IF DEFAULT = "TIME" THEN
               DEFAULT = OCONV(TIME(), "MTH")
            END ELSE
               DEFAULT = OCONV(DEFAULT, "MTH")
            END
            IF PVALUE # "" THEN PVALUE = DEFAULT
         END CASE
      END
      VCNT = COUNT(VALDAT,',') + (VALDAT # '')
      PCNT = COUNT(PATRN,',') + (PATRN # '')
      IF PMSG # '' THEN PX = X; PY = Y; X = X + LEN(PMSG) + 1
      IF Y # 23 AND DEFAULT # '' AND O.R = 'O' THEN P.DEFAULT = 1 ELSE P.DEFAULT = 0
      BEGIN CASE
      CASE TYP = 6 AND MAXL = 8
         FILLER = MASK:MASK:'/':MASK:MASK:'/':MASK:MASK
      CASE TYP = 10 AND MAXL = 7
         FILLER = MASK:MASK:":":MASK:MASK:MASK:MASK
      CASE TYP = 4 AND SCALER > 0
         FILLER = STR(MASK,MAXL-SCALER-1):'.':STR(MASK,SCALER)
      CASE 1
         FILLER = STR(MASK,MAXL)
      END CASE
11000 IF PMSG # '' THEN PRINT @(PX,PY):CL:PMSG:SPACE(1):
      BEGIN CASE
      CASE P.DEFAULT
         PRINT @(0,23) :CL:'DEFAULT - ':DEFAULT[1,69]:
         PRINT @(X,Y) : FILLER : @(X,Y) :
         INPUT DVALUE,MAXL  _:
         PRINT @(0,23):CL:
      CASE BLANK = ""
         PRINT @(X,Y) : FILLER : @(X,Y) :
         INPUT DVALUE,MAXL  _:
      CASE 1
         PRINT @(X,Y) : FILLER : @(X,Y) :
*         DUMMY = OCONV(0,"U80E0")
         ECHO OFF
         INPUT DVALUE,MAXL  _:
*         DUMMY = OCONV(0,"U70E0")
         ECHO ON
      END CASE
*
*---  CHECK ILLEGAL CHARACTER INPUT
*
      IF DVALUE # "" AND DVALUE = SPACE(LEN(DVALUE)) THEN
         DELETE.FLAG = 1
         DVALUE = ""
      END ELSE
         DELETE.FLAG = 0
      END
      INLEN = LEN(DVALUE)
      T.DVALUE = TRIM(DVALUE)
      BEGIN CASE
*
*----  CHECK INPUT LENGTH
*
      CASE DELETE.FLAG AND O.R = 'O'
         MINL = 0
         DVALUE = FDEF<1,B.DEFAULT>
         INLEN = LEN(DVALUE)
         IF DVALUE = '' THEN
            VALUE = DVALUE
            GOTO 17000
         END
      CASE DELETE.FLAG = 0 AND INLEN < 1 AND O.R = 'O'
         MINL = 0
         DVALUE = DEFAULT
         INLEN = LEN(DVALUE)
         IF DVALUE = '' THEN
            VALUE = DVALUE
            GOTO 17000
         END
      CASE INLEN < 1
         ERRMSG = '** REQUIRED **'
         GOSUB 18000
         GOTO 11000
*
*---- CHECK END REQUEST
*
      CASE T.DVALUE = "" OR T.DVALUE = "END" OR T.DVALUE = "^"
         DVALUE = PVALUE
         VALUE  = 'END'
         GOTO 17000
*
*----  CHECK HELP REQUEST
*
      CASE T.DVALUE = "?"
         GOSUB 30000
         GOTO 11000
      CASE T.DVALUE = "!"
         GOSUB 40000
         GOTO 11000
*
*---- RANGE CHECK INPUT LENGTH
*
      CASE INLEN < MINL
         ERRMSG = '** MINIMUM LENGTH = ' : MINL : ' **'
         GOSUB 18000
         GOTO 11000
      END CASE
      T.LEN = LEN(T.DVALUE)
      FOR N = 1 TO T.LEN
         DEC.EQUIV = SEQ(T.DVALUE[N,1])
         IF DEC.EQUIV < 32 OR DEC.EQUIV > 126 THEN
            ERRMSG = '** INVALID INPUT - PLEASE RE-KEY **'
            GOSUB 18000
            GOTO 11000
         END
      NEXT N
*
*---- THE FOLLOWING ALLOWS DATE OR SPECIFIED INPUT
*
      IF TYP = 6 AND VCNT > 0 THEN
         FND = 0
         FOR V = 1 TO VCNT UNTIL FND > 0
            IF DVALUE = FIELD(VALDAT,',',V) THEN FND = V
         NEXT V
         IF FND > 0 THEN
            VALUE = DVALUE
            GOTO 17000
         END ELSE
            VALDAT = ''
         END
      END
      ERRMSG = ''
*
*---- ZERO OR BLANK FILL IF REQUESTED
*
      IF FILL.CHR # "" AND INLEN < MAXL THEN
         IF FILL.CHR = "B" THEN FILL.CHR = " "
         IF JUSTIFY = "R" THEN
            IF NUM(DVALUE) THEN
               DVALUE = STR(FILL.CHR,MAXL-INLEN):DVALUE
            END
         END ELSE
            DVALUE = DVALUE:STR(FILL.CHR,MAXL-INLEN)
         END
      END
*
*---- PROCESS EDIT REQUEST
*
      ON TYP GOSUB 17100,17200,17300,17400,17500,17600,17700,17800,17900,17910
      IF ERRMSG # '' THEN
         GOSUB 18000
         GOTO 11000
      END
*
*---- RANGE CHECK IF REQUESTED
*
      IF MINV = MAXV AND (MINV = 0 OR MINV = '') THEN GOTO 16000
      IF VALUE < MINV OR VALUE > MAXV THEN
         ERRMSG = '** OUT OF RANGE **'
         GOSUB 18000
         GOTO 11000
      END
*
*---- CHECK VALID INPUT
*
16000 IF VCNT > 0 AND ECD.VALDAT.CODE = '' THEN
         FND = 0
         FOR V = 1 TO VCNT UNTIL FND > 0
            IF DVALUE = FIELD(VALDAT,',',V) THEN FND = V
         NEXT V
         IF FND = 0 THEN
           ERRMSG = '** INVALID RESPONSE **'
           GOSUB 18000
           GOTO 11000
         END
      END
17000 IF BLANK # "" THEN GOTO 17010
      FORM = JUSTIFY:'#':MAXL
      PVALUE = DVALUE FORM
      PRINT @(X,Y) : PVALUE :
17010 ECD.RET.VALUE = VALUE
      IF ECD.RET.VALUE = 'END' THEN GOTO 17099
      IF ECD.VALDATION = 'D' OR (ECD.VALDAT.CODE # '' AND ECD.RET.VALUE # '') THEN
         VAL.ERR = 0
         GOSUB 20000
         IF VAL.ERR = 1 THEN GOTO 11000
      END
      IF PMSG = "" THEN
         ECD.RET.VALUES<ECD.SCRN.NO,ECD.NUM,ECD.SUB.NUM> = ECD.RET.VALUE
      END
17099 RETURN
*
*********************  S U B R O U T I N E S  *************************
*
*---- EDIT ALPHANUMERIC INPUT
*
17100 VALUE = DVALUE
      RETURN
*
*---- EDIT ALPHABETIC INPUT
*
17200*ALPHA(DVALUE) WORKS ONLY WITH NEW COMPILER
      FOR I = 1 TO INLEN WHILE ERRMSG = ""
         CHR = DVALUE[I,1]
         IF CHR < "A" OR CHR > "Z" THEN
            ERRMSG = '** ALPHA INPUT REQUIRED **'
         END
      NEXT I
      IF ERRMSG = "" THEN
         VALUE = DVALUE
      END
17299 RETURN
*
*---- EDIT NUMERIC INPUT
*
17300 IF DVALUE MATCHES "0N" THEN
         VALUE = DVALUE
      END ELSE
         ERRMSG = '** NUMERIC INPUT REQUIRED **'
      END
17399 RETURN
*
*---- EDIT SCALED DECIMAL INPUT
*
17400 IF NOT(NUM(DVALUE)) THEN GOTO 17490
      IF LEN(FIELD(DVALUE,".",1)) > (MAXL - SCALER - 1) THEN GOTO 17490
      IF LEN(FIELD(DVALUE,".",2)) > SCALER THEN GOTO 17490
      CNV = 'MD' : SCALER
      VALUE = ICONV(DVALUE,CNV)
      DVALUE= OCONV(VALUE,CNV)
      IF MINV = "" AND MAXV = "" THEN GOTO 17499
      IF INDEX(MINV,".",1) > 0 THEN MINV = ICONV(MINV,CNV)
      IF INDEX(MAXV,".",1) > 0 THEN MAXV = ICONV(MAXV,CNV)
      GOTO 17499
17490 ERRMSG = '** DECIMAL INPUT REQUIRED **'
17499 RETURN
*
*---- EDIT (OPEN)
*
17500 VALUE = DVALUE
17599 RETURN
*
*---- EDIT DATE INPUT
*
17600 IF DVALUE = 'DATE' THEN DVALUE = OCONV(DATE(),'D2')
      VALUE = ICONV(DVALUE,'D')
      IF VALUE = DVALUE OR VALUE = '' THEN
         ERRMSG = '** INVALID DATE **'
      END ELSE
         DVALUE = OCONV(VALUE,'D2/')
         IF MINV = MAXV AND (MINV = 0 OR MINV = '') THEN GOTO 17699
         IF MINV = 'DATE' THEN MINV = DATE()
         IF MAXV = 'DATE' THEN MAXV = DATE()
      END
17699 RETURN
*
*---- EDIT PATTERN INPUT
*
17700 FND = 0
      FOR P = 1 TO PCNT UNTIL FND > 0
         IF DVALUE MATCHES FIELD(PATRN,',',P) THEN FND = P
      NEXT P
      IF FND > 0 THEN
         VALUE = DVALUE
      END ELSE
         ERRMSG = '** INVALID FORMAT **'
      END
17799 RETURN
*
*---- EDIT YES OR NO
*
17800 IF DVALUE # 'Y' AND DVALUE # 'N' THEN
         ERRMSG = '** PLEASE RESPOND (Y) OR (N) **'
      END ELSE
         VALUE = DVALUE
      END
17899 RETURN
*
*---- EDIT (OPEN)
*
17900 VALUE = DVALUE
17909 RETURN
*
*---- EDIT TIME INPUT
*
17910 IF DVALUE = 'TIME' THEN DVALUE = OCONV(TIME(),'MTH')
      BEGIN CASE
         CASE LEN(DVALUE) = 2 AND DVALUE = 12
            DVALUE = DVALUE:"PM"
         CASE LEN(DVALUE) < 7 AND DVALUE[1,2] = 12
            DVALUE = DVALUE:"PM"
      END CASE
      VALUE = ICONV(DVALUE,'MTH')
      IF VALUE = "" THEN
         ERRMSG = '** INVALID TIME **'
      END ELSE
         IF VALUE < 0 OR VALUE > 86340 THEN
            ERRMSG = "** INVALID TIME **"
         END ELSE
            DVALUE = OCONV(VALUE,'MTH')
            IF MINV = MAXV AND (MINV = 0 OR MINV = '') THEN GOTO 17919
            IF MINV = 'TIME' THEN MINV = TIME()
            IF MAXV = 'TIME' THEN MAXV = TIME()
         END
      END
17919 RETURN
*
*---- ERROR ROUTINE
*
18000  BEGIN CASE
       CASE EMODE = 1 OR EMODE = 4
          ERX = EX
          ERY = EY
       CASE EMODE = 2 OR EMODE = 5
          ERX = 40
          ERY = EY
       CASE EMODE = 3 OR EMODE = 6
          ERX = EX
          ERY = EY
       CASE 1
          ERX = 0
          ERY = 23
      END CASE
      SP.LEN = 79 - ERX
      PRINT @(ERX,ERY) : SPACE(SP.LEN) :
      PRINT @(ERX,ERY) : BEL : ERRMSG :
      IF EMODE < 4 THEN
         INPUT STALL,1  _:
         PRINT @(ERX,ERY) : STR(' ',LEN(ERRMSG)+1) :
      END
      ERRMSG = ''
      RETURN
*
*---- PROCESS VALIDATION REQUEST
*
20000 IF ECD.VALDATION = 'D' THEN
         LOCATE ECD.RET.VALUE IN ECD.RET.VALUES<ECD.SCRN.NO,ECD.NUM>,1 SETTING FOUND ELSE FOUND = 0
         IF FOUND AND FOUND # ECD.SUB.NUM THEN
            ERRMSG = '* * ' : ECD.RET.VALUE : ' ALREADY EXIST ON LINE # ' : FOUND : ' * *'
            GOSUB 90000
            VAL.ERR = 1
            GOTO 20099
         END
      END
      IF ECD.VALDAT.CODE # '' AND ECD.RET.VALUE # '' THEN
         FOUND = 0
         IF VALDAT # '' THEN
            CNT = COUNT(VALDAT,',') + 1
            FOR I = 1 TO CNT UNTIL FOUND
               IF ECD.RET.VALUE = FIELD(VALDAT,',',I) THEN FOUND = I
            NEXT I
         END
         IF FOUND = 0 THEN
            FOUND = 1
            IF ECD.VALDAT.CODE # '5' THEN
              READ ECD.VALDAT.ITEM FROM ECD.VALDAT.FILE, ECD.PREFIX.ID : ECD.RET.VALUE ELSE
               FOUND = 0
               ECD.VALDAT.ITEM = ''
               BEGIN CASE
               CASE ECD.VALDAT.CODE = '1'
                  ERRMSG = ECD.RET.VALUE : ' IS NOT ON FILE'
                  GOSUB 90000
               CASE ECD.VALDAT.CODE = '2'
                  ERRMSG = ECD.RET.VALUE : ' IS NOT ON FILE TRY AGAIN !'
                  GOSUB 90000
                  VAL.ERR = 1
                  GOTO 20099
               CASE ECD.VALDAT.CODE = '4'
                  ERRMSG = ECD.RET.VALUE : ' IS NOT ON FILE. DO YOU WANT TO ADD (Y/N) :'
                  GOSUB 90000
                  IF ERRVAL # 'Y' THEN
                     VAL.ERR = 1
                     GOTO 20099
                  END
               END CASE
              END
            END ELSE
              READU ECD.VALDAT.ITEM FROM ECD.VALDAT.FILE, ECD.PREFIX.ID : ECD.RET.VALUE ELSE
                FOUND = 0
                ECD.VALDAT.ITEM = ''
                ERRMSG = ECD.RET.VALUE : ' IS NOT ON FILE TRY AGAIN !'
                GOSUB 90000
                VAL.ERR = 1
                GOTO 20099
               END
            END
            IF FOUND AND ECD.VALDAT.CODE = '3' THEN
               ERRMSG = '** ':ECD.RET.VALUE:' ALREADY EXISTS ON FILE **'
               GOSUB 90000
               VAL.ERR = 1
               GOTO 20099
            END
         END
      END
20099 RETURN
*
*---- PROCESS HELP REQUEST
*
30000 IF BLD.HMSG = "" THEN
         SCREEN.NAME = ECD.SCRN.NAME<ECD.SCRN.NO>
         READ BLD.HMSG FROM M.SCREENS, SCREEN.NAME:"*HMSG":ECD.NUM ELSE
            BLD.HMSG = 'NO HELP MESSAGE FOR THIS FIELD'
         END
      END
      NO.HELPS = COUNT(BLD.HMSG,SVM) + (BLD.HMSG # '')
      FOR HMSG.NO = 1 TO NO.HELPS
         PRINT @(0,23):CL:BLD.HMSG<1,1,HMSG.NO>[1,78]:CL:
         INPUT STALL,1  _:
      NEXT HMSG.NO
      PRINT @(0,23):CL:
      RETURN
*
*---- ENTER HELP MESSAGE
*
40000 IF BLD.HMSG = "" THEN
         SCREEN.NAME = ECD.SCRN.NAME<ECD.SCRN.NO>
         READ BLD.HMSG FROM M.SCREENS, SCREEN.NAME:"*HMSG":ECD.NUM ELSE
            BLD.HMSG = ""
         END
      END
      NO.HELPS = COUNT(BLD.HMSG,SVM) + (BLD.HMSG # '')
      DONE = 0
      FOR HMSG.NO = 1 TO 3 UNTIL DONE
40010    PRINT @(0,23):CL:"Help (":HMSG.NO:") - ":BLD.HMSG<1,1,HMSG.NO>[1,66]:
         PRINT @(11,23):
         INPUT NEW.HMSG,66  _:
         BEGIN CASE
         CASE NEW.HMSG = "" AND HMSG.NO > NO.HELPS
            DONE = 1
         CASE NEW.HMSG = ""
         CASE TRIM(NEW.HMSG) = ""
            BLD.HMSG = DELETE(BLD.HMSG,1,1,HMSG.NO)
            NO.HELPS = COUNT(BLD.HMSG,SVM) + (BLD.HMSG # '')
            GOTO 40010
         CASE 1
            BLD.HMSG<1,1,HMSG.NO> = NEW.HMSG
         END CASE
      NEXT HMSG.NO
      WRITE BLD.HMSG ON M.SCREENS, SCREEN.NAME:"*HMSG":ECD.NUM
      RETURN
*
*---- ERROR ROUTINE
*
90000 PRINT @(0,23) : CL : ERRMSG :
      INPUT ERRVAL,1  _:
      PRINT @(0,23) : CL :
      RETURN
   END
