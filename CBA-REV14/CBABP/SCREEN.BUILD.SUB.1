      SUBROUTINE SCREEN.BUILD.SUB.1 (SCREEN.NAME, SCREEN.DIMENSIONS,SYS.SCREENS)
*
***************************************************************************
*
* REVISION    - [08.0]
* Copyright 1982 by Computer Business Associates (Vercom Software, Inc.)
*
* PROGRAM  - SCREEN.BUILD.SUB.1
*
* AUTHOR   - NICK AMENDOLA, COMPUTER BUSINESS ASSOCIATES
*
* DATE     - 01/24/84
*
* REVISION - A.1.1
*
* DESCRIPTION
*
* This program maintains a file of screen definitions. All fixed and
* data fields are defined. The data field definitions contain all
* information necessary to display and edit the data to be processed.
*
***************************************************************************
*
*COPY>CPYLIB>COM1
*COPY>CPYLIB>COM.SCREEN.BUILD
*COPY>CPYLIB>EDIT.COM
*COPY>CPYLIB>EDIT.COM.DRIVER
*COPY>CPYLIB>ALT.BUILD.SCREEN
*COPY>CPYLIB>CHAR
*
*---- DEFINE VARIABLES
*
      DIM FORM(24)
      DIM CLRS(24,2)
*
*---- INITIALIZATION
*
      MIN.CRT.ROW = 0
      MAX.CRT.ROW = 22
      MIN.CRT.COL = 0
      MAX.CRT.COL = 79
      MAX.WIDTH = MAX.CRT.COL - MIN.CRT.COL + 1
      SPACE.WIDTH = SPACE(MAX.WIDTH)
      FIRST.ROW = SCREEN.DIMENSIONS<1>
      LAST.ROW = SCREEN.DIMENSIONS<2>
      FIRST.COL = SCREEN.DIMENSIONS<3>
      LAST.COL = SCREEN.DIMENSIONS<4>
      CLR.R1 = SCREEN.DIMENSIONS<5>
      CLR.R2 = SCREEN.DIMENSIONS<6>
      CLR.C1 = SCREEN.DIMENSIONS<7>
      CLR.C2 = SCREEN.DIMENSIONS<8>
      MID.COL = INT((LAST.COL-FIRST.COL)/2) + FIRST.COL
      WIDTH = LAST.COL - FIRST.COL + 1
      ADR.CNT = 4
      COLNOS = ""
      COLNOS = COLNOS:"0....^....1....^....2....^....3....^...."
      COLNOS = COLNOS:"4....^....5....^....6....^....7....^...."
      COLNOS = COLNOS:"8....^....9....^....0....^....1....^...."
      COLNOS = COLNOS:"2....^....3....^....4....^....5....^...."
      DATA.ROW = ""
      DATA.COL1 = FIRST.COL
      DATA.COL2 = LAST.COL
      COL.REF.FLAG = 0
      ROW.REF.FLAG = 0
      MOD.ROWS = ""
      FIELD.NAME = ""
      HELP.MSG = ""
*
*---- MAIN PROCESSING
*
100*
      PRINT CS:
      MAT FORM = SPACE.WIDTH
      MATREADU ABLD.SCRN FROM SYS.SCREENS, SCREEN.NAME:"*FLD" ELSE
         MAT ABLD.SCRN = ""
         PRINT CS:
         GOTO 150
      END
      FOR FLD = 1 TO BLD.FIELD.CNT
         EXT.REF = BLD.EXT.REF<1,FLD>
         READ FIELD.NAME FROM SYS.SCREENS, SCREEN.NAME:"*NAME":EXT.REF ELSE
            FIELD.NAME = ""
         END
         IF FIELD.NAME # "" THEN
            BLD.FIELD.NAME<1,EXT.REF> = FIELD.NAME
         END
         READ HELP.MSG FROM SYS.SCREENS, SCREEN.NAME:"*HMSG":EXT.REF ELSE
            HELP.MSG = ""
         END
         IF HELP.MSG # "" THEN
            BLD.HMSG<1,EXT.REF> = HELP.MSG
         END
      NEXT FLD
150*
      READ BLD.COMP.SCRN FROM SYS.SCREENS, SCREEN.NAME:"*FRM" ELSE
         BLD.COMP.SCRN = ""
      END
      PRINT BLD.COMP.SCRN:
      READU BLD.DEF.SCRN FROM SYS.SCREENS, SCREEN.NAME:"*DEF" THEN
         GOSUB 6100
      END ELSE
         GOSUB 6000
         BLD.DEF.SCRN = ""; DPTR = 0
         FOR ROW = FIRST.ROW TO LAST.ROW
            GOSUB 5100
         NEXT ROW
         GOSUB 5300
      END
      GOSUB 7000
*
*---- GET USER REQUEST
*
1000*
      X = 0; Y = 23
      PMSG = "COMMAND ?"
      HMSG = "CR[r[,c]]  DR[r]  IR[r]  AD[r[,c]]  CD[r[,c]]  DD[r[,c]]  E  F"
      MINL = 1; MAXL = 8
      CALL EDIT.SUB
      COMMAND = VALUE
      BEGIN CASE
      CASE COMMAND = "E" OR COMMAND = "e" OR COMMAND = "END" OR COMMAND = "end"
         RELEASE SYS.SCREENS, SCREEN.NAME:"*FLD"
         RELEASE SYS.SCREENS, SCREEN.NAME:"*FRM"
         RELEASE SYS.SCREENS, SCREEN.NAME:"*DEF"
         GOTO 99999
      CASE COMMAND = "F" OR COMMAND = "f"
         IF MOD.ROWS # "" THEN GOSUB 5000
         SCRN.ID = SCREEN.NAME:"*FLD"
         IF BLD.EXT.REF = "" THEN
            DELETE SYS.SCREENS, SCREEN.NAME:"*FLD"
         END ELSE
            MATWRITE ABLD.SCRN ON SYS.SCREENS, SCREEN.NAME:"*FLD"
         END
         IF BLD.DEF.SCRN = "" THEN
            DELETE SYS.SCREENS, SCREEN.NAME:"*DEF"
            DELETE SYS.SCREENS, SCREEN.NAME:"*FRM"
            SCRN.ID = SCREEN.NAME:"*CLR"
            READU DUMMY FROM SYS.SCREENS, SCRN.ID THEN
               DELETE SYS.SCREENS, SCRN.ID
            END ELSE
               RELEASE SYS.SCREENS, SCRN.ID
            END
            SCRN.ID = SCREEN.NAME:"*DIM"
            READU DUMMY FROM SYS.SCREENS, SCRN.ID THEN
               DELETE SYS.SCREENS, SCRN.ID
            END ELSE
               RELEASE SYS.SCREENS, SCRN.ID
            END
         END ELSE
            GOSUB 5500
            WRITE BLD.DEF.SCRN ON SYS.SCREENS, SCREEN.NAME:"*DEF"
            WRITE BLD.COMP.SCRN ON SYS.SCREENS, SCREEN.NAME:"*FRM"
            WRITE BLD.CLR.DATA ON SYS.SCREENS, SCREEN.NAME:"*CLR"
            WRITE SCREEN.DIMENSIONS ON SYS.SCREENS, SCREEN.NAME:"*DIM"
         END
         FN.CNT = DCOUNT(BLD.FIELD.NAME,VM)
         FOR FN = 1 TO FN.CNT
            SCRN.ID = SCREEN.NAME:"*NAME":FN
            READU DUMMY FROM SYS.SCREENS, SCRN.ID ELSE NULL
            FIELD.NAME = BLD.FIELD.NAME<1,FN>
            BEGIN CASE
            CASE FIELD.NAME = ""
               RELEASE SYS.SCREENS, SCRN.ID
            CASE FIELD.NAME = "*DELETE*"
               DELETE SYS.SCREENS, SCRN.ID
            CASE 1
               WRITE FIELD.NAME ON SYS.SCREENS, SCRN.ID
            END CASE
         NEXT FN
         HM.CNT = DCOUNT(BLD.HMSG,VM)
         FOR HM = 1 TO HM.CNT
            SCRN.ID = SCREEN.NAME:"*HMSG":HM
            READU DUMMY FROM SYS.SCREENS, SCRN.ID ELSE NULL
            HELP.MSG = BLD.HMSG<1,HM>
            BEGIN CASE
            CASE HELP.MSG = ""
               RELEASE SYS.SCREENS, SCRN.ID
            CASE HELP.MSG = "*DELETE*"
               DELETE SYS.SCREENS, SCRN.ID
            CASE 1
               WRITE HELP.MSG ON SYS.SCREENS, SCRN.ID
            END CASE
         NEXT HM
         BLD.COMP.SCRN = ""
         BLD.CLR.DATA = ""
         BLD.HMSG = ""
         BLD.FIELD.NAME = ""
         GOTO 99999
      CASE COMMAND[1,2] = "IR" OR COMMAND[1,2] = "ir"
         MINROW = FIRST.ROW; MAXROW = LAST.ROW+1
         GOSUB 1100
         IF ROW = "" THEN GOTO 1000
         INSERT.ROW = ROW
         FOR XROW = ROW TO LAST.ROW
            MOD.ROWS<-1> = XROW
         NEXT XROW
         GOSUB 3000
      CASE COMMAND[1,2] = "CR" OR COMMAND[1,2] = "cr"
         MINROW = FIRST.ROW; MAXROW = LAST.ROW
         GOSUB 1100
         IF ROW = "" THEN GOTO 1000
         GOSUB 1200
         IF COL = "" THEN GOTO 1000
         GOSUB 2000
      CASE COMMAND[1,2] = "DR" OR COMMAND[1,2] = "dr"
         MINROW = FIRST.ROW; MAXROW = LAST.ROW
         GOSUB 1100
         IF ROW = "" THEN GOTO 1000
         DELETE.ROW = ROW
         FOR XROW = ROW TO LAST.ROW
            MOD.ROWS<-1> = XROW
         NEXT XROW
         GOSUB 4000
      CASE COMMAND[1,2] = "AD" OR COMMAND[1,2] = "ad"
         MINROW = FIRST.ROW; MAXROW = LAST.ROW
         GOSUB 1100
         IF ROW = "" THEN GOTO 1000
         GOSUB 1200
         IF COL = "" THEN GOTO 1000
         GOSUB 8000
         IF FOUND AND ABLD.SCRN(INT.REF)<1,B.PMSG> = "" THEN
            ERRMSG = "Field overlap"
            GOSUB 95000
            GOSUB 6500
         END ELSE
            FUNCT = "A"
            ECD.SCRN.NO = ECD.SCRN.NO + 1
            CALL SCREEN.BUILD.SUB.2 (FUNCT, COL, ROW, ERROR.STATUS)
            ECD.SCRN.NO = ECD.SCRN.NO - 1
            PRINT CS:
            IF MOD.ROWS # "" THEN GOSUB 5000
            PRINT BLD.COMP.SCRN:
            GOSUB 7000
         END
      CASE COMMAND[1,2] = "CD" OR COMMAND[1,2] = "cd"
         MINROW = FIRST.ROW; MAXROW = LAST.ROW
         GOSUB 1100
         IF ROW = "" THEN GOTO 1000
         GOSUB 1200
         IF COL = "" THEN GOTO 1000
         GOSUB 8000
         IF FOUND THEN
            FUNCT = "C"
            ECD.SCRN.NO = ECD.SCRN.NO + 1
            CALL SCREEN.BUILD.SUB.2 (FUNCT, COL, ROW, ERROR.STATUS)
            ECD.SCRN.NO = ECD.SCRN.NO - 1
            PRINT CS:
            IF MOD.ROWS # "" THEN GOSUB 5000
            PRINT BLD.COMP.SCRN:
            GOSUB 7000
         END ELSE
            ERRMSG = "Invalid field reference"
            GOSUB 95000
            GOSUB 6500
         END
      CASE COMMAND[1,2] = "DD" OR COMMAND[1,2] = "dd"
         MINROW = FIRST.ROW; MAXROW = LAST.ROW
         GOSUB 1100
         IF ROW = "" THEN GOTO 1000
         GOSUB 1200
         IF COL = "" THEN GOTO 1000
         GOSUB 8000
         IF FOUND2 THEN GOSUB 8500
         IF FOUND THEN
            GOSUB 9000
            DATA.ROW = ROW
            DATA.COL1 = FIRST.COL
            DATA.COL2 = LAST.COL
            GOSUB 7000
            GOSUB 6500
         END ELSE
            ERRMSG = "Invalid field reference"
            GOSUB 95000
            GOSUB 6500
         END
      END CASE
      GOTO 1000
*
*---- GET ROW NUMBER
*
1100*
      IN.ROW = FIELD(COMMAND[3,99],",",1)
      BEGIN CASE
      CASE IN.ROW # "" AND IN.ROW >= MINROW AND IN.ROW <= MAXROW
         ROW = IN.ROW
      CASE 1
         SAVE.COL.DATA = ""
         FOR ROW = FIRST.ROW TO LAST.ROW
            SAVE.COL.DATA<1,ROW+1> = FORM(ROW+1)[MID.COL,4]
            PRINT @(MID.COL-1,ROW):" ":ROW "R#2":" ":
         NEXT ROW
         ROW.REF.FLAG = 1
         X = 0; Y = 23
         PMSG = CL:"ROW?"
         TYP = 3
         MINL = 1; MAXL = 2
         MINV = MINROW; MAXV = MAXROW
         O.R = "O"
         CALL EDIT.SUB
         ROW = VALUE
         GOSUB 6400
         IF ROW = "END" THEN ROW = ""
      END CASE
      RETURN
*
*---- GET COLUMN NUMBER
*
1200*
      IN.COL = FIELD(COMMAND[3,99],",",2)
      BEGIN CASE
      CASE IN.COL # "" AND IN.COL >= FIRST.COL AND IN.COL <= LAST.COL
         COL = IN.COL
      CASE 1
         IF ROW = MAX.CRT.ROW THEN
            PRINT @(0,ROW-1):CL:SPACE(FIRST.COL):COLNOS[FIRST.COL+1,WIDTH]:
         END ELSE
            PRINT @(0,ROW+1):CL:SPACE(FIRST.COL):COLNOS[FIRST.COL+1,WIDTH]:
         END
         COL.REF.FLAG = 1
         X = 0; Y = 23
         PMSG = CL:"COLUMN?"
         TYP = 3
         MINL = 1; MAXL = 2
         MINV = FIRST.COL; MAXV = LAST.COL
         O.R = "O"
         CALL EDIT.SUB
         COL = VALUE
         IF COL = "" OR COL = "END" THEN
            GOSUB 6500
            COL = ""
         END
      END CASE
      RETURN
*
*---- REPLACE SCREEN LINE
*
2000*
      OLD.LINE = FORM(ROW+1)
      PRINT @(COL,ROW):
      SZ = WIDTH - COL + FIRST.COL
      INPUT IN.DATA,SZ:_
      IF LEN(IN.DATA) > 0 THEN
         LOCATE ROW IN MOD.ROWS,1 BY "AR" SETTING PTR ELSE
            INS ROW BEFORE MOD.ROWS<PTR>
         END
      END
      NEXT.COL = COL + LEN(IN.DATA)
      BEGIN CASE
      CASE COL = 0 AND OLD.LINE = STR(OLD.LINE[1,1],WIDTH) AND (IN.DATA = " " OR IN.DATA = "-" OR IN.DATA = "=")
         FORM(ROW+1) = STR(IN.DATA,WIDTH)
      CASE COL = 0
         FORM(ROW+1) = IN.DATA:OLD.LINE[NEXT.COL+1,999]
      CASE 1
         FORM(ROW+1) = OLD.LINE[1,COL]:IN.DATA:OLD.LINE[NEXT.COL+1,999]
      END CASE
      PRINT @(COL,ROW):CL:FORM(ROW+1)[COL+1,999]
      DATA.ROW = ROW
      GOSUB 7000
      GOSUB 6500
      RETURN
*
*---- INSERT NEW LINE
*
3000*
      FOR N = LAST.ROW+1 TO ROW+1 STEP -1
         FORM(N+1) = FORM(N)
      NEXT N
      FORM(ROW+1) = SPACE.WIDTH
      GOSUB 5000
      PRINT BLD.COMP.SCRN:
      FOR FLD = 1 TO BLD.FIELD.CNT
         FY = ABLD.SCRN(FLD)<1,B.Y>
         IF FY >= INSERT.ROW THEN
            ABLD.SCRN(FLD)<1,B.Y> = FY + 1
         END
      NEXT FLD
      GOSUB 7000
      RETURN
*
*---- DELETE OLD LINE
*
4000*
      FOR FLD = 1 TO BLD.FIELD.CNT
         FY = ABLD.SCRN(FLD)<1,B.Y>
         ML = ABLD.SCRN(FLD)<1,B.MULTI.LN>
         IF ML = "" THEN ML = 1
         LS = ABLD.SCRN(FLD)<1,B.MULTI.SP>
         IF LS = "" THEN LS = 1
         IF DELETE.ROW >= FY AND DELETE.ROW <= (FY+(ML-1)*LS) THEN
            ERRMSG = "Data fields must be deleted before row deletion..."
            GOSUB 95000
            GOTO 4090
         END
      NEXT FLD
      FOR N = ROW TO LAST.ROW-1
         FORM(N+1) = FORM(N+2)
      NEXT N
      FORM(LAST.ROW+1) = SPACE.WIDTH
      GOSUB 5000
      PRINT BLD.COMP.SCRN:
      FOR FLD = 1 TO BLD.FIELD.CNT
         IF ABLD.SCRN(FLD)<1,B.Y> > DELETE.ROW THEN
            ABLD.SCRN(FLD)<1,B.Y> = ABLD.SCRN(FLD)<1,B.Y> - 1
         END
      NEXT FLD
      GOSUB 7000
4090*
      RETURN
*
*---- BUILD BLD.DEF.SCRN RECORD
*
5000*
      OLD.DEF = BLD.DEF.SCRN; BLD.DEF.SCRN = ""; DPTR = 0
      FOR ROW = FIRST.ROW TO LAST.ROW
         LOCATE ROW IN MOD.ROWS,1 SETTING PTR THEN
            MOD.ROWS = DELETE(MOD.ROWS,PTR,0,0)
            LOOP WHILE OLD.DEF<1,1> = ROW DO
               OLD.DEF = DELETE(OLD.DEF,1,0,0)
            REPEAT
            GOSUB 5100
         END ELSE
            LOOP WHILE OLD.DEF<1,1> = ROW DO
               DPTR = DPTR + 1
               BLD.DEF.SCRN<DPTR> = OLD.DEF<1>
               OLD.DEF = DELETE(OLD.DEF,1,0,0)
            REPEAT
         END
      NEXT ROW
      MOD.ROWS = ""; OLD.DEF = ""
      GOSUB 5300
      RETURN
*
*---- BUILD BLD.DEF.SCRN COLUMNS
*
5100*
      BEGIN CASE
      CASE TRIM(FORM(ROW+1)) = ""
      CASE FORM(ROW+1) = STR(FORM(ROW+1)[1,1],MAX.WIDTH)
         DPTR = DPTR + 1
         BLD.DEF.SCRN<DPTR> = ROW
         BLD.DEF.SCRN<DPTR,2> = MIN.CRT.COL
         BLD.DEF.SCRN<DPTR,3> = FORM(ROW+1)
      CASE 1
         DUP.CNT = 0; SCOL = FIRST.COL; STMT = ""
         FOR COL = MIN.CRT.COL TO MAX.CRT.COL
            CHR = FORM(ROW+1)[COL+1,1]
            BEGIN CASE
            CASE TRIM(CHR) = ""
               DUP.CNT = DUP.CNT + 1
            CASE DUP.CNT < ADR.CNT
               STMT = STMT:SPACE(DUP.CNT):CHR
               DUP.CNT = 0
            CASE 1
               IF STMT # "" THEN
                  			                 DPTR = DPTR + 1
                  BLD.DEF.SCRN<DPTR> = ROW
                  BLD.DEF.SCRN<DPTR,2> = SCOL
                  BLD.DEF.SCRN<DPTR,3> = STMT
               END
               STMT = CHR
               SCOL = COL
               DUP.CNT = 0
            END CASE
         NEXT COL
         IF STMT # "" THEN
            DPTR = DPTR + 1
            BLD.DEF.SCRN<DPTR> = ROW
            BLD.DEF.SCRN<DPTR,2> = SCOL
            BLD.DEF.SCRN<DPTR,3> = STMT
         END
      END CASE
      RETURN
*
*---- BUILD BLD.COMP.SCRN RECORD
5300*
      BEGIN CASE
      CASE CLR.R1 <= MIN.CRT.ROW AND CLR.R2 >= MAX.CRT.ROW AND CLR.C1 <= MIN.CRT.COL AND CLR.C2 >= MAX.CRT.COL
         BLD.COMP.SCRN = CS
      CASE CLR.C2 = MAX.CRT.COL
         BLD.COMP.SCRN = ""
         FOR ROW = CLR.R1 TO CLR.R2
            BLD.COMP.SCRN = BLD.COMP.SCRN:@(CLR.C1,ROW):CL
         NEXT ROW
      CASE 1
         BLD.COMP.SCRN = ""
         FOR ROW = CLR.R1 TO CLR.R2
            BLD.COMP.SCRN = BLD.COMP.SCRN:@(CLR.C1,ROW):SPACE(CLR.C2-CLR.C1+1)
         NEXT ROW
      END CASE
      FOR DEF = 1 TO DPTR
         BLD.COMP.SCRN = BLD.COMP.SCRN:@(BLD.DEF.SCRN<DEF,2>,BLD.DEF.SCRN<DEF,1>):BLD.DEF.SCRN<DEF,3>
      NEXT DEF
      RETURN
*
*---- DERIVE STRING TO CLRS DATA ONLY
*
5500*
      MAT CLRS = ""
      FOR ROW = FIRST.ROW TO LAST.ROW
         DONE = 0
         FOR COL = LAST.COL TO FIRST.COL STEP -1 UNTIL DONE
            IF FORM(ROW+1)[COL+1,1] # " " THEN
               CLRS(ROW+1,2) = COL + 1
               DONE = 1
            END
         NEXT COL
      NEXT ROW
      FOR FLD = 1 TO BLD.FIELD.CNT
         ROW = ABLD.SCRN(FLD)<1,B.Y>
         COL = ABLD.SCRN(FLD)<1,B.X>
         ML = ABLD.SCRN(FLD)<1,B.MULTI.LN>
         IF ML = "" THEN ML = 1
         LS = ABLD.SCRN(FLD)<1,B.MULTI.SP>
         IF LS = "" THEN LS = 1
         FOR M = 1 TO ML STEP LS
            MROW = ROW + (M-1) * LS
            IF COL < CLRS(MROW+1,2) THEN
               CLRS(MROW+1,1) = CLRS(MROW+1,1):@(COL,MROW):SPACE(ABLD.SCRN(FLD)<1,B.MAXL>)
            END
         NEXT M
      NEXT FLD
      BLD.CLR.DATA = ""
      FOR ROW = FIRST.ROW TO LAST.ROW
         BLD.CLR.DATA = BLD.CLR.DATA:CLRS(ROW+1,1)
         COL = CLRS(ROW+1,2) + 0
         IF COL < 80 THEN
            BLD.CLR.DATA = BLD.CLR.DATA:@(COL,ROW):CL
         END
      NEXT ROW
      RETURN
*
*---- DECOMPRESSION ROUTINE
*
6000*
      COL = 0
      ROW = 0
      SLEN = LEN(BLD.COMP.SCRN)
      P = 1
      LOOP UNTIL P > SLEN DO
         CHR = BLD.COMP.SCRN[P,1]
         BEGIN CASE
         CASE CHR = CS
            MAT FORM = SPACE.WIDTH
            COL = FIRST.COL
            ROW = FIRST.ROW
            P = P + 1
         CASE CHR = CHAR(16)        ;* ADDRESS COLUMN
            ACOL = SEQ(BLD.COMP.SCRN[P+1,1])
            BEGIN CASE
            CASE SEQ(BLD.COMP.SCRN[P+2,1]) = 8
               COL = INT(ACOL/16) * 10 + MOD(ACOL,16) - 1
               P = P + 3
            CASE 1
               COL = INT(ACOL/16) * 10 + MOD(ACOL,16)
               P = P + 2
            END CASE
         CASE CHR = CHAR(11)        ;* ADDRESS ROW
            AROW = SEQ(BLD.COMP.SCRN[P+1,1])
            ROW = AROW - 64
            P = P + 2
         CASE CHR = CHAR(27)        ;* ESCAPE
            P = P + 2
         CASE COL = 0
            FORM(ROW+1) = CHR:FORM(ROW+1)[2,MAX.WIDTH-1]
            P = P + 1
            COL = COL + 1
            IF COL > LAST.COL THEN
               COL = FIRST.COL
               ROW = ROW + 1
            END
         CASE 1
            FORM(ROW+1) = FORM(ROW+1)[1,COL]:CHR:FORM(ROW+1)[COL+2,MAX.WIDTH-COL-1]
            P = P + 1
            COL = COL + 1
            IF COL > LAST.COL THEN
               COL = FIRST.COL
               ROW = ROW + 1
            END
         END CASE
      REPEAT
      RETURN
*
6100*
      MAT FORM = SPACE.WIDTH
      DPTR = DCOUNT(BLD.DEF.SCRN,AM)
      FOR DEF = 1 TO DPTR
         Y = BLD.DEF.SCRN<DEF,1> + 1
         X = BLD.DEF.SCRN<DEF,2>
         STMT = BLD.DEF.SCRN<DEF,3>
         L = LEN(STMT)
         FORM(Y) = FORM(Y)[1,X]:STMT:FORM(Y)[X+L+1,MAX.WIDTH-X-1]
      NEXT DEF
      RETURN
*
*---- RE-DISPLAY ROW REFERENCE COLUMNS
*
6400*
      IF ROW.REF.FLAG THEN
         ROW.REF.FLAG = 0
         FOR R = FIRST.ROW TO LAST.ROW
            PRINT @(MID.COL-1,R):SAVE.COL.DATA<1,R+1> "L#4":
         NEXT R
         DATA.COL1 = MID.COL-1
         DATA.COL2 = MID.COL+2
         GOSUB 7000
      END
      RETURN
*
*---- RE-DISPLAY COLUMN REFERENCE ROW
*
6500*
      IF COL.REF.FLAG THEN
         COL.REF.FLAG = 0
         IF ROW = MAX.CRT.ROW THEN
            PRINT @(0,ROW-1):CL:FORM(ROW):
            DATA.ROW = ROW-1
         END ELSE
            PRINT @(0,ROW+1):CL:FORM(ROW+2):
            DATA.ROW = ROW+1
         END
         GOSUB 7000
      END
      RETURN
*
*---- DISPLAY DATA FIELDS
*
7000*
      FOR FLD = 1 TO BLD.FIELD.CNT
         FX = ABLD.SCRN(FLD)<1,B.X>
         IF FX = "" THEN GOTO 7090
         FY = ABLD.SCRN(FLD)<1,B.Y>
         IF FY > LAST.ROW THEN GOTO 7090
         ML = ABLD.SCRN(FLD)<1,B.MULTI.LN>
         IF ML = "" THEN ML = 1
         LS = ABLD.SCRN(FLD)<1,B.MULTI.SP>
         IF LS = "" THEN LS = 1
         IF DATA.ROW = "" OR (DATA.ROW >= FY AND DATA.ROW <= (FY+(ML-1)*LS)) THEN
            IF DATA.COL1 < FX AND DATA.COL2 < FX THEN GOTO 7090
            IF DATA.COL1 >= FX+ABLD.SCRN(FLD)<1,B.MAXL> THEN GOTO 7090
            IF ABLD.SCRN(FLD)<1,B.MASK> = "" THEN
               DFILL = "#"
            END ELSE
               DFILL = ABLD.SCRN(FLD)<1,B.MASK>
            END
            PTYP = ABLD.SCRN(FLD)<1,B.TYP>
            PMAXL = ABLD.SCRN(FLD)<1,B.MAXL>
            BEGIN CASE
            CASE PTYP = 6
               PMASK = STR(DFILL,2):"/":STR(DFILL,2):"/":STR(DFILL,2)
               PMASK = PMASK[1,PMAXL]
            CASE PTYP = 4
               PSCALER = ABLD.SCRN(FLD)<1,B.SCALER>
               PMASK = STR(DFILL,PMAXL-PSCALER-1):".":STR(DFILL,PSCALER)
            CASE PTYP = 10
               PMASK = STR(DFILL,2):":":STR(DFILL,4)
               PMASK = PMASK[1,PMAXL]
            CASE 1
               PMASK = STR(DFILL,PMAXL)
            END CASE
            FOR L = 1 TO ML
               PRINT @(FX,FY+(L-1)*LS):PMASK:
            NEXT L
         END
7090*
      NEXT FLD
      DATA.ROW = ""
      DATA.COL1 = FIRST.COL
      DATA.COL2 = LAST.COL
      RETURN
*
*---- DETERMINE EXACT COLUMN
*
8000*
      FOUND = 0
      FOUND2 = 0
      INT.REF = 1
      FOR FLD = 1 TO BLD.FIELD.CNT UNTIL FOUND2
         FX = ABLD.SCRN(FLD)<1,B.X>
         FY = ABLD.SCRN(FLD)<1,B.Y>
         IF ROW = FY AND COL >= FX AND COL < FX + ABLD.SCRN(FLD)<1,B.MAXL> THEN
            IF FOUND THEN
               FOUND2 = 1
            END ELSE
               COL = FX
               FOUND = 1
               INT.REF = FLD
            END
         END
8009  NEXT FLD
      RETURN
*
*---- GET FIELD REFERENCE NUMBER
*
8500*
      FOUND = 0
      X = 0; Y = 23
      PMSG = CL:"FIELD REFERENCE NUMBER?"
      MINL =1; MAXL = 3
      O.R = "O"; DEFAULT = ""
      CALL EDIT.SUB
      IF VALUE # "END" AND VALUE # "" THEN
         LOCATE VALUE IN BLD.EXT.REF<1>,1 SETTING INT.REF ELSE INT.REF = 0
         IF INT.REF > 0 THEN
            COL = ABLD.SCRN(FLD)<1,B.X>
            FOUND = 1
         END
      END
      RETURN
*
*---- DELETE DATA FIELD
*
9000*
      FX = ABLD.SCRN(INT.REF)<1,B.X>
      FY = ABLD.SCRN(INT.REF)<1,B.Y>
      ML = ABLD.SCRN(INT.REF)<1,B.MULTI.LN>
      IF ML = "" THEN ML = 1
      LS = ABLD.SCRN(INT.REF)<1,B.MULTI.SP>
      IF LS = "" THEN LS = 1
      SPC = SPACE(ABLD.SCRN(INT.REF)<1,B.MAXL>)
      FOR L = 1 TO ML
         PRINT @(FX,FY+(L-1)*LS):SPC:
      NEXT L
      FOR FLD = INT.REF TO (BLD.FIELD.CNT-1)
         ABLD.SCRN(FLD) = ABLD.SCRN(FLD+1)
      NEXT FLD
      ABLD.SCRN(BLD.FIELD.CNT) = ""
      EXT.REF = BLD.EXT.REF<1,INT.REF>
      IF BLD.HMSG<1,EXT.REF> # "" THEN BLD.HMSG<1,EXT.REF> = "*DELETE*"
      IF BLD.FIELD.NAME<1,EXT.REF> # "" THEN BLD.FIELD.NAME<1,EXT.REF> = "*DELETE*"
      BLD.EXT.REF = DELETE(BLD.EXT.REF,1,INT.REF,0)
      BLD.SORT.ID = DELETE(BLD.SORT.ID,1,INT.REF,0)
      BLD.FIELD.CNT = BLD.FIELD.CNT - 1
      RETURN
*
*---- ERROR PROCESS
*
95000*
      PRINT @(0,23):CL:ERRMSG:
      INPUT REPLY,1:
      PRINT @(0,23):CL:
      RETURN
*
*---- END OF PROGRAM
*
99999*
      RETURN
   END
