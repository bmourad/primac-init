      SUBROUTINE EDIT.SUB
*COPY>CPYLIB>COMMON3
*********************************************************************
*
* REVISION    - [08.0]
* Copyright 1982 by Computer Business Associates (Vercom Software, Inc.)
* PROGRAM       - EDIT.SUB
* BY            - ZIAD YAMOUT, COMPUTER BUSINESS ASSOCIATES
* DATE          - 12/17/82
* DESCRIPTION
*
*   THIS ROUTINE PROVIDES A BASIC INTERFACE BETWEEN
*   ON-LINE PROCESSING PROGRAM AND A TERMINAL OPERATOR.
*   THE FOLLOWING TYPES OF EDITTING MAY BE REQUESTED.
*
*       1 - ALPHANUMERIC
*       2 - ALPHABETIC
*       3 - NUMERIC
*       4 - DECIMAL
*       5 - ALPHANUMERIC WITH NO SPACES
*       6 - DATE
*       7 - PATTERN MATCH
*       8 - (Y)ES OR (N)O
*       9 - (OPEN)
*
*   FIELD LENGTH CHECKING, RANGE CHECKING, LEFT OR
*   RIGHT JUSTIFICATION, AND EXTERNAL TO INTERNAL DATA
*   CONVERSION IS ALSO SUPPORTED.
*
*********************************************************************
*
*************
* DIMENSION *
*************
*
*COPY>CPYLIB>EDIT.COM
*COPY>CPYLIB>CHAR
*
**************
* INITIALIZE *
**************
*
      PROMPT ""
      IF TYP = 0 OR TYP > 9 THEN
         FILL   = "#"
         ERRMSG = ""
         GOTO 200
      END
*
***************************
* MAIN PROCESSING ROUTINE *
***************************
*
100   IF PMSG # "" THEN
         PX = X
         PY = Y
         X  = X + LEN(PMSG) + 1
      END
      IF Y # 23 AND TRIM(DEFAULT) # "" AND O.R = "O" THEN P.DEFAULT = 1 ELSE P.DEFAULT = 0
      BEGIN CASE
      CASE TYP = 6 AND MAXL = 8
         FILLER = FILL:FILL:"/":FILL:FILL:"/":FILL:FILL
      CASE TYP = 4 AND SCALER > 0
         FILLER = STR(FILL,MAXL-SCALER-1):".":STR(FILL,SCALER)
      CASE 1
         FILLER = STR(FILL,MAXL)
      END CASE
110   IF PMSG # "" THEN
         PRINT @(PX,PY) : CL : PMSG : SPACE(1) :
      END
      BEGIN CASE
      CASE P.DEFAULT
         IF LEN(DEFAULT) < 71 THEN
            PRINT @(0,15) : CL : "DEFAULT- " : DEFAULT :
         END ELSE
            PRINT @(0,15) : CL : DEFAULT "L#79" :
         END
         PRINT @(X,Y) : FILLER : @(X,Y) :
         INPUT DVALUE,MAXL _:
         PRINT @(0,15) : CL :
      CASE ECHO.BACK
         PRINT @(X,Y) : FILLER : @(X,Y) :
         INPUT DVALUE,MAXL _:
      CASE 1
         PRINT @(X,Y) : FILLER : @(X,Y) :
         ECHO OFF
         INPUT DVALUE,MAXL _:
         ECHO ON
      END CASE
      IF DVALUE = " " THEN
         DVALUE = ""
         DEFAULT = ""
      END
      INLEN = LEN(DVALUE)
      T.DVALUE = TRIM(DVALUE)
      IF JUSTIFY = "" THEN
         IF TYP = 3 OR TYP = 4 THEN
            JUSTIFY = "R"
         END ELSE
            JUSTIFY = "L"
         END
      END
*
*--- CHECK INPUT LENGTH
*
      BEGIN CASE
      CASE INLEN < 1
         IF O.R = "O" THEN
            MINL = 0
            DVALUE = DEFAULT
            INLEN = LEN(DVALUE)
            IF DVALUE = "" THEN
               VALUE = DVALUE
               GOTO 170
            END
         END ELSE
            ERRMSG = "** REQUIRED **"
            GOSUB 500
            GOTO 110
         END
*
*--- CHECK END REQUEST
*
      CASE T.DVALUE = CHAR(27) OR T.DVALUE = "END" OR T.DVALUE = "^"
         DVALUE = PVALUE
         VALUE  = "END"
         GOTO 170
*
*--- CHECK HELP REQUEST
*
      CASE T.DVALUE = "?"
         IF HMSG = "" THEN HMSG = "NO HELP MESSAGE FOR THIS FIELD"
         NO.HELPS = DCOUNT(HMSG,VM)
         DONE = 0
         FOR HMSG.NO = 1 TO NO.HELPS UNTIL DONE
            PRINT @(0,15):CL:
            PRINT @(2,15):HMSG<1,HMSG.NO>[1,78]:CL:
            PRINT @(0,15):
            INPUT STALL,1 _:
            IF STALL="E" OR STALL="^" OR STALL=CHAR(27) THEN DONE=1
         NEXT HMSG.NO
         PRINT @(0,15) : CL :
         GOTO 110
      END CASE
*
*--- CHECK (OR) VALID INPUT
*
      IF ORVALDAT THEN
         LOCATE DVALUE IN VALDAT<1>,1 SETTING Z THEN
            VALUE = DVALUE
            GOTO 170
         END
      END
*
*--- RANGE CHECK INPUT LENGTH
*
      IF INLEN < MINL THEN
         ERRMSG = "** MINIMUM LENGTH = " : MINL : " **"
         GOSUB 500
         GOTO 110
      END
*
*--- CHECK ILLEGAL CHARACTER INPUT
*
      IF INVALCHR # "" THEN
         CNT = DCOUNT(INVALCHR,VM)
         FOR I = 1 TO CNT
            IF INDEX(DVALUE,INVALCHR<1,I>,1) THEN
               ERRMSG = INVALCHR<1,I>
               CNT = 0
            END
         NEXT I
         IF NOT(CNT) THEN
            ERRMSG = "** INVALID CHARACTER (":ERRMSG:") INPUT **"
            GOSUB 500
            GOTO 110
         END
      END
      T.LEN = LEN(T.DVALUE)
      FOR N = 1 TO T.LEN
         DEC.EQUIV = SEQ(T.DVALUE[N,1])
         IF DEC.EQUIV < 32 OR DEC.EQUIV > 126 THEN
            ERRMSG = "** INVALID INPUT - PLEASE RE-KEY **"
            GOSUB 500
            GOTO 110
         END
      NEXT N
*
*--- THE FOLLOWING ALLOWS DATE OR SPECIFIED INPUT
*
      IF TYP = 6 AND VALDAT # "" AND ORVALDAT = "" THEN
         LOCATE DVALUE IN VALDAT<1>,1 SETTING Z ELSE
            VALDAT = ""
            GOTO 130
         END
         VALUE = DVALUE
         GOTO 170
      END
130   ERRMSG = ""
*
*---- ZERO OR BLANK FILL IF REQUESTED
*
      BEGIN CASE
      CASE FILL.CHR = "" OR INLEN >= MAXL
      CASE NUM(FILL.CHR) AND NOT(NUM(DVALUE))
      CASE 1
         IF FILL.CHR = "B" THEN FILL.CHR = " "
         IF JUSTIFY = "R" THEN
            DVALUE = STR(FILL.CHR,MAXL-INLEN):DVALUE
         END ELSE
            DVALUE = DVALUE:STR(FILL.CHR,MAXL-INLEN)
         END
      END CASE
*
*--- PROCESS EDIT REQUEST
*
      ON TYP GOSUB 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000
      IF ERRMSG # "" THEN
         GOSUB 500
         GOTO 110
      END
*
*--- RANGE CHECK IF REQUESTED
*
      BEGIN CASE
      CASE MINV = MAXV AND (MINV = 0 OR MINV = "")
      CASE VALUE < MINV OR VALUE > MAXV
         ERRMSG = "** OUT OF RANGE **"
         GOSUB 500
         GOTO 110
      END CASE
*
*--- CHECK (AND) VALID INPUT
*
      IF VALDAT # "" AND ORVALDAT = "" THEN
         LOCATE VALUE IN VALDAT<1>,1 SETTING Z ELSE
            ERRMSG = "** INVALID RESPONSE **"
            GOSUB 500
            GOTO 110
         END
      END
*
*--- RE-DISPLAY DATA
*
170   IF NOT(ECHO.BACK) THEN GOTO 190
      OUTLEN = LEN(DVALUE)
      IF JUSTIFY = "L" THEN
         IF FILL = " " THEN
            PVALUE = DVALUE
         END ELSE
            PVALUE = DVALUE : STR(" ",MAXL-OUTLEN)
         END
      END ELSE
         PVALUE = STR(" ",MAXL-OUTLEN) : DVALUE
      END
      PRINT @(X,Y) : PVALUE :
*
*--- INITIALIZE ALL PARAMETERS
*
190   TYP       = 1
      PVALUE    = ""
      MINL      = 1
      MAXL      = 1
      MINV      = ""
      MAXV      = ""
      O.R       = "R"
      DEFAULT   = ""
      JUSTIFY   = ""
      SCALER    = 2
      PATRN     = ""
      EMODE     = 1
      EX        = 0
      EY        = 15
      PMSG      = ""
      HMSG      = ""
      ECHO.BACK = 1
      VID       = ""
      VALDAT    = ""
      AUTO.RTN  = 0
      FILL.CHR = ""
      ORVALDAT = ""
      INVALCHR = ""
      RETURN
*
*---- CHECK SERIAL NUMBER
*
200   IF TYP = 0 THEN
         PORT.NO = 'TTY'
        CALL SYSVARS.SUB(PORT.NO)
*        PORT.NO = PORT.NO[INDEX(PORT.NO,"/",1)+4,99]
         ACCT.NM = @WHO
         CALL CHECK.SYSTEM.SN("",SER)
         LSER = LEN(SER)
         CS1 = 0; CS2 = 0
         FOR N = 1 TO LSER
            IF MOD(N,2) THEN
               CS1 = CS1 + SEQ(SER[N,1])
            END ELSE
               CS2 = CS2 + SEQ(SER[N,1])
            END
         NEXT N
         TS1 = 1; TS2 = 1
         FOR N = 1 TO LSER
            IF MOD(N,2) THEN
               TS1 = TS1 * (CS2 + SEQ(SER[N,1]))
            END ELSE
               TS2 = TS2 * (CS1 + SEQ(SER[N,1]))
            END
         NEXT N
         SID = TS2:TS1
         FOUND = 1 ; ITEM.SID = ""
         OPEN "","SECURITY" TO SECURITY ELSE FOUND = 0
         IF FOUND = 1 THEN
            READV ITEM.SID FROM SECURITY, "SID",1 ELSE FOUND = 0
         END
         IF NOT(FOUND) OR ITEM.SID # SID THEN
            PRINT CHAR(12):CHAR(7)
            PRINT "*********************************************************"
            PRINT "*                                                       *"
            PRINT "*  This Software and documentation related thereto, nd  *"
            PRINT "*  the information disclosed therein are confidentia    *"
            PRINT "*  and proprietary to Computer Business Associates.     *"
            PRINT "*  Neither the software, regardless of the form, nor    *"
            PRINT "*  such data, nor information, may be used by or dis    *"
            PRINT "*  closed to others for any purpose except as specific- *"
            PRINT "*  ally authorized in writing by Computer Business      *"
            PRINT "*  Associates.                                          *"
            PRINT "*                                                       *"
            PRINT "*********************************************************"
            RQM 10
            DELETE SECURITY, "R.":PORT.NO
            CHAIN "LO"
         END
      END
      GOTO 190
*
*****************
* ERROR ROUTINE *
*****************
*
500   BEGIN CASE
      CASE EMODE = 1 OR EMODE = 4
         ERX = EX
         ERY = EY
      CASE EMODE = 2 OR EMODE = 5
         ERX = 40
         ERY = EY
      CASE EMODE = 3 OR EMODE = 6
         ERX = EX
         ERY = EY
      CASE 1
         ERX = 0
         ERY = 15
      END CASE
      SP.LEN = 14 - ERX
      PRINT @(ERX,ERY) : SPACE(SP.LEN) :
      PRINT @(ERX,ERY) : BEL : ERRMSG :
      IF EMODE < 4 THEN
         INPUT STALL,1 _:
         PRINT @(ERX,ERY) : STR(" ",LEN(ERRMSG)+1) :
      END
      ERRMSG = ""
      RETURN
*
***************************
* EDIT ALPHANUMERIC INPUT *
***************************
*
1000  VALUE = DVALUE
      RETURN
*
*************************
* EDIT ALPHABETIC INPUT *
*************************
*
2000*APLHA(DVALUE) WORKS ONLY WITH NEW COMPILER
      FOR I = 1 TO INLEN WHILE ERRMSG = ""
         CHR = DVALUE[I,1]
         IF CHR < "A" OR CHR > "Z" THEN
            ERRMSG = "** ALPHA INPUT REQUIRED **"
         END
      NEXT I
      IF ERRMSG = "" THEN
         VALUE = DVALUE
      END
      RETURN
*
**********************
* EDIT NUMERIC INPUT *
**********************
*
3000  IF DVALUE MATCHES "0N" THEN
         VALUE = DVALUE
      END ELSE
         ERRMSG = "** NUMERIC INPUT REQUIRED **"
      END
      RETURN
*
*****************************
* EDIT SCALED DECIMAL INPUT *
*****************************
*
4000  IF NOT(NUM(DVALUE)) THEN GOTO 4900
      IF LEN(FIELD(DVALUE,".",1)) > (MAXL - SCALER - 1) THEN GOTO 4900
      IF LEN(FIELD(DVALUE,".",2)) > SCALER THEN GOTO 4900
      CNV = "MD" : SCALER
      VALUE = ICONV(DVALUE,CNV)
      DVALUE= OCONV(VALUE,CNV)
      RETURN
4900  ERRMSG = "** DECIMAL INPUT REQUIRED **"
      RETURN
*
******************************************
* EDIT ALPHANUMERIC WITH NO SPACES INPUT *
******************************************
*
5000  IF INDEX(DVALUE," ",1) THEN
         ERRMSG = "** INVALID SPACE CHARACTER INPUT **"
      END ELSE
         VALUE = DVALUE
      END
      RETURN
*
*******************
* EDIT DATE INPUT *
*******************
*
6000  IF DVALUE = "DATE" THEN DVALUE = OCONV(DATE(),"D2")
      VALUE = ICONV(DVALUE,"D")
      IF VALUE = DVALUE OR VALUE = "" THEN
         ERRMSG = "** INVALID DATE **"
      END ELSE
         DVALUE = OCONV(VALUE,"D2/")
         IF MINV = MAXV AND (MINV = 0 OR MINV = "") THEN GOTO 6999
         IF MINV = "DATE" THEN MINV = DATE()
         IF MAXV = "DATE" THEN MAXV = DATE()
6999  END
      RETURN
*
**********************
* EDIT PATTERN INPUT *
**********************
*
7000  CNT = DCOUNT(PATRN,VM)
      FOR I = 1 TO CNT
         IF DVALUE MATCHES PATRN<1,I> THEN
            VALUE = DVALUE
            GOTO 7999
         END
      NEXT I
      ERRMSG = "** INVALID FORMAT **"
7999  RETURN
*
******************
* EDIT YES OR NO *
******************
*
8000  IF DVALUE # "Y" AND DVALUE # "N" THEN
         ERRMSG = "** PLEASE RESPOND (Y) OR (N) **"
      END ELSE
         VALUE = DVALUE
      END
      RETURN
*
***************
* EDIT (OPEN) *
***************
*
9000  VALUE = DVALUE
      RETURN
   END
