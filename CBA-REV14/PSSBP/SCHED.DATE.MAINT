*COPY>CPYLIB>SCOMMON1
*COPY>PSS.CPYLIB>COM.PSS.FILE.VARS
*COPY>PSS.CPYLIB>COM.CCTR.SCHED
*COPY>PSS.CPYLIB>COM.JOB.SCHED
*COPY>JCS.CPYLIB>COM.JOB
*********************************************************************
* REVISION - [08.0]
* Copyright 1982 by Computer Business Associates (Vercom Software, Inc.)
* SYSTEM   - PRIMAC
* SOURCE   - PSSBP
* PROGRAM  - SCHED.DATE.MAINT
* AUTHOR   - WALID YAMOUT, COMPUTER BUSINESS ASSOCIATES
* DATE     - 10/24/88
* MODIFIED - 11/02/95 TERRY NORTHCUTT TASK 19407 DIVISIONALIZATION
* MODIFIED - 02/07/96, NA, TASK 19937, JOB DESC BASED ON COMPANY FLAG.
* DESCRIPTION
* This program allows the user to manualy change the schedule dates
* of jobs in a specific cost center.
* TASK 20899 JR ALLOW "???" ON RE-SCHED DATE FIELD
*T22102 renee 07/25/1997 * Adding CPI'S modifications to REV10B base
*                          package. Changes in this screen are adding
*                          field: component number, category and
*                          category.
*********************************************************************
*
*---- FILE COPY STATEMENTS
*
*COPY>PSS.CPYLIB>CCTR.SCHED
*COPY>PSS.CPYLIB>JOB.SCHED
*COPY>PSS.CPYLIB>PSS.FILE.VARS
*COPY>PSS.CPYLIB>PSS.HIERARCHY
*COPY>JCS.CPYLIB>JOB
*COPY>JES.CPYLIB>ESTIMATE        ; * T22102 (added new CPYLIB)
*COPY>PMC.CPYLIB>COMPANY
*COPY>PMC.CPYLIB>DEPARTMENT
*COPY>PMC.CPYLIB>COST.CNTR
*COPY>CPYLIB>SCREEN.COM
*COPY>CPYLIB>FILE.VARS
*COPY>CPYLIB>GEN.XREF
*COPY>CPYLIB>CHAR
*COPY>CPYLIB>SYSCOM
MAT SYSCOM.REC =  ""; SYS.TYPE = 2
*
*---- PRE-INITIALIZATION
*
      PROC.TYPE = "M"
      DIM SORT.VALS(5)           ; * T22102 (added new array)
*
*---- OPEN ALL FILES
*
      OPEN "","COMPANY" TO COMPANY ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN COMPANY FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","CONTROL" TO CONTROL ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN CONTROL FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","PREFIX" TO PREFIX ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN PREFIX FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","PSS.SCREENS" TO M.SCREENS ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN PSS.SCREENS FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","CCTR.SCHED" TO CCTR.SCHED ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN CCTR.SCHED FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","PEND.CCTR.SCHED" TO PEND.CCTR.SCHED ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN PEND.CCTR.SCHED FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","CCTR.AVAIL" TO CCTR.AVAIL ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN CCTR.AVAIL FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","HOLIDAY.SCHED" TO HOLIDAY.SCHED ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN HOLIDAY.SCHED FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","JOB.SCHED" TO JOB.SCHED ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN JOB.SCHED FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","PEND.JOB.SCHED" TO PEND.JOB.SCHED ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN PEND.JOB.SCHED FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","JOB.CRTL.DATE.EXC" TO JOB.CRTL.DATE.EXC ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN JOB.CRTL.DATE.EXC FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
*---- TASK 19407
      OPEN "","JOB" TO JOB ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN JOB FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
*---- TASK 19407
      OPEN "","DEPARTMENT" TO DEPARTMENT ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN DEPARTMENT FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","COST.CNTR" TO COST.CNTR ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN COST.CNTR FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","OPERATION" TO OPERATION ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN OPERATION FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","PSS.CONTROL" TO PSS.CONTROL ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN PSS.CONTROL FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","PSS.HIERARCHY" TO PSS.HIERARCHY ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN PSS.HIERARCHY FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","PSS.JOURNAL" TO PSS.JOURNAL ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN PSS.JOURNAL FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
      OPEN "","PSS.LOCK" TO PSS.LOCK ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN PSS.LOCK FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
* T22102 v (added open statement for ESTIMATE)
      OPEN "","ESTIMATE" TO ESTIMATE ELSE
         P_X = 3 ; P_Y = 23 ; P_VALUE = "CANNOT OPEN ESTIMATE FILE" ; P_OPT = ""
         CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
         STOP
      END
* T22102 ^
*
*--- CHECK FOR HIERARCHY
*
      ERRMSG = ""
      MATREAD PSHR.REC FROM PSS.CONTROL, "HIERARCHY" ELSE
         ERRMSG = "SYSTEM HIERARCHY RECORD IS MISSING"
         GOSUB 90000
         GOTO 999999
      END
      MAT PSHR.REC = ""
*
*---- GET COMPANY
*
      CONO = ""
      CALL GET.CONO1 (CONO, MAT COMP.REC, COMPANY, CONTROL)
      IF CONO = "END" THEN GOTO 999999
*---- TASK 19407
*
*---- PERFORM PROCREAD
*
      PROCREAD BUFFER ELSE
         ERRMSG = "MUST RUN FROM A PROC"
         GOSUB 90000
         GOTO 999999
      END
      DIV.OWNER = BUFFER<3>
*---- TASK 19407
*
*--- CHECK FOR LOCKS
*
      DUMMY = ""
      REC.LOCK = 0
      READU DUMMY FROM PSS.CONTROL, CONO : DIV.OWNER : "SCHED.FLG" LOCKED REC.LOCK = 1 ELSE DUMMY = "" ; *---- TASK 19407
      IF REC.LOCK THEN
         ERRMSG = "MUST WAIT UNTIL SCHEDULE PROCESS IS DONE"
         GOSUB 90000
         GOTO 98888
      END
      DUMMY = ""
      REC.LOCK = 0
      READU DUMMY FROM PSS.CONTROL, CONO : DIV.OWNER : "UNSCHED.FLG" LOCKED REC.LOCK = 1 ELSE DUMMY = "" ; *---- TASK 19407
      IF REC.LOCK THEN
         ERRMSG = "MUST WAIT UNTIL UNSCHEDULE PROCESS IS DONE"
         GOSUB 90000
         GOTO 98888
      END
      RELEASE PSS.CONTROL, CONO : DIV.OWNER : "UNSCHED.FLG" ; *---- TASK 19407
      DUMMY = ""
      REC.LOCK = 0
      READU DUMMY FROM PSS.CONTROL, CONO : DIV.OWNER : "JOB.SCHED.LIST" LOCKED REC.LOCK = 1 ELSE DUMMY = "" ; *---- TASK 19407
      IF REC.LOCK THEN
         ERRMSG = "MUST WAIT UNTIL MULTI SCHEDULE PROCESS IS DONE"
         GOSUB 90000
         GOTO 98888
      END
      RELEASE PSS.CONTROL, CONO : DIV.OWNER : "JOB.SCHED.LIST" ; *---- TASK 19407
      DUMMY = ""
*
*---- INITIALIZATION
*
      READ DEMODATE FROM CONTROL,"DEMODATE" THEN TODAY=ICONV(DEMODATE,"D") ELSE TODAY=DATE()
      MAT GEN.XREF.REC = ""
      SCREEN INIT;#
      S$SCR = 1
      SCREEN DEFINE;SCHED.DATE.MAINT
      SCREEN FORMAT
      SCREEN COUNT;;11
      LINE.COUNT = S$LCNT
      LINE.SPACE = S$LSPC
      TP.ERRMSG = ""
      GOTO 110
*
*---- MAIN PROCESSING
*
100*
      SCREEN CLEAR
110*
      GOSUB 89900;* CHECK FOR ACTIVE TRANSACTION
* T22102 v (added 5 new variables)
      SORT.OPTIONS = ""
      UNSCHED.LIST = ""
      UNSCHED.SPTR = ""
      UNSCHED.PRI  = ""
      UNSCHED.DUE  = ""
* T22102 ^
      S$DATA(1)<S$SCR> = TODAY
      SCREEN DISPLAY;;1
120*
      SCREEN FIELD;;2
      SCREEN INPUT;;2;GOTO 999999
      DEPT = S$VALUE
      IF DEPT = "" THEN
         MAT DEPT.REC = ""
      END ELSE
         MATREAD DEPT.REC FROM DEPARTMENT, CONO:DEPT ELSE
            ERRMSG = "Invalid Department"
            GOSUB 90000
            GOTO 120
         END
         S$DATA(3)<S$SCR> = DEPT.DESC
         SCREEN DISPLAY;;3
      END
130*
      SCREEN FIELD;;5
      SCREEN INPUT;;5;GOTO 100
      CCTR = S$VALUE
      BEGIN CASE
         CASE CCTR = "???" AND DEPT # ""
            GXR.CO = CONO
            GXR.XREF = DEPARTMENT
            GXR.SRCH.ID = DEPT
            GXR.FILE = COST.CNTR
            GXR.LOC = 5
            GXR.TOP.LINE = "COST CENTER XREF SEARCH"
            GXR.HEADING<1,1> = "CCTR"
            GXR.ATT<1,1> = 0
            GXR.LEN<1,1> = 4
            GXR.HEADING<1,2> = "DESCRIPTION"
            GXR.ATT<1,2> = 1
            GXR.LEN<1,2> = 30
            GXR.ID = ""
*         CALL GEN.XREF1 (MAT GEN.XREF.REC, PREFIX)
            CALL GEN.XREF (MAT GEN.XREF.REC, PREFIX)
            CCTR = GXR.ID
            IF GXR.ACTION # "X" THEN
               SCREEN FORMAT
               S$DATA(5)<S$SCR> = CCTR
               GOSUB 60000
            END
            IF GXR.ID = "" THEN GOTO 130
         CASE CCTR # "" AND DEPT = ""
            NULL
         CASE DEPT # ""
            LOCATE CCTR IN DEPT.CCTRS<1>,1 SETTING C ELSE
               ERRMSG = "Invalid cost center for specified department"
               GOSUB 90000
               GOTO 130
            END
         CASE 1
            ERRMSG = "Invalid Entry"
            GOSUB 90000
            GOTO 130
      END CASE
      IF CCTR = "" THEN
         MAT CCTR.REC = ""
      END ELSE
         MATREAD CCTR.REC FROM COST.CNTR, CONO:CCTR ELSE
            ERRMSG = "Invalid Cost Center"
            GOSUB 90000
            GOTO 130
         END
         IF CCTR.MASTER # "" AND CCTR.MASTER # CCTR THEN
            ERRMSG = "This is not a master Cost Center"
            GOSUB 90000
            GOTO 130
         END
         IF DEPT = "" OR DEPT # CCTR.DEPT THEN
            DEPT = CCTR.DEPT
            MATREAD DEPT.REC FROM DEPARTMENT, CONO:DEPT ELSE
               MAT DEPT.REC = ""
               DEPT.DESC = "???????????????"
            END
            S$DATA(2)<S$SCR> = DEPT
            S$DATA(3)<S$SCR> = DEPT.DESC
            SCREEN DISPLAY;;2
            SCREEN DISPLAY;;3
         END
         S$DATA(6)<S$SCR> = CCTR.DESC
         SCREEN DISPLAY;;6
      END
140*
      SCREEN FIELD;;4
      SCREEN INPUT;;4;GOTO 100
* T22102 v (comment out next five lines)
*      IF S$VALUE < TODAY THEN
*         ERRMSG = "Invalid date. The date cannot be less than today's date."
*         GOSUB 90000
*         GOTO 140
*      END
* T22102 ^
      SDATE = S$VALUE
150*
      EDATE = SDATE + 27
      UPDATE.FLAG = ""
      LINE.CNT = 0
      TEMP.TRAN = ""
      FOR CDATE = SDATE TO EDATE
         GOSUB 40000
      NEXT CDATE
      S$DATA(7)<S$SCR> = EDATE
      SCREEN DISPLAY;;7
      REF = 1
      CURR.REF.NO = ""
      GOSUB 50000
*
*---- GET OPERATOR REQUEST
*
500*
      BEGIN CASE
         CASE PROC.TYPE = "M" AND TP.DIV # "X"
            SCREEN FIELD;;8
            SCREEN INPUT;;8
         CASE 1
            SCREEN FIELD;;23
            SCREEN INPUT;;23
      END CASE
      OPTION = S$VALUE
510*
      BEGIN CASE
         CASE OPTION = "S" OR OPTION = "SF"
            REF = CURR.REF.NO + LINE.COUNT
            IF REF > LINE.CNT THEN REF = 1
            GOSUB 50000
         CASE OPTION = "ST"
            REF = 1
            GOSUB 50000
         CASE OPTION = "SB"
            REF = LINE.CNT
            IF REF < 1 THEN REF = 1
            GOSUB 50000
         CASE OPTION = "SR"
            REF = CURR.REF.NO - LINE.COUNT
            IF REF < 1 THEN REF = 1
            GOSUB 50000
         CASE OPTION = "E" OR OPTION = "END"
* T22102 v (next exit time logic at CASE OPTION = "E")
           IF UNSCHED.LIST # "" THEN
             * Return these jobs to the unscheduled list by updating
             *   the PSS.CONTROL record.
             SCREEN FIELD;;56
             SCREEN INPUT;;56
             IF S$VALUE = "Y" THEN
               111
               JSL.ID = CONO:DIV.OWNER:"JOB.SCHED.LIST"
               READU SCH.LIST FROM PSS.CONTROL, JSL.ID LOCKED GOTO 111 ELSE SCH.LIST = ""
               FOR JNO = 1 TO DCOUNT(UNSCHED.LIST, VM)
                 JOB.ID = UNSCHED.LIST<1,JNO>
                 NUM.SCH.LIST = DCOUNT(SCH.LIST,@AM)
                 FND = 0
                 FOR PTR = 1 TO NUM.SCH.LIST WHILE NOT(FND)
                   IF JOB.ID = SCH.LIST<PTR,1> THEN 
                     FND=1
                   END
                 NEXT PTR
                 IF NOT(FND) THEN
                   SCH.LIST<-1> = JOB.ID:VM:"S":VM:UNSCHED.DUE<1,JNO>:VM:UNSCHED.PRI<1,JNO>
                 END
               NEXT JNO
               WRITE SCH.LIST ON PSS.CONTROL, JSL.ID
               RELEASE PSS.CONTROL, JSL.ID
               GOTO 100
             END
           END ELSE
             GOTO 100
           END
* T22102 ^
            GOTO 100
* T22102 v (add options "SO"rt, "PI" paper & ink, "U"nsched job , "P"rio)
        CASE OPTION = "SO"
           GOSUB SORT.JOBS
        CASE OPTION = "PI"
           GOSUB 600
           IF S$VALUE # "END" THEN
             JOB.NO = S$DATA(12)<S$SCR,S$VALUE>
             S$SCR = S$SCR + 1
             IF S$DATA(57)<S$SCR,S$VALUE> = "*" THEN
               CALL PAPER.AND.INK.DISPLAY(JOB.NO, DEPT, CCTR, 1, CONO)
             END ELSE
               TCOMP = S$DATA(51)<S$SCR,S$VALUE>
               CALL PAPER.AND.INK.DISPLAY(JOB.NO, DEPT, CCTR, TCOMP, CONO)  
             END
             S$SCR = S$SCR - 1
             *
             GOSUB REDISP.SCREEN
             *
           END
        CASE OPTION = "U"
           GOSUB 600
           IF S$VALUE # "END" THEN
             JOB.NO = S$DATA(12)<S$SCR,S$VALUE>
             CDATE = S$DATA(53)<S$SCR,S$VALUE>
             LOCATE JOB.NO IN UNSCHED.LIST<1> SETTING POS THEN
               ERRMSG = "Selected Job Has Already Been Unscheduled"
               GOSUB 90000
               GOTO 500
             END ELSE
               SPTR = 1
               MATREAD JBS.REC FROM JOB.SCHED, CONO:JOB.NO THEN
                 LOCATE TEMP.TRAN<S$VALUE> IN JBS.TRAN<1> SETTING SPTR ELSE SPTR = 1
               END
               UNSCHED.LIST<1,-1> = JOB.NO
               UNSCHED.SPTR<1,-1> = SPTR
               UNSCHED.DUE<1,-1> = CDATE
               ACTION = ""
               ALL.FLG = 0
               EPTR = DCOUNT(JBS.DEPT,VM)
               CALL UNSCHED.JOB.SUB(CONO,ACTION,JOB.NO,TODAY,SPTR,EPTR,CDATE,ALL.FLG)
               GOSUB REDISP.SCREEN
             END
           END
         CASE OPTION = "P"
           GOSUB 600
           IF S$VALUE # "END" THEN
             REF = S$VALUE
             IF S$DATA(57)<S$SCR,REF> # "*" THEN
               ERRMSG = "You May Only Change Priority of Unscheduled Jobs"
               GOSUB 90000
             END ELSE
               GOSUB 50000
               S$VAL = REF
               SCREEN FIELD;;54
               SCREEN INPUT;;54
               IF S$VALUE # "END" THEN
                 JID = S$DATA(12)<S$SCR,REF>
                 LOCATE JID IN UNSCHED.LIST<1> SETTING POS THEN
                   UNSCHED.PRI<1,POS> = S$VALUE
                 END
               END
             END
           END
* T22102 ^
         CASE OPTION = "F"
* T22102 v (new file time logic at CASE OPTION = "F")
           *
           * If you want to re-sort the jobs before re-scheduling them,
           *   just un-comment the following line...
           *GOSUB PROCESS.SORT
           *
           * We need to reschedule the unscheduled jobs now...
           FOR RNO = 1 TO DCOUNT(UNSCHED.LIST, @VM)
             JOB.NO = UNSCHED.LIST<1,RNO>
             MATREAD JBS.REC FROM JOB.SCHED, CONO:JOB.NO ELSE MAT JBS.REC = ""
             SPTR = UNSCHED.SPTR<1,RNO>
             EPTR = DCOUNT(JBS.DEPT, @VM)
             BCK.FLG = "M"
             DUE.DATE = UNSCHED.DUE<1,RNO>
             ACTION = ""
             REV.DATE = DATE()
             CALL GEN.JOB.SCHED.FWD(CONO,ACTION,JOB.NO,REV.DATE,TODAY,DUE.DATE,SPTR,EPTR,BCK.FLG)
             * Maybe ask them if the new due.date is acceptable??
           NEXT RNO
           GOTO 100
* T22102 ^
         CASE NUM(OPTION) AND OPTION > 0 AND OPTION <= LINE.CNT AND LINE.CNT > 0
            IF S$DATA(17)<S$SCR,OPTION> # "" THEN
               ERRMSG = "Cannot change due to the status"
               GOSUB 90000
               GOTO 500
            END
* T22102 v (new logic at CASE NUM(OPTION))
           * If the job is unscheduled, take them right into maintenance
           IF S$DATA(57)<S$SCR,OPTION> = "*" THEN
              JOB.NO = S$DATA(12)<S$SCR,OPTION>
              PARAM = "SM"
              PARAM<1,2> = "AUTO"
              PARAM<1,3> = JOB.NO
              PARAM<1,4> = DIV.OWNER
              CALL PERFORM.PROG ("JOB.SCHED.DET.MAINT",PARAM)
              GOSUB REDISP.SCREEN
              GOTO 500
           END
* T22102 ^
            REF = OPTION
            GOSUB 50000
            GOSUB 10000
            S$DATA(10)<S$SCR,REF> = ""
            IF S$VALUE = "END" THEN
               S$DATA(16)<S$SCR,REF> = ""
               CURR.REF.NO = ""
               GOSUB 50000
            END
         CASE 1
            ERRMSG = "Invalid Selection"
            GOSUB 90000
      END CASE
      GOTO 500
*
*---- GET LINE REFERENCE NUMBER
*
600*
      SCREEN FIELD;;9
      S$MINV = CURR.REF.NO
      S$MAXV = S$MINV + LINE.COUNT - 1
      IF S$MAXV > LINE.CNT THEN S$MAXV = LINE.CNT
      SCREEN INPUT;;9
      RETURN
*
*---- GET REVISE DATE AND RESCHEDULE THE JOB
*
10000*
      REC.LOCK = 0
      JOB.NO = S$DATA(12)<S$SCR,REF>
      CDATE = S$DATA(14)<S$SCR,REF>
*---- TASK 19407
      MATREAD JOB.REC FROM JOB, CONO:JOB.NO THEN
         IF JOB.DIV # DIV.OWNER THEN
            ERRMSG = "Job not owned by selected division ":DIV.OWNER
            GOSUB 90000
            GOTO 18888
         END
      END ELSE
         MATREAD JBS.REC FROM JOB.SCHED, CONO:JOB.NO ELSE
            MAT JBS.REC=''
         END
         IF JBS.DIV # DIV.OWNER THEN
            ERRMSG = "JOB NUMBER ":JOB.NO:" NOT IN JOB FILE"
            GOSUB 90000
            GOTO 18888
         END
      END
*---- TASK 19407
      MATREADU JBS.REC FROM JOB.SCHED, CONO:JOB.NO LOCKED REC.LOCK = 1 ELSE
         ERRMSG = "JOB.SCHED record is missing"
         GOSUB 90000
         GOTO 18888
      END
      IF REC.LOCK THEN
         ERRMSG = "JOB.SCHED record is locked"
         GOSUB 90000
         GOTO 19999
      END
      MATREAD CCTR.SCHED.REC FROM CCTR.SCHED, CONO:CCTR:"*":CDATE ELSE MAT CCTR.SCHED.REC = ""
      PTR = 1
      LOOP
      WHILE PTR DO
         LOCATE JOB.NO IN CCS.JOB<1>,PTR SETTING FND ELSE
            PTR = 0
            FND = 0
         END
         BEGIN CASE
            CASE PTR = 0
            CASE CCS.TRAN<1,FND> = ""
               PTR = FND + 1
            CASE CCS.TRAN<1,FND> = TEMP.TRAN<REF>
               PTR = 0
            CASE 1
               PTR = FND + 1
         END CASE
      REPEAT
      IF FND = 0 THEN
         ERRMSG = "ERROR in CCTR.SCHED record"
         GOSUB 90000
         GOTO 18888
      END
      PTR = 1
      LOOP
      WHILE PTR DO
         LOCATE TEMP.TRAN<REF> IN JBS.TRAN<1>,PTR SETTING FND ELSE
            PTR = 0
            FND = 0
         END
         BEGIN CASE
            CASE PTR = 0
            CASE CCTR # JBS.CCTR<1,FND>
               PTR = FND + 1
            CASE JBS.SCH.DATE<1,FND> = ""
               PTR = FND + 1
            CASE JBS.EXP.DATE<1,FND> = ""
               PTR = FND + 1
            CASE JBS.SCH.DATE<1,FND> > CDATE
               PTR = FND + 1
            CASE JBS.EXP.DATE<1,FND> < CDATE
               PTR = FND + 1
            CASE 1
               PTR = 0
         END CASE
      REPEAT
      IF FND = 0 THEN
         ERRMSG = "Could not match CCTR.SCHED and JOB.SCHED records"
         GOSUB 90000
         GOTO 18888
      END
      IF JBS.DEPT.STATUS<1,FND> # "" THEN
         ERRMSG = "Status was modified in JOB.SCHED record"
         GOSUB 90000
         GOTO 18888
      END
      SPTR = FND
      EPTR = DCOUNT(JBS.DEPT,VM)
      SBLK = 0
      FOR PTR = SPTR - 1 TO 1 STEP - 1 UNTIL SBLK
         BEGIN CASE
            CASE JBS.DEPT.STATUS<1,PTR> # ""
            CASE JBS.USD.HRS<1,PTR> >= JBS.SCH.HRS<1,PTR>
            CASE 1
               SBLK = 1
         END CASE
      NEXT PTR
      IF SBLK THEN
         ERRMSG = "Job is partially scheduled. Must use the schedule process"
         GOSUB 90000
         GOTO 18888
      END
11000*
      S$VAL = REF
      S$DATA(16)<S$SCR,REF> = ""
      SCREEN FIELD;;16
      SCREEN INPUT;;16;GOTO 18888
* T20899
      DATE.VALUE = ICONV(S$VALUE,"D")
      IF DATE.VALUE # "" THEN S$VALUE = DATE.VALUE
* T20899
      BEGIN CASE
         CASE S$VALUE = "???"
            S$DATA(16)<S$SCR,REF> = ""
            PARAM = "I"
            PARAM<1,2> = "AUTO"
            PARAM<1,3> = JOB.NO
            CALL SI_PERFORM.PROG ("JOB.SCHED.DET.MAINT",PARAM)
            SCREEN FORMAT
            GOSUB 60000
            CURR.REF.NO = ""
            GOSUB 50000
* T22102 v   (new logic to "I"nquire on job maintenance screen)
        CASE S$VALUE = "I"
           S$DATA(16)<S$SCR,REF> = ""
           PARAM = "I"
           PARAM<1,2> = "AUTO"
           PARAM<1,3> = JOB.NO
           CALL PERFORM.PROG ("JOB.SCHED.DET.MAINT",PARAM)
           SCREEN FORMAT
           GOSUB 60000
           CURR.REF.NO = ""
           GOSUB 50000
  * T22102 ^
  * T22102 v   (new logic to "M"odify job maintenance screen info)
         CASE S$VALUE = "M"
           * New for T21743
           SCREEN FIELD;;55
           SCREEN INPUT;;55
           S$DATA(16)<S$SCR,REF> = ""
           IF S$VALUE # "END" AND S$VALUE # "N" THEN
             *
             * No need to re-unschedule a job!  Just take them into maintenance.
             LOCATE JOB.NO IN UNSCHED.LIST<1> SETTING POS ELSE
               UNSCHED.LIST<1,-1> = JOB.NO
               UNSCHED.SPTR<1,-1> = SPTR
               UNSCHED.DUE<1,-1> = S$DATA(53)<S$SCR,REF>
               ACTION = ""
               ALL.FLG = 0
               CALL UNSCHED.JOB.SUB(CONO,ACTION,JOB.NO,TODAY,SPTR,EPTR,CDATE,ALL.FLG)
             END
             *
             PARAM = "SM"
             PARAM<1,2> = "AUTO"
             PARAM<1,3> = JOB.NO
             PARAM<1,4> = DIV.OWNER
             CALL PERFORM.PROG ("JOB.SCHED.DET.MAINT",PARAM)
             GOSUB REDISP.SCREEN
             GOTO 18888
           END
* T22102 ^
         CASE NOT(NUM(S$VALUE))
            ERRMSG = "Invalid date."
            GOSUB 90000
         CASE S$VALUE < TODAY
            ERRMSG = "Invalid date. The date can not be less than today's date."
            GOSUB 90000
         CASE S$VALUE <= CDATE
            ERRMSG = "Must use unschedule and schedule process"
            GOSUB 90000
         CASE 1
            REV.DATE = S$VALUE
            GOTO 12000
      END CASE
      GOTO 11000
12000*
* T20899
      S$DATA(16)<S$SCR,REF> = OCONV(S$VALUE,"D2/")
      SCREEN DISPLAY;;16
* T20899
      S$DATA(10)<S$SCR> = ""
      SCREEN FIELD;;10
      SCREEN INPUT;;10;GOTO 18888
      IF S$VALUE = "N" THEN GOTO 11000
      ACTION = ""
      ALL.FLG = 0
      CALL UNSCHED.JOB.SUB(CONO,ACTION,JOB.NO,TODAY,SPTR,EPTR,CDATE,ALL.FLG)
      P_X = 3 ; P_Y = 23 ; P_VALUE = "NOW PROCESSING SCHEDULE ROUTINE" ; P_OPT = "CL"
      CALL VSI_SI_PLINE(P_X,P_Y,P_VALUE,P_OPT)
      BCK.FLG = "M"
      DUE.DATE = ""
      CALL GEN.JOB.SCHED.FWD(CONO,ACTION,JOB.NO,REV.DATE,TODAY,DUE.DATE,SPTR,EPTR,BCK.FLG)
      IF ACTION = "E" THEN
         SBLK = 1
      END ELSE
         IF DUE.DATE > JBS.DUE.DATE THEN
            * T22102 - (On line below) RENEE changed from 24 to 10 like Rev10b
            SCREEN FIELD;;10
            S$PMSG = "New calculated due date is - ": OCONV(DUE.DATE,"D2/") :". Accept (Y/N)"
            * T22102 - (On line below) RENEE changed from 24 to 10 like Rev10b
            SCREEN INPUT;;10
            IF S$VALUE # "Y" THEN SBLK = 1 ELSE SBLK = 0
            S$VALUE = ""
         END ELSE
            SBLK = 0
         END
      END
      IF SBLK AND SPTR > 0 AND EPTR > 0 AND REV.DATE # "" THEN
         ALL.FLG = 0
         CALL UNSCHED.JOB.SUB(CONO,ACTION,JOB.NO,TODAY,SPTR,EPTR,REV.DATE,ALL.FLG)
      END
*
*--- BUILD JOB.CRTL.DATE.EXC
*
      CALL JOB.CRTL.DATE.EXC.UPD (CONO,JOB.NO)
      S$DATA(11)<S$SCR> = ""
      S$DATA(12)<S$SCR> = ""
      S$DATA(13)<S$SCR> = ""
      S$DATA(14)<S$SCR> = ""
      S$DATA(15)<S$SCR> = ""
      S$DATA(16)<S$SCR> = ""
      S$DATA(17)<S$SCR> = ""
      LINE.CNT = 0
      TEMP.TRAN = ""
      FOR CDATE = SDATE TO EDATE
         GOSUB 40000
      NEXT CDATE
      CURR.REF.NO = ""
      IF REF > LINE.CNT THEN REF = LINE.CNT
      IF REF < 1 THEN REF = 1
      GOSUB 50000
18888*
      RELEASE JOB.SCHED, CONO:JOB.NO
19999*
      RETURN
*
*---- LOAD S$DATA MATRIX
*
40000*
      MATREAD CCTR.SCHED.REC FROM CCTR.SCHED, CONO:CCTR:"*":CDATE ELSE
         MAT CCTR.SCHED.REC = ""
      END
41000*
      ALL.JOB = ""
      ALL.HRS = ""
      ALL.STAT = ""
      ALL.TRAN = ""
*--- SUMMARY BY EQUIP BY SHIFT
      JCNT = DCOUNT(CCS.JOB,VM)
      FOR JB = JCNT TO 1 STEP - 1
         IF CCS.JOB<1,JB> = "" THEN GOTO 41099
* T22102 (on line below, locate job in unscheduled list)
         LOCATE CCS.JOB<1,JB> IN UNSCHED.LIST<1> SETTING POS THEN GOTO 41099
*--- TASK 19407
         MATREAD JOB.REC FROM JOB, CONO:CCS.JOB<1,JB> THEN
            IF JOB.DIV # DIV.OWNER THEN GOTO 41099
         END ELSE
            MATREAD JBS.REC FROM JOB.SCHED, CONO:CCS.JOB<1,JB> THEN
               IF JBS.DIV # DIV.OWNER THEN GOTO 41099
            END
         END
*--- TASK 19407
         IF CCS.TRAN<1,JB> = "" THEN GOTO 41099
         IF CCS.JOB.HRS<1,JB> + 0 = 0 THEN GOTO 41099
         IF CCS.JOB.EQUIP<1,JB> + 0 = 0 THEN GOTO 41099
         EQP = CCS.JOB.EQUIP<1,JB>
         BEGIN CASE
            CASE CCS.JOB.SHIFT<1,JB> = 1
               SFT = 1
            CASE CCS.JOB.SHIFT<1,JB> = 2
               SFT = 2
            CASE 1
               SFT = 3
         END CASE
         PTR = 1
         LOOP
         WHILE PTR DO
            LOCATE CCS.JOB<1,JB> IN ALL.JOB<EQP,SFT>,PTR SETTING FND ELSE
               FND = 0
               PTR = 0
            END
            BEGIN CASE
               CASE PTR = 0
               CASE CCS.TRAN<1,JB> = ALL.TRAN<EQP,SFT,FND>
                  PTR = 0
               CASE 1 
                  PTR = FND + 1
            END CASE
         REPEAT
         IF FND THEN
            ALL.HRS<EQP,SFT,FND> = ALL.HRS<EQP,SFT,FND> + CCS.JOB.HRS<1,JB>
            IF ALL.STAT<EQP,SFT,FND> = "" AND CCS.OPER.STATUS<1,JB> # "" THEN
               ALL.STAT<EQP,SFT,FND> = CCS.OPER.STATUS<1,JB>
            END
         END ELSE
            ALL.JOB = INSERT(ALL.JOB,EQP,SFT,1,CCS.JOB<1,JB>)
            ALL.TRAN = INSERT(ALL.TRAN,EQP,SFT,1,CCS.TRAN<1,JB>)
            ALL.HRS = INSERT(ALL.HRS,EQP,SFT,1,CCS.JOB.HRS<1,JB>)
            ALL.STAT = INSERT(ALL.STAT,EQP,SFT,1,CCS.OPER.STATUS<1,JB>)
         END
41099*
      NEXT JB
*--- SUMMARY BY EQUIP
41100*
      XEQP = ""
      XJOB = ""
      XHRS = ""
      XSTAT = ""
      XTRAN = ""
      ECNT = DCOUNT(ALL.JOB,AM)
      FOR EQP = 1 TO ECNT
         SCNT = DCOUNT(ALL.JOB<EQP>,VM)
         IF SCNT > 2 THEN
            JCNT = DCOUNT(ALL.JOB<EQP,3>,SVM)
            FOR JB = JCNT TO 1 STEP - 1
               JOB.NO = ALL.JOB<EQP,3,JB>
               HRS = ALL.HRS<EQP,3,JB>
               STAT = ALL.STAT<EQP,3,JB>
               TRAN = ALL.TRAN<EQP,3,JB>
               PTR = 1
               LOOP
               WHILE PTR DO
                  LOCATE JOB.NO IN ALL.JOB<EQP,2>,PTR SETTING FND ELSE
                     FND = 0
                     PTR = 0
                  END
                  BEGIN CASE
                     CASE PTR = 0
                     CASE TRAN = ALL.TRAN<EQP,2,FND>
                        PTR = 0
                     CASE 1
                        PTR = FND + 1
                  END CASE
               REPEAT
               IF FND THEN
                  HRS = HRS + ALL.HRS<EQP,2,FND>
                  IF STAT = "" AND ALL.STAT<EQP,2,FND> # "" THEN
                     STAT = ALL.STAT<EQP,2,FND>
                  END
                  ALL.JOB = DELETE(ALL.JOB,EQP,3,JB)
                  ALL.HRS = DELETE(ALL.HRS,EQP,3,JB)
                  ALL.STAT = DELETE(ALL.STAT,EQP,3,JB)
                  ALL.TRAN = DELETE(ALL.TRAN,EQP,3,JB)
                  ALL.JOB = DELETE(ALL.JOB,EQP,2,FND)
                  ALL.HRS = DELETE(ALL.HRS,EQP,2,FND)
                  ALL.STAT = DELETE(ALL.STAT,EQP,2,FND)
                  ALL.TRAN = DELETE(ALL.TRAN,EQP,2,FND)
                  TF = DCOUNT(ALL.JOB<EQP,2>,VM) + 1
                  ALL.JOB = INSERT(ALL.JOB,EQP,2,TF,JOB.NO)
                  ALL.HRS = INSERT(ALL.HRS,EQP,2,TF,HRS)
                  ALL.STAT = INSERT(ALL.STAT,EQP,2,TF,STAT)
                  ALL.TRAN = INSERT(ALL.TRAN,EQP,2,TF,TRAN)
               END
            NEXT JB
         END
         IF SCNT > 1 THEN
            JCNT = DCOUNT(ALL.JOB<EQP,1>,SVM)
            FOR JB = JCNT TO 1 STEP - 1
               JOB.NO = ALL.JOB<EQP,1,JB>
               HRS = ALL.HRS<EQP,1,JB>
               STAT = ALL.STAT<EQP,1,JB>
               TRAN = ALL.TRAN<EQP,1,JB>
               PTR = 1
               LOOP
               WHILE PTR DO
                  LOCATE JOB.NO IN ALL.JOB<EQP,2>,PTR SETTING FND ELSE
                     FND = 0
                     PTR = 0
                  END
                  BEGIN CASE
                     CASE PTR = 0
                     CASE TRAN = ALL.TRAN<EQP,2,FND>
                        PTR = 0
                     CASE 1
                        PTR = FND + 1
                  END CASE
               REPEAT
               IF FND THEN
                  HRS = HRS + ALL.HRS<EQP,2,FND>
                  IF STAT = "" AND ALL.STAT<EQP,2,FND> # "" THEN
                     STAT = ALL.STAT<EQP,2,FND>
                  END
                  ALL.JOB = DELETE(ALL.JOB,EQP,1,JB)
                  ALL.HRS = DELETE(ALL.HRS,EQP,1,JB)
                  ALL.STAT = DELETE(ALL.STAT,EQP,1,JB)
                  ALL.TRAN = DELETE(ALL.TRAN,EQP,1,JB)
                  ALL.JOB = DELETE(ALL.JOB,EQP,2,FND)
                  ALL.HRS = DELETE(ALL.HRS,EQP,2,FND)
                  ALL.STAT = DELETE(ALL.STAT,EQP,2,FND)
                  ALL.TRAN = DELETE(ALL.TRAN,EQP,2,FND)
                  TF = 1
                  ALL.JOB = INSERT(ALL.JOB,EQP,2,TF,JOB.NO)
                  ALL.HRS = INSERT(ALL.HRS,EQP,2,TF,HRS)
                  ALL.STAT = INSERT(ALL.STAT,EQP,2,TF,STAT)
                  ALL.TRAN = INSERT(ALL.TRAN,EQP,2,TF,TRAN)
               END
            NEXT JB
         END
         FOR SFT = SCNT TO 1 STEP - 1
            JCNT = DCOUNT(ALL.JOB<EQP,SFT>,SVM)
            FOR JB = JCNT TO 1 STEP - 1
               XEQP<EQP> = EQP
               XJOB = INSERT(XJOB,EQP,1,0,ALL.JOB<EQP,SFT,JB>)
               XHRS = INSERT(XHRS,EQP,1,0,ALL.HRS<EQP,SFT,JB>)
               XSTAT = INSERT(XSTAT,EQP,1,0,ALL.STAT<EQP,SFT,JB>)
               XTRAN = INSERT(XTRAN,EQP,1,0,ALL.TRAN<EQP,SFT,JB>)
            NEXT JB
         NEXT SFT
      NEXT EQP
      ALL.JOB = ""
      ALL.HRS = ""
      ALL.STAT = ""
      ALL.TRAN = ""
      ECNT = DCOUNT(XEQP,AM)
      FOR EQP = ECNT TO 1 STEP - 1
         IF XEQP<EQP> = "" THEN
            XEQP = DELETE(XEQP,EQP,0,0)
            XJOB = DELETE(XJOB,EQP,0,0)
            XHRS = DELETE(XHRS,EQP,0,0)
            XSTAT = DELETE(XSTAT,EQP,0,0)
            XTRAN = DELETE(XTRAN,EQP,0,0)
         END
      NEXT EQP
*--- LOAD THE DAY
41200*
      ECNT = DCOUNT(XEQP,AM)
      FOR EQP = 1 TO ECNT
         JCNT = DCOUNT(XJOB<EQP>,VM)
         FOR JB = 1 TO JCNT
            JOB.NO = XJOB<EQP,JB>
            MATREAD JBS.REC FROM JOB.SCHED, CONO : JOB.NO ELSE
               MAT JBS.REC = ""
               JBS.CUST.NAME = "NOT ON FILE"
            END
*---- TASK # 19937 ----
            JDESC = JBS.CUST.NAME
            IF CO.PSS.JDESC.FLAG = "J" OR CO.PSS.JDESC.FLAG = "X" THEN
               MATREAD JOB.REC FROM JOB, CONO:JOB.NO THEN
                  IF TRIM(JOB.DESC<1,1>) # "" THEN
                     IF CO.PSS.JDESC.FLAG = "J" THEN
                        JDESC = JOB.DESC<1,1>
                     END ELSE
                        JDESC = JDESC[1,10]:":":JOB.DESC<1,1>
                     END
                  END
               END
            END
*----------------------
            LINE.CNT = LINE.CNT + 1
* T22102 v
            MATREAD JOB.REC FROM JOB, CONO:JOB.NO ELSE MAT JOB.REC = ""
            S$DATA(52)<S$SCR,LINE.CNT> = JOB.CATG
            S$DATA(53)<S$SCR,LINE.CNT> = OCONV(JOB.TRACK.DATE<1,4>,"D2/")
            TTRAN = XTRAN<EQP,JB>
            COMP.DISP = ""
            LOCATE TTRAN IN JBS.TRAN<1> SETTING POS THEN
              COMP.DISP = JBS.COMP.NO<1,POS,1>
            END
            S$DATA(51)<S$SCR,LINE.CNT> = COMP.DISP
* T22102 ^
            S$DATA(12)<S$SCR,LINE.CNT> = JOB.NO
*---- TASK # 19937 ----
*           S$DATA(13)<S$SCR,LINE.CNT> = JBS.CUST.NAME
            S$DATA(13)<S$SCR,LINE.CNT> = JDESC
*----------------------
            S$DATA(14)<S$SCR,LINE.CNT> = CDATE
            S$DATA(15)<S$SCR,LINE.CNT> = XHRS<EQP,JB>
            IF XSTAT<EQP,JB> # "" THEN
               S$DATA(17)<S$SCR,LINE.CNT> = XSTAT<EQP,JB>
            END
            TEMP.TRAN<LINE.CNT> = XTRAN<EQP,JB>
         NEXT JB
      NEXT EQP
      XEQP = ""
      XJOB = ""
      XHRS = ""
      XSTAT = ""
      XTRAN = ""
      RETURN
*
*---- DISPLAY MULTI-VALUE DATA
*
50000*
      START.REF.NO = 1 + INT((REF-1)/LINE.COUNT)*LINE.COUNT
      IF START.REF.NO = CURR.REF.NO THEN RETURN
      CURR.REF.NO = START.REF.NO
      S$VAL = START.REF.NO
      S$CNT = LINE.CNT
* T22102 (on line below added 51, 52, 53, 54 and 57 to end of line)
      SCREEN MULTI;;C;11;12;13;14;15;16;17;51;52;53;54;57
      RETURN
*
*---- DISPLAY ALL DATA
*
60000*
      SCREEN DISPLAY;;ALL
      RETURN
* T22102 v (Redisplay after unscheduling a job)
65000*
      LINE.CNT = 0
      TEMP.TRAN = ""
      FOR CDATE = SDATE TO EDATE
         GOSUB 40000
      NEXT CDATE
      *
      * Put unscheduled jobs at end of list
      FOR UJNO = 1 TO DCOUNT(UNSCHED.LIST, @VM)
        JID = UNSCHED.LIST<1,UJNO>
        MATREAD JOB.REC FROM JOB, CONO:JID ELSE MAT JOB.REC = ""
        MATREAD JBS.REC FROM JOB.SCHED, CONO:JID ELSE MAT JBS.REC = ""
        *
        LINE.CNT = LINE.CNT + 1
        S$DATA(12)<S$SCR,LINE.CNT> = JID
        S$DATA(57)<S$SCR,LINE.CNT> = "*"
        S$DATA(52)<S$SCR,LINE.CNT> = JOB.CATG
        S$DATA(53)<S$SCR,LINE.CNT> = OCONV(JOB.TRACK.DATE<1,4>,"D2/")
        S$DATA(13)<S$SCR,LINE.CNT> = JBS.CUST.NAME
        S$DATA(54)<S$SCR,LINE.CNT> = UNSCHED.PRI<1,UJNO>
        S$DATA(53)<S$SCR,LINE.CNT> = UNSCHED.DUE<1,UJNO>
      NEXT UJNO
      * 
      RETURN
*
**********
SORT.JOBS:
**********
* Entire sorting logic added for T21743
**********
IF DCOUNT(UNSCHED.LIST, @VM) >= 2 THEN
  *
  * Prompt for which type of sort...
  S$SCR = S$SCR + 1
  CALL SORT.OPTIONS.MAINT(SORT.OPTIONS)
  S$SCR = S$SCR - 1
  *
  * Process the sort
  GOSUB PROCESS.SORT
  *
  GOSUB REDISP.SCREEN
  *
END
*
RETURN
*
*************
PROCESS.SORT:
*************
* You can call this routine at any time, followed by a call to REDISP.SCREEN
*   to resort the internal variable UNSCHED.LIST using the last sort
*   criteria specified by the user.
*************
SORT.ARRAY = ""
NEW.LIST = ""
*
LCNT = DCOUNT(UNSCHED.LIST, @VM)
FOR LNO = 1 TO LCNT
  TJNO = UNSCHED.LIST<1,LNO>
  MATREAD JOB.REC FROM JOB, CONO:TJNO ELSE MAT JOB.REC = ""
  MAT EST.REC = ""
  IF JOB.EST # "" THEN
    MATREAD EST.REC FROM ESTIMATE, CONO:JOB.EST ELSE MAT EST.REC = ""
  END
  GOSUB GET.SORT.VALS
  CALL SORTED.ARRAY.INSERT(LNO, NEW.LIST, SORT.VAL, SORT.ARRAY, SORT.SEQ)
NEXT LNO
*
N.UNSCHED.LIST = ""
N.UNSCHED.SPTR = ""
N.UNSCHED.PRI  = ""
N.UNSCHED.DUE  = ""
FOR XX = 1 TO DCOUNT(NEW.LIST, @AM)
  TPOS = NEW.LIST<XX>
  N.UNSCHED.LIST<1,-1> = UNSCHED.LIST<1,TPOS>
  N.UNSCHED.SPTR<1,-1> = UNSCHED.SPTR<1,TPOS>
  N.UNSCHED.PRI<1,-1>  = UNSCHED.PRI<1,TPOS>
  N.UNSCHED.DUE<1,-1>  = UNSCHED.DUE<1,TPOS>
NEXT XX
*
UNSCHED.LIST = N.UNSCHED.LIST
UNSCHED.SPTR = N.UNSCHED.SPTR
UNSCHED.PRI  = N.UNSCHED.PRI
UNSCHED.DUE  = N.UNSCHED.DUE
*
RETURN
*
**************
GET.SORT.VALS:
**************
MAT SORT.VALS = ""
SORT.SEQ = ""
*
NUM.SORTS = DCOUNT(SORT.OPTIONS, @AM)
FOR SORT.POS = 1 TO NUM.SORTS
  TSEQ = SORT.OPTIONS<SORT.POS,1>
  TTYPE = SORT.OPTIONS<SORT.POS,2>
  BEGIN CASE
    CASE TTYPE = "I"
      GOSUB GET.INK.SORT
      SORT.VALS(SORT.POS) = INK.SORT.OUT
    CASE TTYPE = "PA"
      GOSUB GET.PAPER.SORT
      SORT.VALS(SORT.POS) = PAPER.SORT.OUT
    CASE TTYPE = "PR"
      SORT.VALS(SORT.POS) = UNSCHED.PRI<1,LNO>
    CASE TTYPE = "D"
      SORT.VALS(SORT.POS) = UNSCHED.DUE<1,LNO>
  END CASE
  *
  SORT.SEQ<1,-1> = TSEQ
  *
NEXT SORT.POS
*
FOR XX = DCOUNT(SORT.OPTIONS, @AM) + 1 TO 4
  SORT.VALS(XX) = LNO
NEXT XX
*
SORT.VAL = ""
FOR XX = 1 TO 4
  SORT.VAL<1,-1> = SORT.VALS(XX)
NEXT XX
*
RETURN
*
***************
GET.PAPER.SORT:
***************
PAPER.SORT.OUT = EST.PROD.INV.ID<1,1>
IF PAPER.SORT.OUT = "" THEN
  PAPER.SORT.OUT = EST.PROD.OS.PROD<1,1>
END
*
RETURN
*
*************
GET.INK.SORT:
*************
INK.IDS = ""
INK.SORT = ""
T.INKS = EST.PROD.INK.ID<1,1>
FOR INK.NO = 1 TO DCOUNT(T.INKS, "!")
  ONE.INK = FIELD(T.INKS, "!", INK.NO)
  CALL SORTED.ARRAY.INSERT(INK.NO, INK.IDS, ONE.INK, INK.SORT, "A")
NEXT INK.NO
*
* Now, we have the list of sorted inks for this job stored multi-attributed in
* the variable INK.SORT.  We need to parse it out and get rid of the attribute
* marks.
INK.SORT.OUT = ""
FOR INK.NO = 1 TO DCOUNT(INK.SORT, @AM)
  ONE.INK = INK.SORT<INK.NO>
  INK.SORT.OUT = INK.SORT.OUT:' ':ONE.INK
NEXT INK.NO
*
RETURN
*
**************
CLEAR.COLUMNS:
**************
FOR XX = 11 TO 17
  S$DATA(XX)<S$SCR> = ""
NEXT XX
*
FOR XX = 51 TO 54
  S$DATA(XX)<S$SCR> = ""
NEXT XX
*
S$DATA(57)<S$SCR> = ""
*
RETURN
*
**************
REDISP.SCREEN:
**************
* Redisplay the Screen
**************
GOSUB CLEAR.COLUMNS
SCREEN FORMAT
GOSUB 65000
GOSUB 60000
CURR.REF.NO = ""
GOSUB 50000
*
RETURN
* T22102 ^
***(TPCHECKBEG)***************************************************
*
*---- CHECK FOR ACTIVE TRANSACTION
*
89900 *
      BEGIN CASE
         CASE PROC.TYPE = "M"
            READU LREC FROM PSS.LOCK, CONO:"TP" ELSE NULL
            REQDIV = DIV.OWNER
            CALL TRANSACTION.LOCK(CONO, REQDIV, TP.DIV, ERRMSG)
            BEGIN CASE
               CASE TP.DIV = "X"
                  RELEASE PSS.LOCK, CONO:"TP"
                  IF ERRMSG # TP.ERRMSG THEN GOSUB 90000
               CASE TP.DIV = ""
                  DCNT = DCOUNT(REQDIV,VM)
                  FOR DPTR = 1 TO DCNT
                     CDIV = REQDIV<1,DPTR>
                     LOCK.ID = "[":CONO:",":CDIV:",":@LOGNAME:" @ ":@TTY:"]"
                     READU LREC FROM PSS.LOCK, LOCK.ID ELSE NULL
                  NEXT DPTR
            END CASE
            RELEASE PSS.LOCK, CONO:"TP"
            TP.ERRMSG = ERRMSG
         CASE 1
            TP.DIV = ""
            DELETE PSS.LOCK, @TTY
            TP.ERRMSG = ""
      END CASE
      RETURN
***(TPCHECKEND)***************************************************
*
*---- ERROR ROUTINE
*
90000 ERR.TYPE=1;CALL SI_SYSCOM(MAT SYSCOM.REC);RETURN
* 90000*
*       PRINT @(0,23):CL:ERRMSG:
*       INPUT REPLY:
*       PRINT @(0,23):CL:
*       RETURN
*
*---- GENERAL RELEASE
*
98888*
      RELEASE
*
*---- END OF PROGRAM
*
999999*
SCREEN CLOSE
   END
